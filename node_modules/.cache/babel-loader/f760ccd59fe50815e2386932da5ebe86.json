{"ast":null,"code":"module.exports = function () {\n  throw new Error('call .point() or .polygon() instead');\n};\n\nfunction position(bbox) {\n  if (bbox) return coordInBBBOX(bbox);else return [lon(), lat()];\n}\n\nmodule.exports.position = position;\n\nmodule.exports.point = function (count, bbox) {\n  var features = [];\n\n  for (i = 0; i < count; i++) {\n    features.push(feature(bbox ? point(position(bbox)) : point()));\n  }\n\n  return collection(features);\n};\n\nmodule.exports.polygon = function (count, num_vertices, max_radial_length, bbox) {\n  if (typeof num_vertices !== 'number') num_vertices = 10;\n  if (typeof max_radial_length !== 'number') max_radial_length = 10;\n  var features = [];\n\n  for (i = 0; i < count; i++) {\n    var vertices = [],\n        circle_offsets = Array.apply(null, new Array(num_vertices + 1)).map(Math.random);\n    circle_offsets.forEach(sumOffsets);\n    circle_offsets.forEach(scaleOffsets);\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n    // center the polygon around something\n\n    vertices = vertices.map(vertexToCoordinate(position(bbox)));\n    features.push(feature(polygon([vertices])));\n  }\n\n  function sumOffsets(cur, index, arr) {\n    arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n  }\n\n  function scaleOffsets(cur, index) {\n    cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];\n    var radial_scaler = Math.random();\n    vertices.push([radial_scaler * max_radial_length * Math.sin(cur), radial_scaler * max_radial_length * Math.cos(cur)]);\n  }\n\n  return collection(features);\n};\n\nfunction vertexToCoordinate(hub) {\n  return function (cur, index) {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\n\nfunction lon() {\n  return rnd() * 360;\n}\n\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction point(coordinates) {\n  return {\n    type: 'Point',\n    coordinates: coordinates || [lon(), lat()]\n  };\n}\n\nfunction coordInBBBOX(bbox) {\n  return [Math.random() * (bbox[2] - bbox[0]) + bbox[0], Math.random() * (bbox[3] - bbox[1]) + bbox[1]];\n}\n\nfunction pointInBBBOX() {\n  return {\n    type: 'Point',\n    coordinates: [lon(), lat()]\n  };\n}\n\nfunction polygon(coordinates) {\n  return {\n    type: 'Polygon',\n    coordinates: coordinates\n  };\n}\n\nfunction feature(geom) {\n  return {\n    type: 'Feature',\n    geometry: geom,\n    properties: {}\n  };\n}\n\nfunction collection(f) {\n  return {\n    type: 'FeatureCollection',\n    features: f\n  };\n}","map":null,"metadata":{},"sourceType":"script"}