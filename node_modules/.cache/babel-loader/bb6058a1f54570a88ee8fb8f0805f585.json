{"ast":null,"code":"var point = require('turf-helpers').point;\n\nvar featurecollection = require('turf-helpers').featureCollection;\n\nvar distance = require('turf-distance');\n/**\n * Takes a bounding box and a cell depth and returns a set of {@link Point|points} in a grid.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSize the distance across each cell\n * @param {string} [units=kilometers] used in calculating cellWidth, can be degrees, radians, miles, or kilometers\n * @return {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellWidth = 3;\n * var units = 'miles';\n *\n * var grid = turf.pointGrid(extent, cellWidth, units);\n *\n * //=grid\n */\n\n\nmodule.exports = function pointGrid(bbox, cellSize, units) {\n  var fc = featurecollection([]);\n  var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);\n  var cellWidth = xFraction * (bbox[2] - bbox[0]);\n  var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);\n  var cellHeight = yFraction * (bbox[3] - bbox[1]);\n  var currentX = bbox[0];\n\n  while (currentX <= bbox[2]) {\n    var currentY = bbox[1];\n\n    while (currentY <= bbox[3]) {\n      fc.features.push(point([currentX, currentY]));\n      currentY += cellHeight;\n    }\n\n    currentX += cellWidth;\n  }\n\n  return fc;\n};","map":null,"metadata":{},"sourceType":"script"}