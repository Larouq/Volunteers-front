{"ast":null,"code":"/* eslint-disable */\n\n/*\n * Copyright (c) 2010, Jason Davies.\n *\n * All rights reserved.  This code is based on Bradley White's Java version,\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\n * on Paul D. Bourke's original Fortran version.  See below for the respective\n * copyright notices.\n *\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\n * paper by Paul D. Bourke.\n *\n * The vector conversion code is based on http://apptree.net/conrec.htm by\n * Graham Cox.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the <organization> nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Copyright (c) 1996-1997 Nicholas Yue\n *\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\n * Bourke's CONREC.F routine.\n *\n * The authors hereby grant permission to use, copy, and distribute this\n * software and its documentation for any purpose, provided that existing\n * copyright notices are retained in all copies and that this notice is\n * included verbatim in any distributions. Additionally, the authors grant\n * permission to modify this software and its documentation for any purpose,\n * provided that such modifications are not distributed without the explicit\n * consent of the authors and that existing copyright notices are retained in\n * all copies. Some of the algorithms implemented by this software are\n * patented, observe all applicable patent law.\n *\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\n * MODIFICATIONS.\n */\nmodule.exports = Conrec;\nvar EPSILON = 1e-10;\n\nfunction pointsEqual(a, b) {\n  var x = a.x - b.x,\n      y = a.y - b.y;\n  return x * x + y * y < EPSILON;\n}\n\nfunction reverseList(list) {\n  var pp = list.head;\n\n  while (pp) {\n    // swap prev/next pointers\n    var temp = pp.next;\n    pp.next = pp.prev;\n    pp.prev = temp; // continue through the list\n\n    pp = temp;\n  } // swap head/tail pointers\n\n\n  var temp = list.head;\n  list.head = list.tail;\n  list.tail = temp;\n}\n\nfunction ContourBuilder(level) {\n  this.level = level;\n  this.s = null;\n  this.count = 0;\n}\n\nContourBuilder.prototype.remove_seq = function (list) {\n  // if list is the first item, static ptr s is updated\n  if (list.prev) {\n    list.prev.next = list.next;\n  } else {\n    this.s = list.next;\n  }\n\n  if (list.next) {\n    list.next.prev = list.prev;\n  }\n\n  --this.count;\n};\n\nContourBuilder.prototype.addSegment = function (a, b) {\n  var ss = this.s;\n  var ma = null;\n  var mb = null;\n  var prependA = false;\n  var prependB = false;\n\n  while (ss) {\n    if (ma == null) {\n      // no match for a yet\n      if (pointsEqual(a, ss.head.p)) {\n        ma = ss;\n        prependA = true;\n      } else if (pointsEqual(a, ss.tail.p)) {\n        ma = ss;\n      }\n    }\n\n    if (mb == null) {\n      // no match for b yet\n      if (pointsEqual(b, ss.head.p)) {\n        mb = ss;\n        prependB = true;\n      } else if (pointsEqual(b, ss.tail.p)) {\n        mb = ss;\n      }\n    } // if we matched both no need to continue searching\n\n\n    if (mb != null && ma != null) {\n      break;\n    } else {\n      ss = ss.next;\n    }\n  } // c is the case selector based on which of ma and/or mb are set\n\n\n  var c = (ma != null ? 1 : 0) | (mb != null ? 2 : 0);\n\n  switch (c) {\n    case 0:\n      // both unmatched, add as new sequence\n      var aa = {\n        p: a,\n        prev: null\n      };\n      var bb = {\n        p: b,\n        next: null\n      };\n      aa.next = bb;\n      bb.prev = aa; // create sequence element and push onto head of main list. The order\n      // of items in this list is unimportant\n\n      ma = {\n        head: aa,\n        tail: bb,\n        next: this.s,\n        prev: null,\n        closed: false\n      };\n\n      if (this.s) {\n        this.s.prev = ma;\n      }\n\n      this.s = ma;\n      ++this.count; // not essential - tracks number of unmerged sequences\n\n      break;\n\n    case 1:\n      // a matched, b did not - thus b extends sequence ma\n      var pp = {\n        p: b\n      };\n\n      if (prependA) {\n        pp.next = ma.head;\n        pp.prev = null;\n        ma.head.prev = pp;\n        ma.head = pp;\n      } else {\n        pp.next = null;\n        pp.prev = ma.tail;\n        ma.tail.next = pp;\n        ma.tail = pp;\n      }\n\n      break;\n\n    case 2:\n      // b matched, a did not - thus a extends sequence mb\n      var pp = {\n        p: a\n      };\n\n      if (prependB) {\n        pp.next = mb.head;\n        pp.prev = null;\n        mb.head.prev = pp;\n        mb.head = pp;\n      } else {\n        pp.next = null;\n        pp.prev = mb.tail;\n        mb.tail.next = pp;\n        mb.tail = pp;\n      }\n\n      break;\n\n    case 3:\n      // both matched, can merge sequences\n      // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)\n      if (ma === mb) {\n        var pp = {\n          p: ma.tail.p,\n          next: ma.head,\n          prev: null\n        };\n        ma.head.prev = pp;\n        ma.head = pp;\n        ma.closed = true;\n        break;\n      } // there are 4 ways the sequence pair can be joined. The current setting of prependA and\n      // prependB will tell us which type of join is needed. For head/head and tail/tail joins\n      // one sequence needs to be reversed\n\n\n      switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {\n        case 0:\n          // tail-tail\n          // reverse ma and append to mb\n          reverseList(ma);\n        // fall through to head/tail case\n\n        case 1:\n          // head-tail\n          // ma is appended to mb and ma discarded\n          mb.tail.next = ma.head;\n          ma.head.prev = mb.tail;\n          mb.tail = ma.tail; //discard ma sequence record\n\n          this.remove_seq(ma);\n          break;\n\n        case 3:\n          // head-head\n          // reverse ma and append mb to it\n          reverseList(ma);\n        // fall through to tail/head case\n\n        case 2:\n          // tail-head\n          // mb is appended to ma and mb is discarded\n          ma.tail.next = mb.head;\n          mb.head.prev = ma.tail;\n          ma.tail = mb.tail; //discard mb sequence record\n\n          this.remove_seq(mb);\n          break;\n      }\n\n  }\n};\n/*\n * Implements CONREC.\n *\n * @private\n * @param {function} drawContour function for drawing contour.  Defaults to a\n *                               custom \"contour builder\", which populates the\n *                               contours property.\n */\n\n\nfunction Conrec(drawContour) {\n  if (!drawContour) {\n    var c = this;\n    c.contours = {};\n    /**\n     * drawContour - interface for implementing the user supplied method to\n     * render the countours.\n     *\n     * Draws a line between the start and end coordinates.\n     *\n     * @private\n     * @param startX    - start coordinate for X\n     * @param startY    - start coordinate for Y\n     * @param endX      - end coordinate for X\n     * @param endY      - end coordinate for Y\n     * @param contourLevel - Contour level for line.\n     */\n\n    this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {\n      var cb = c.contours[k];\n\n      if (!cb) {\n        cb = c.contours[k] = new ContourBuilder(contourLevel);\n      }\n\n      cb.addSegment({\n        x: startX,\n        y: startY\n      }, {\n        x: endX,\n        y: endY\n      });\n    };\n\n    this.contourList = function () {\n      var l = [];\n      var a = c.contours;\n\n      for (var k in a) {\n        var s = a[k].s;\n        var level = a[k].level;\n\n        while (s) {\n          var h = s.head;\n          var l2 = [];\n          l2.level = level;\n          l2.k = k;\n\n          while (h && h.p) {\n            l2.push(h.p);\n            h = h.next;\n          }\n\n          l.push(l2);\n          s = s.next;\n        }\n      }\n\n      l.sort(function (a, b) {\n        return a.k - b.k;\n      });\n      return l;\n    };\n  } else {\n    this.drawContour = drawContour;\n  }\n\n  this.h = new Array(5);\n  this.sh = new Array(5);\n  this.xh = new Array(5);\n  this.yh = new Array(5);\n}\n/*\n * contour is a contouring subroutine for rectangularily spaced data\n *\n * It emits calls to a line drawing subroutine supplied by the user which\n * draws a contour map corresponding to real*4data on a randomly spaced\n * rectangular grid. The coordinates emitted are in the same units given in\n * the x() and y() arrays.\n *\n * Any number of contour levels may be specified but they must be in order of\n * increasing value.\n *\n *\n * @param {number[][]} d - matrix of data to contour\n * @param {number} ilb,iub,jlb,jub - index bounds of data matrix\n *\n *             The following two, one dimensional arrays (x and y) contain\n *             the horizontal and vertical coordinates of each sample points.\n * @param {number[]} x  - data matrix column coordinates\n * @param {number[]} y  - data matrix row coordinates\n * @param {number} nc   - number of contour levels\n * @param {number[]} z  - contour levels in increasing order.\n */\n\n\nConrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {\n  var h = this.h,\n      sh = this.sh,\n      xh = this.xh,\n      yh = this.yh;\n  var drawContour = this.drawContour;\n  this.contours = {};\n\n  var xsect = function xsect(p1, p2) {\n    return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);\n  };\n\n  var ysect = function ysect(p1, p2) {\n    return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);\n  };\n\n  var m1;\n  var m2;\n  var m3;\n  var case_value;\n  var dmin;\n  var dmax;\n  var x1 = 0.0;\n  var x2 = 0.0;\n  var y1 = 0.0;\n  var y2 = 0.0; // The indexing of im and jm should be noted as it has to start from zero\n  // unlike the fortran counter part\n\n  var im = [0, 1, 1, 0];\n  var jm = [0, 0, 1, 1]; // Note that castab is arranged differently from the FORTRAN code because\n  // Fortran and C/C++ arrays are transposed of each other, in this case\n  // it is more tricky as castab is in 3 dimensions\n\n  var castab = [[[0, 0, 8], [0, 2, 5], [7, 6, 9]], [[0, 3, 4], [1, 3, 1], [4, 3, 0]], [[9, 6, 7], [5, 2, 0], [8, 0, 0]]];\n\n  for (var j = jub - 1; j >= jlb; j--) {\n    for (var i = ilb; i <= iub - 1; i++) {\n      var temp1, temp2;\n      temp1 = Math.min(d[i][j], d[i][j + 1]);\n      temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);\n      dmin = Math.min(temp1, temp2);\n      temp1 = Math.max(d[i][j], d[i][j + 1]);\n      temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);\n      dmax = Math.max(temp1, temp2);\n\n      if (dmax >= z[0] && dmin <= z[nc - 1]) {\n        for (var k = 0; k < nc; k++) {\n          if (z[k] >= dmin && z[k] <= dmax) {\n            for (var m = 4; m >= 0; m--) {\n              if (m > 0) {\n                // The indexing of im and jm should be noted as it has to\n                // start from zero\n                h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];\n                xh[m] = x[i + im[m - 1]];\n                yh[m] = y[j + jm[m - 1]];\n              } else {\n                h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);\n                xh[0] = 0.5 * (x[i] + x[i + 1]);\n                yh[0] = 0.5 * (y[j] + y[j + 1]);\n              }\n\n              if (h[m] > EPSILON) {\n                sh[m] = 1;\n              } else if (h[m] < -EPSILON) {\n                sh[m] = -1;\n              } else sh[m] = 0;\n            } //\n            // Note: at this stage the relative heights of the corners and the\n            // centre are in the h array, and the corresponding coordinates are\n            // in the xh and yh arrays. The centre of the box is indexed by 0\n            // and the 4 corners by 1 to 4 as shown below.\n            // Each triangle is then indexed by the parameter m, and the 3\n            // vertices of each triangle are indexed by parameters m1,m2,and\n            // m3.\n            // It is assumed that the centre of the box is always vertex 2\n            // though this isimportant only when all 3 vertices lie exactly on\n            // the same contour level, in which case only the side of the box\n            // is drawn.\n            //\n            //\n            //      vertex 4 +-------------------+ vertex 3\n            //               | \\               / |\n            //               |   \\    m-3    /   |\n            //               |     \\       /     |\n            //               |       \\   /       |\n            //               |  m=2    X   m=2   |       the centre is vertex 0\n            //               |       /   \\       |\n            //               |     /       \\     |\n            //               |   /    m=1    \\   |\n            //               | /               \\ |\n            //      vertex 1 +-------------------+ vertex 2\n            //\n            //\n            //\n            //               Scan each triangle in the box\n            //\n\n\n            for (m = 1; m <= 4; m++) {\n              m1 = m;\n              m2 = 0;\n\n              if (m != 4) {\n                m3 = m + 1;\n              } else {\n                m3 = 1;\n              }\n\n              case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];\n\n              if (case_value != 0) {\n                switch (case_value) {\n                  case 1:\n                    // Line between vertices 1 and 2\n                    x1 = xh[m1];\n                    y1 = yh[m1];\n                    x2 = xh[m2];\n                    y2 = yh[m2];\n                    break;\n\n                  case 2:\n                    // Line between vertices 2 and 3\n                    x1 = xh[m2];\n                    y1 = yh[m2];\n                    x2 = xh[m3];\n                    y2 = yh[m3];\n                    break;\n\n                  case 3:\n                    // Line between vertices 3 and 1\n                    x1 = xh[m3];\n                    y1 = yh[m3];\n                    x2 = xh[m1];\n                    y2 = yh[m1];\n                    break;\n\n                  case 4:\n                    // Line between vertex 1 and side 2-3\n                    x1 = xh[m1];\n                    y1 = yh[m1];\n                    x2 = xsect(m2, m3);\n                    y2 = ysect(m2, m3);\n                    break;\n\n                  case 5:\n                    // Line between vertex 2 and side 3-1\n                    x1 = xh[m2];\n                    y1 = yh[m2];\n                    x2 = xsect(m3, m1);\n                    y2 = ysect(m3, m1);\n                    break;\n\n                  case 6:\n                    //  Line between vertex 3 and side 1-2\n                    x1 = xh[m3];\n                    y1 = yh[m3];\n                    x2 = xsect(m1, m2);\n                    y2 = ysect(m1, m2);\n                    break;\n\n                  case 7:\n                    // Line between sides 1-2 and 2-3\n                    x1 = xsect(m1, m2);\n                    y1 = ysect(m1, m2);\n                    x2 = xsect(m2, m3);\n                    y2 = ysect(m2, m3);\n                    break;\n\n                  case 8:\n                    // Line between sides 2-3 and 3-1\n                    x1 = xsect(m2, m3);\n                    y1 = ysect(m2, m3);\n                    x2 = xsect(m3, m1);\n                    y2 = ysect(m3, m1);\n                    break;\n\n                  case 9:\n                    // Line between sides 3-1 and 1-2\n                    x1 = xsect(m3, m1);\n                    y1 = ysect(m3, m1);\n                    x2 = xsect(m1, m2);\n                    y2 = ysect(m1, m2);\n                    break;\n\n                  default:\n                    break;\n                } // Put your processing code here and comment out the printf\n                //printf(\"%f %f %f %f %f\\n\",x1,y1,x2,y2,z[k]);\n\n\n                drawContour(x1, y1, x2, y2, z[k], k);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}