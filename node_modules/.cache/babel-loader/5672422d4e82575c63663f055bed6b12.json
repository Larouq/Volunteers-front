{"ast":null,"code":"var linestring = require('turf-helpers').lineString;\n\nvar pointOnLine = require('turf-point-on-line');\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Feature<Point>} point1 starting point\n * @param {Feature<Point>} point2 stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @return {Feature<LineString>} sliced line\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var start = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.029609, 38.881946]\n *   }\n * };\n * var stop = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.021884, 38.889563]\n *   }\n * };\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //=line\n *\n * //=sliced\n */\n\n\nmodule.exports = function lineSlice(startPt, stopPt, line) {\n  var coords;\n\n  if (line.type === 'Feature') {\n    coords = line.geometry.coordinates;\n  } else if (line.type === 'LineString') {\n    coords = line.coordinates;\n  } else {\n    throw new Error('input must be a LineString Feature or Geometry');\n  }\n\n  var startVertex = pointOnLine(line, startPt);\n  var stopVertex = pointOnLine(line, stopPt);\n  var ends;\n\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n\n  var clipLine = linestring([ends[0].geometry.coordinates], {});\n\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipLine.geometry.coordinates.push(coords[i]);\n  }\n\n  clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);\n  return clipLine;\n};","map":null,"metadata":{},"sourceType":"script"}