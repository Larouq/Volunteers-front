{"ast":null,"code":"var distance = require('turf-distance');\n\nvar point = require('turf-helpers').point;\n\nvar bearing = require('turf-bearing');\n\nvar destination = require('turf-destination');\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.\n *\n * @name pointOnLine\n * @param {Feature<LineString>} line line to snap to\n * @param {Feature<Point>} point point to snap from\n * @return {Feature<Point>} closest point on the `line` to `point`\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var pt = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.037076, 38.884017]\n *   }\n * };\n *\n * var snapped = turf.pointOnLine(line, pt);\n * snapped.properties['marker-color'] = '#00f'\n *\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [line, pt, snapped]\n * };\n *\n * //=result\n */\n\n\nmodule.exports = function (line, pt) {\n  var coords;\n\n  if (line.type === 'Feature') {\n    coords = line.geometry.coordinates;\n  } else if (line.type === 'LineString') {\n    coords = line.coordinates;\n  } else {\n    throw new Error('input must be a LineString Feature or Geometry');\n  }\n\n  return pointOnLine(pt, coords);\n};\n\nfunction pointOnLine(pt, coords) {\n  var units = 'miles';\n  var closestPt = point([Infinity, Infinity], {\n    dist: Infinity\n  });\n\n  for (var i = 0; i < coords.length - 1; i++) {\n    var start = point(coords[i]);\n    var stop = point(coords[i + 1]); //start\n\n    start.properties.dist = distance(pt, start, units); //stop\n\n    stop.properties.dist = distance(pt, stop, units); //perpendicular\n\n    var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n    var direction = bearing(start, stop);\n    var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n    var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n    var intersect = lineIntersects(perpendicularPt1.geometry.coordinates[0], perpendicularPt1.geometry.coordinates[1], perpendicularPt2.geometry.coordinates[0], perpendicularPt2.geometry.coordinates[1], start.geometry.coordinates[0], start.geometry.coordinates[1], stop.geometry.coordinates[0], stop.geometry.coordinates[1]);\n    var intersectPt;\n\n    if (intersect) {\n      intersectPt = point(intersect);\n      intersectPt.properties.dist = distance(pt, intersectPt, units);\n    }\n\n    if (start.properties.dist < closestPt.properties.dist) {\n      closestPt = start;\n      closestPt.properties.index = i;\n    }\n\n    if (stop.properties.dist < closestPt.properties.dist) {\n      closestPt = stop;\n      closestPt.properties.index = i;\n    }\n\n    if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n      closestPt = intersectPt;\n      closestPt.properties.index = i;\n    }\n  }\n\n  return closestPt;\n} // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n\n\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2;\n  var result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY); // if line1 is a segment and line2 is infinite, they intersect if:\n\n  if (a > 0 && a < 1) {\n    result.onLine1 = true;\n  } // if line2 is a segment and line1 is infinite, they intersect if:\n\n\n  if (b > 0 && b < 1) {\n    result.onLine2 = true;\n  } // if line1 and line2 are segments, they intersect if both of the above are true\n\n\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}