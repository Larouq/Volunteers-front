{"ast":null,"code":"/* eslint-disable */\n\n/**\n  * BezierSpline\n  * https://github.com/leszekr/bezier-spline-js\n  *\n  * @private\n  * @copyright\n  * Copyright (c) 2013 Leszek Rybicki\n  *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n  * in the Software without restriction, including without limitation the rights\n  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  * copies of the Software, and to permit persons to whom the Software is\n  * furnished to do so, subject to the following conditions:\n  *\n  * The above copyright notice and this permission notice shall be included in all\n  * copies or substantial portions of the Software.\n  *\n  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  * SOFTWARE.\n  */\nvar Spline = function Spline(options) {\n  this.points = options.points || [];\n  this.duration = options.duration || 10000;\n  this.sharpness = options.sharpness || 0.85;\n  this.centers = [];\n  this.controls = [];\n  this.stepLength = options.stepLength || 60;\n  this.length = this.points.length;\n  this.delay = 0; // this is to ensure compatibility with the 2d version\n\n  for (var i = 0; i < this.length; i++) {\n    this.points[i].z = this.points[i].z || 0;\n  }\n\n  for (var i = 0; i < this.length - 1; i++) {\n    var p1 = this.points[i];\n    var p2 = this.points[i + 1];\n    this.centers.push({\n      x: (p1.x + p2.x) / 2,\n      y: (p1.y + p2.y) / 2,\n      z: (p1.z + p2.z) / 2\n    });\n  }\n\n  this.controls.push([this.points[0], this.points[0]]);\n\n  for (var i = 0; i < this.centers.length - 1; i++) {\n    var p1 = this.centers[i];\n    var p2 = this.centers[i + 1];\n    var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;\n    var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;\n    var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;\n    this.controls.push([{\n      x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),\n      y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),\n      z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)\n    }, {\n      x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),\n      y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),\n      z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)\n    }]);\n  }\n\n  this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);\n  this.steps = this.cacheSteps(this.stepLength);\n  return this;\n};\n/*\n  Caches an array of equidistant (more or less) points on the curve.\n*/\n\n\nSpline.prototype.cacheSteps = function (mindist) {\n  var steps = [];\n  var laststep = this.pos(0);\n  steps.push(0);\n\n  for (var t = 0; t < this.duration; t += 10) {\n    var step = this.pos(t);\n    var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));\n\n    if (dist > mindist) {\n      steps.push(t);\n      laststep = step;\n    }\n  }\n\n  return steps;\n};\n/*\n  returns angle and speed in the given point in the curve\n*/\n\n\nSpline.prototype.vector = function (t) {\n  var p1 = this.pos(t + 10);\n  var p2 = this.pos(t - 10);\n  return {\n    angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,\n    speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))\n  };\n};\n/*\n  Gets the position of the point, given time.\n   WARNING: The speed is not constant. The time it takes between control points is constant.\n   For constant speed, use Spline.steps[i];\n*/\n\n\nSpline.prototype.pos = function (time) {\n  function bezier(t, p1, c1, c2, p2) {\n    var B = function B(t) {\n      var t2 = t * t,\n          t3 = t2 * t;\n      return [t3, 3 * t2 * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)];\n    };\n\n    var b = B(t);\n    var pos = {\n      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],\n      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],\n      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]\n    };\n    return pos;\n  }\n\n  var t = time - this.delay;\n  if (t < 0) t = 0;\n  if (t > this.duration) t = this.duration - 1; //t = t-this.delay;\n\n  var t2 = t / this.duration;\n  if (t2 >= 1) return this.points[this.length - 1];\n  var n = Math.floor((this.points.length - 1) * t2);\n  var t1 = (this.length - 1) * t2 - n;\n  return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);\n};\n\nmodule.exports = Spline;","map":null,"metadata":{},"sourceType":"script"}