{"ast":null,"code":"// JSTS. See https://github.com/bjornharrtell/jsts\n// Licenses:\n// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt\n// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt\n// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e(t.jsts = t.jsts || {});\n}(this, function (t) {\n  \"use strict\";\n\n  function e(t, e) {\n    for (var n in e) {\n      e.hasOwnProperty(n) && (t[n] = e[n]);\n    }\n  }\n\n  function n() {}\n\n  function i() {}\n\n  function r() {}\n\n  function s() {}\n\n  function o() {}\n\n  function a() {}\n\n  function u() {}\n\n  function l(t) {\n    this.message = t;\n  }\n\n  function h(t, e) {\n    t.prototype = Object.create(e.prototype), t.prototype.constructor = t;\n  }\n\n  function c() {\n    if (0 === arguments.length) l.call(this);else if (1 === arguments.length) {\n      var t = arguments[0];\n      l.call(this, t);\n    }\n  }\n\n  function f() {}\n\n  function g() {\n    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) g.call(this, 0, 0);else if (1 === arguments.length) {\n      var t = arguments[0];\n      g.call(this, t.x, t.y, t.z);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      g.call(this, e, n, g.NULL_ORDINATE);\n    } else if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2];\n      this.x = i, this.y = r, this.z = s;\n    }\n  }\n\n  function d() {\n    if (this.dimensionsToTest = 2, 0 === arguments.length) d.call(this, 2);else if (1 === arguments.length) {\n      var t = arguments[0];\n      if (2 !== t && 3 !== t) throw new i(\"only 2 or 3 dimensions may be specified\");\n      this.dimensionsToTest = t;\n    }\n  }\n\n  function p() {}\n\n  function v() {}\n\n  function m(t) {\n    this.message = t || \"\";\n  }\n\n  function y() {}\n\n  function x(t) {\n    this.message = t || \"\";\n  }\n\n  function E(t) {\n    this.message = t || \"\";\n  }\n\n  function I() {\n    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);\n  }\n\n  function N() {\n    if (I.apply(this), 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.ensureCapacity(t.length), this.add(t, !0);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.ensureCapacity(e.length), this.add(e, n);\n    }\n  }\n\n  function C() {\n    if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {\n      if (arguments[0] instanceof g) {\n        var t = arguments[0];\n        this.init(t.x, t.x, t.y, t.y);\n      } else if (arguments[0] instanceof C) {\n        var e = arguments[0];\n        this.init(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.init(n.x, i.x, n.y, i.y);\n    } else if (4 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2],\n          a = arguments[3];\n      this.init(r, s, o, a);\n    }\n  }\n\n  function S() {}\n\n  function w() {\n    S.call(this, \"Projective point not representable on the Cartesian plane.\");\n  }\n\n  function L() {}\n\n  function R(t, e) {\n    return t.interfaces_ && t.interfaces_().indexOf(e) > -1;\n  }\n\n  function T() {}\n\n  function P(t) {\n    this.str = t;\n  }\n\n  function b(t) {\n    this.value = t;\n  }\n\n  function O() {}\n\n  function _() {\n    if (this.hi = 0, this.lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {\n      if (\"number\" == typeof arguments[0]) {\n        var t = arguments[0];\n        this.init(t);\n      } else if (arguments[0] instanceof _) {\n        var e = arguments[0];\n        this.init(e);\n      } else if (\"string\" == typeof arguments[0]) {\n        var n = arguments[0];\n\n        _.call(this, _.parse(n));\n      }\n    } else if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1];\n      this.init(i, r);\n    }\n  }\n\n  function M() {}\n\n  function D() {}\n\n  function A() {}\n\n  function F() {\n    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.x = t.x, this.y = t.y, this.w = 1;\n    } else if (2 === arguments.length) {\n      if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n        var e = arguments[0],\n            n = arguments[1];\n        this.x = e, this.y = n, this.w = 1;\n      } else if (arguments[0] instanceof F && arguments[1] instanceof F) {\n        var i = arguments[0],\n            r = arguments[1];\n        this.x = i.y * r.w - r.y * i.w, this.y = r.x * i.w - i.x * r.w, this.w = i.x * r.y - r.x * i.y;\n      } else if (arguments[0] instanceof g && arguments[1] instanceof g) {\n        var s = arguments[0],\n            o = arguments[1];\n        this.x = s.y - o.y, this.y = o.x - s.x, this.w = s.x * o.y - o.x * s.y;\n      }\n    } else if (3 === arguments.length) {\n      var a = arguments[0],\n          u = arguments[1],\n          l = arguments[2];\n      this.x = a, this.y = u, this.w = l;\n    } else if (4 === arguments.length) {\n      var h = arguments[0],\n          c = arguments[1],\n          f = arguments[2],\n          d = arguments[3],\n          p = h.y - c.y,\n          v = c.x - h.x,\n          m = h.x * c.y - c.x * h.y,\n          y = f.y - d.y,\n          x = d.x - f.x,\n          E = f.x * d.y - d.x * f.y;\n      this.x = v * E - x * m, this.y = y * m - p * E, this.w = p * x - y * v;\n    }\n  }\n\n  function G() {}\n\n  function q() {}\n\n  function B() {\n    this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;\n    var t = arguments[0];\n    this.factory = t, this.SRID = t.getSRID();\n  }\n\n  function z() {}\n\n  function V() {}\n\n  function k() {}\n\n  function Y() {}\n\n  function U() {}\n\n  function X() {}\n\n  function H() {}\n\n  function W() {}\n\n  function j() {}\n\n  function K() {}\n\n  function Z() {}\n\n  function Q() {}\n\n  function J() {\n    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);\n  }\n\n  function $(t) {\n    return null == t ? $s : t.color;\n  }\n\n  function tt(t) {\n    return null == t ? null : t.parent;\n  }\n\n  function et(t, e) {\n    null !== t && (t.color = e);\n  }\n\n  function nt(t) {\n    return null == t ? null : t.left;\n  }\n\n  function it(t) {\n    return null == t ? null : t.right;\n  }\n\n  function rt() {\n    this.root_ = null, this.size_ = 0;\n  }\n\n  function st() {}\n\n  function ot() {}\n\n  function at() {\n    this.array_ = [], arguments[0] instanceof v && this.addAll(arguments[0]);\n  }\n\n  function ut() {}\n\n  function lt() {}\n\n  function ht() {}\n\n  function ct() {}\n\n  function ft() {\n    this.geometries = null;\n    var t = arguments[0],\n        e = arguments[1];\n    if (B.call(this, e), null === t && (t = []), B.hasNullElements(t)) throw new i(\"geometries must not contain null elements\");\n    this.geometries = t;\n  }\n\n  function gt() {\n    var t = arguments[0],\n        e = arguments[1];\n    ft.call(this, t, e);\n  }\n\n  function dt() {\n    if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {\n      var t = arguments[0];\n      dt.call(this, t, V.MOD2_BOUNDARY_RULE);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.geom = e, this.geomFact = e.getFactory(), this.bnRule = n;\n    }\n  }\n\n  function pt() {\n    this.count = null;\n  }\n\n  function vt() {}\n\n  function mt() {}\n\n  function yt() {}\n\n  function xt() {}\n\n  function Et() {}\n\n  function It() {}\n\n  function Nt() {}\n\n  function Ct() {}\n\n  function St() {\n    this.points = null;\n    var t = arguments[0],\n        e = arguments[1];\n    B.call(this, e), this.init(t);\n  }\n\n  function wt() {}\n\n  function Lt() {\n    this.coordinates = null;\n    var t = arguments[0],\n        e = arguments[1];\n    B.call(this, e), this.init(t);\n  }\n\n  function Rt() {}\n\n  function Tt() {\n    this.shell = null, this.holes = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    if (B.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), B.hasNullElements(e)) throw new i(\"holes must not contain null elements\");\n    if (t.isEmpty() && B.hasNonEmptyElements(e)) throw new i(\"shell is empty but holes are not\");\n    this.shell = t, this.holes = e;\n  }\n\n  function Pt() {\n    var t = arguments[0],\n        e = arguments[1];\n    ft.call(this, t, e);\n  }\n\n  function bt() {\n    if (arguments[0] instanceof g && arguments[1] instanceof ie) {\n      var t = arguments[0],\n          e = arguments[1];\n      bt.call(this, e.getCoordinateSequenceFactory().create(t), e);\n    } else if (R(arguments[0], D) && arguments[1] instanceof ie) {\n      var n = arguments[0],\n          i = arguments[1];\n      St.call(this, n, i), this.validateConstruction();\n    }\n  }\n\n  function Ot() {\n    var t = arguments[0],\n        e = arguments[1];\n    ft.call(this, t, e);\n  }\n\n  function _t() {\n    if (this.factory = null, this.isUserDataCopied = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.factory = t;\n    }\n  }\n\n  function Mt() {}\n\n  function Dt() {}\n\n  function At() {}\n\n  function Ft() {}\n\n  function Gt() {\n    if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        Gt.call(this, t, 3);\n      } else if (Number.isInteger(arguments[0])) {\n        var e = arguments[0];\n        this.coordinates = new Array(e).fill(null);\n\n        for (var n = 0; e > n; n++) {\n          this.coordinates[n] = new g();\n        }\n      } else if (R(arguments[0], D)) {\n        var i = arguments[0];\n        if (null === i) return this.coordinates = new Array(0).fill(null), null;\n        this.dimension = i.getDimension(), this.coordinates = new Array(i.size()).fill(null);\n\n        for (var n = 0; n < this.coordinates.length; n++) {\n          this.coordinates[n] = i.getCoordinateCopy(n);\n        }\n      }\n    } else if (2 === arguments.length) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n      var r = arguments[0],\n          s = arguments[1];\n      this.coordinates = r, this.dimension = s, null === r && (this.coordinates = new Array(0).fill(null));\n    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var o = arguments[0],\n          a = arguments[1];\n      this.coordinates = new Array(o).fill(null), this.dimension = a;\n\n      for (var n = 0; o > n; n++) {\n        this.coordinates[n] = new g();\n      }\n    }\n  }\n\n  function qt() {}\n\n  function Bt(t, e) {\n    return t === e || t !== t && e !== e;\n  }\n\n  function zt(t, e) {\n    function n(t) {\n      return this && this.constructor === n ? (this._keys = [], this._values = [], this._itp = [], this.objectOnly = e, void (t && Vt.call(this, t))) : new n(t);\n    }\n\n    return e || io(t, \"size\", {\n      get: Jt\n    }), t.constructor = n, n.prototype = t, n;\n  }\n\n  function Vt(t) {\n    this.add ? t.forEach(this.add, this) : t.forEach(function (t) {\n      this.set(t[0], t[1]);\n    }, this);\n  }\n\n  function kt(t) {\n    return this.has(t) && (this._keys.splice(no, 1), this._values.splice(no, 1), this._itp.forEach(function (t) {\n      no < t[0] && t[0]--;\n    })), no > -1;\n  }\n\n  function Yt(t) {\n    return this.has(t) ? this._values[no] : void 0;\n  }\n\n  function Ut(t, e) {\n    if (this.objectOnly && e !== Object(e)) throw new TypeError(\"Invalid value used as weak collection key\");\n    if (e !== e || 0 === e) for (no = t.length; no-- && !Bt(t[no], e);) {\n      ;\n    } else no = t.indexOf(e);\n    return no > -1;\n  }\n\n  function Xt(t) {\n    return Ut.call(this, this._keys, t);\n  }\n\n  function Ht(t, e) {\n    return this.has(t) ? this._values[no] = e : this._values[this._keys.push(t) - 1] = e, this;\n  }\n\n  function Wt() {\n    (this._keys || 0).length = this._values.length = 0;\n  }\n\n  function jt() {\n    return Qt(this._itp, this._keys);\n  }\n\n  function Kt() {\n    return Qt(this._itp, this._values);\n  }\n\n  function Zt() {\n    return Qt(this._itp, this._keys, this._values);\n  }\n\n  function Qt(t, e, n) {\n    var i = [0],\n        r = !1;\n    return t.push(i), {\n      next: function next() {\n        var s,\n            o = i[0];\n        return !r && o < e.length ? (s = n ? [e[o], n[o]] : e[o], i[0]++) : (r = !0, t.splice(t.indexOf(i), 1)), {\n          done: r,\n          value: s\n        };\n      }\n    };\n  }\n\n  function Jt() {\n    return this._values.length;\n  }\n\n  function $t(t, e) {\n    for (var n = this.entries();;) {\n      var i = n.next();\n      if (i.done) break;\n      t.call(e, i.value[1], i.value[0], this);\n    }\n  }\n\n  function te() {\n    this.map_ = new so();\n  }\n\n  function ee() {\n    if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = ee.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof ne) {\n      var t = arguments[0];\n      this.modelType = t, t === ee.FIXED && this.setScale(1);\n    } else if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      this.modelType = ee.FIXED, this.setScale(e);\n    } else if (arguments[0] instanceof ee) {\n      var n = arguments[0];\n      this.modelType = n.modelType, this.scale = n.scale;\n    }\n  }\n\n  function ne() {\n    this.name = null;\n    var t = arguments[0];\n    this.name = t, ne.nameToTypeMap.put(t, this);\n  }\n\n  function ie() {\n    if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) ie.call(this, new ee(), 0);else if (1 === arguments.length) {\n      if (R(arguments[0], G)) {\n        var t = arguments[0];\n        ie.call(this, new ee(), 0, t);\n      } else if (arguments[0] instanceof ee) {\n        var e = arguments[0];\n        ie.call(this, e, 0, ie.getDefaultCoordinateSequenceFactory());\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      ie.call(this, n, i, ie.getDefaultCoordinateSequenceFactory());\n    } else if (3 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2];\n      this.precisionModel = r, this.coordinateSequenceFactory = o, this.SRID = s;\n    }\n  }\n\n  function re(t) {\n    this.geometryFactory = t || new ie();\n  }\n\n  function se(t) {\n    this.parser = new re(t);\n  }\n\n  function oe() {\n    this.result = null, this.inputLines = Array(2).fill().map(function () {\n      return Array(2);\n    }), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new g(), this.intPt[1] = new g(), this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0;\n  }\n\n  function ae() {\n    oe.apply(this);\n  }\n\n  function ue() {}\n\n  function le() {\n    this.p = null, this.crossingCount = 0, this.isPointOnSegment = !1;\n    var t = arguments[0];\n    this.p = t;\n  }\n\n  function he() {}\n\n  function ce() {\n    if (this.p0 = null, this.p1 = null, 0 === arguments.length) ce.call(this, new g(), new g());else if (1 === arguments.length) {\n      var t = arguments[0];\n      ce.call(this, t.p0, t.p1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.p0 = e, this.p1 = n;\n    } else if (4 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2],\n          o = arguments[3];\n      ce.call(this, new g(i, r), new g(s, o));\n    }\n  }\n\n  function fe() {\n    if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map(function () {\n      return Array(3);\n    }), this.setAll(lt.FALSE);else if (1 === arguments.length) if (\"string\" == typeof arguments[0]) {\n      var t = arguments[0];\n      fe.call(this), this.set(t);\n    } else if (arguments[0] instanceof fe) {\n      var e = arguments[0];\n      fe.call(this), this.matrix[L.INTERIOR][L.INTERIOR] = e.matrix[L.INTERIOR][L.INTERIOR], this.matrix[L.INTERIOR][L.BOUNDARY] = e.matrix[L.INTERIOR][L.BOUNDARY], this.matrix[L.INTERIOR][L.EXTERIOR] = e.matrix[L.INTERIOR][L.EXTERIOR], this.matrix[L.BOUNDARY][L.INTERIOR] = e.matrix[L.BOUNDARY][L.INTERIOR], this.matrix[L.BOUNDARY][L.BOUNDARY] = e.matrix[L.BOUNDARY][L.BOUNDARY], this.matrix[L.BOUNDARY][L.EXTERIOR] = e.matrix[L.BOUNDARY][L.EXTERIOR], this.matrix[L.EXTERIOR][L.INTERIOR] = e.matrix[L.EXTERIOR][L.INTERIOR], this.matrix[L.EXTERIOR][L.BOUNDARY] = e.matrix[L.EXTERIOR][L.BOUNDARY], this.matrix[L.EXTERIOR][L.EXTERIOR] = e.matrix[L.EXTERIOR][L.EXTERIOR];\n    }\n  }\n\n  function ge() {\n    this.areaBasePt = null, this.triangleCent3 = new g(), this.areasum2 = 0, this.cg3 = new g(), this.lineCentSum = new g(), this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new g();\n    var t = arguments[0];\n    this.areaBasePt = null, this.add(t);\n  }\n\n  function de(t) {\n    this.message = t || \"\";\n  }\n\n  function pe() {\n    this.array_ = [];\n  }\n\n  function ve() {\n    this.treeSet = new at(), this.list = new I();\n  }\n\n  function me() {\n    if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {\n      var t = arguments[0];\n      me.call(this, me.extractCoordinates(t), t.getFactory());\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.inputPts = ve.filterCoordinates(e), this.geomFactory = n;\n    }\n  }\n\n  function ye() {\n    this.origin = null;\n    var t = arguments[0];\n    this.origin = t;\n  }\n\n  function xe() {\n    this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = !0, this.preserveGeometryCollectionType = !0, this.preserveCollections = !1, this.preserveType = !1;\n  }\n\n  function Ee() {\n    if (this.snapTolerance = 0, this.srcPts = null, this.seg = new ce(), this.allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof St && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      Ee.call(this, t.getCoordinates(), e);\n    } else if (arguments[0] instanceof Array && \"number\" == typeof arguments[1]) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.srcPts = n, this._isClosed = Ee.isClosed(n), this.snapTolerance = i;\n    }\n  }\n\n  function Ie() {\n    this.srcGeom = null;\n    var t = arguments[0];\n    this.srcGeom = t;\n  }\n\n  function Ne() {\n    if (xe.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.snapTolerance = t, this.snapPts = e;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.snapTolerance = n, this.snapPts = i, this.isSelfSnap = r;\n    }\n  }\n\n  function Ce() {\n    this.isFirst = !0, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null;\n  }\n\n  function Se() {\n    this.commonCoord = null, this.ccFilter = new we();\n  }\n\n  function we() {\n    this.commonBitsX = new Ce(), this.commonBitsY = new Ce();\n  }\n\n  function Le() {\n    this.trans = null;\n    var t = arguments[0];\n    this.trans = t;\n  }\n\n  function Re() {\n    this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;\n    var t = arguments[0];\n    this.parent = t, this.atStart = !0, this.index = 0, this.max = t.getNumGeometries();\n  }\n\n  function Te() {\n    if (this.boundaryRule = V.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      if (null === t) throw new i(\"Rule must be non-null\");\n      this.boundaryRule = t;\n    }\n  }\n\n  function Pe() {}\n\n  function be() {}\n\n  function Oe() {\n    this.pts = null, this.data = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.pts = t, this.data = e;\n  }\n\n  function _e() {}\n\n  function Me() {\n    this.bounds = null, this.item = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.bounds = t, this.item = e;\n  }\n\n  function De() {\n    this._size = null, this.items = null, this._size = 0, this.items = new I(), this.items.add(null);\n  }\n\n  function Ae() {}\n\n  function Fe() {}\n\n  function Ge() {\n    if (this.childBoundables = new I(), this.bounds = null, this.level = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.level = t;\n    }\n  }\n\n  function qe() {\n    this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.boundable1 = t, this.boundable2 = e, this.itemDistance = n, this._distance = this.distance();\n  }\n\n  function Be() {\n    if (this.root = null, this.built = !1, this.itemBoundables = new I(), this.nodeCapacity = null, 0 === arguments.length) Be.call(this, Be.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n      var t = arguments[0];\n      f.isTrue(t > 1, \"Node capacity must be greater than 1\"), this.nodeCapacity = t;\n    }\n  }\n\n  function ze() {}\n\n  function Ve() {}\n\n  function ke() {\n    if (0 === arguments.length) ke.call(this, ke.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n      var t = arguments[0];\n      Be.call(this, t);\n    }\n  }\n\n  function Ye() {\n    var t = arguments[0];\n    Ge.call(this, t);\n  }\n\n  function Ue() {}\n\n  function Xe() {\n    this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    this.segString = t, this.coord = new g(e), this.segmentIndex = n, this.segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));\n  }\n\n  function He() {\n    this.nodeMap = new rt(), this.edge = null;\n    var t = arguments[0];\n    this.edge = t;\n  }\n\n  function We() {\n    this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;\n    var t = arguments[0];\n    this.nodeList = t, this.edge = t.getEdge(), this.nodeIt = t.iterator(), this.readNextNode();\n  }\n\n  function je() {}\n\n  function Ke() {\n    this.nodeList = new He(this), this.pts = null, this.data = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.pts = t, this.data = e;\n  }\n\n  function Ze() {\n    this.tempEnv1 = new C(), this.tempEnv2 = new C(), this.overlapSeg1 = new ce(), this.overlapSeg2 = new ce();\n  }\n\n  function Qe() {\n    this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    this.pts = t, this.start = e, this.end = n, this.context = i;\n  }\n\n  function Je() {}\n\n  function $e() {}\n\n  function tn() {}\n\n  function en() {\n    if (this.segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setSegmentIntersector(t);\n    }\n  }\n\n  function nn() {\n    if (this.monoChains = new I(), this.index = new ke(), this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      en.call(this, t);\n    }\n  }\n\n  function rn() {\n    Ze.apply(this), this.si = null;\n    var t = arguments[0];\n    this.si = t;\n  }\n\n  function sn() {\n    if (this.pt = null, 1 === arguments.length) {\n      var t = arguments[0];\n      l.call(this, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      l.call(this, sn.msgWithCoord(e, n)), this.pt = new g(n);\n    }\n  }\n\n  function on() {}\n\n  function an() {\n    this.findAllIntersections = !1, this.isCheckEndSegmentsOnly = !1, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new I(), this.intersectionCount = 0, this.keepIntersections = !0;\n    var t = arguments[0];\n    this.li = t, this.interiorIntersection = null;\n  }\n\n  function un() {\n    this.li = new ae(), this.segStrings = null, this.findAllIntersections = !1, this.segInt = null, this._isValid = !0;\n    var t = arguments[0];\n    this.segStrings = t;\n  }\n\n  function ln() {\n    this.nv = null;\n    var t = arguments[0];\n    this.nv = new un(ln.toSegmentStrings(t));\n  }\n\n  function hn() {\n    this.mapOp = null;\n    var t = arguments[0];\n    this.mapOp = t;\n  }\n\n  function cn() {}\n\n  function fn() {\n    if (this.location = null, 1 === arguments.length) {\n      if (arguments[0] instanceof Array) {\n        var t = arguments[0];\n        this.init(t.length);\n      } else if (Number.isInteger(arguments[0])) {\n        var e = arguments[0];\n        this.init(1), this.location[cn.ON] = e;\n      } else if (arguments[0] instanceof fn) {\n        var n = arguments[0];\n        if (this.init(n.location.length), null !== n) for (var i = 0; i < this.location.length; i++) {\n          this.location[i] = n.location[i];\n        }\n      }\n    } else if (3 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2];\n      this.init(3), this.location[cn.ON] = r, this.location[cn.LEFT] = s, this.location[cn.RIGHT] = o;\n    }\n  }\n\n  function gn() {\n    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {\n      if (Number.isInteger(arguments[0])) {\n        var t = arguments[0];\n        this.elt[0] = new fn(t), this.elt[1] = new fn(t);\n      } else if (arguments[0] instanceof gn) {\n        var e = arguments[0];\n        this.elt[0] = new fn(e.elt[0]), this.elt[1] = new fn(e.elt[1]);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.elt[0] = new fn(L.NONE), this.elt[1] = new fn(L.NONE), this.elt[n].setLocation(i);\n    } else if (3 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2];\n      this.elt[0] = new fn(r, s, o), this.elt[1] = new fn(r, s, o);\n    } else if (4 === arguments.length) {\n      var a = arguments[0],\n          u = arguments[1],\n          l = arguments[2],\n          h = arguments[3];\n      this.elt[0] = new fn(L.NONE, L.NONE, L.NONE), this.elt[1] = new fn(L.NONE, L.NONE, L.NONE), this.elt[a].setLocations(u, l, h);\n    }\n  }\n\n  function dn() {\n    this.startDe = null, this.maxNodeDegree = -1, this.edges = new I(), this.pts = new I(), this.label = new gn(L.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new I(), this.geometryFactory = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.geometryFactory = e, this.computePoints(t), this.computeRing();\n  }\n\n  function pn() {\n    var t = arguments[0],\n        e = arguments[1];\n    dn.call(this, t, e);\n  }\n\n  function vn() {\n    var t = arguments[0],\n        e = arguments[1];\n    dn.call(this, t, e);\n  }\n\n  function mn() {\n    if (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.label = t;\n    }\n  }\n\n  function yn() {\n    mn.apply(this), this.coord = null, this.edges = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.coord = t, this.edges = e, this.label = new gn(0, L.NONE);\n  }\n\n  function xn() {\n    this.nodeMap = new rt(), this.nodeFact = null;\n    var t = arguments[0];\n    this.nodeFact = t;\n  }\n\n  function En() {\n    if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.edge = t;\n    } else if (3 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n      En.call(this, e, n, i, null);\n    } else if (4 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2],\n          a = arguments[3];\n      En.call(this, r), this.init(s, o), this.label = a;\n    }\n  }\n\n  function In() {\n    this._isForward = null, this._isInResult = !1, this._isVisited = !1, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];\n    var t = arguments[0],\n        e = arguments[1];\n    if (En.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {\n      var n = t.getNumPoints() - 1;\n      this.init(t.getCoordinate(n), t.getCoordinate(n - 1));\n    }\n    this.computeDirectedLabel();\n  }\n\n  function Nn() {}\n\n  function Cn() {\n    if (this.edges = new I(), this.nodes = null, this.edgeEndList = new I(), 0 === arguments.length) this.nodes = new xn(new Nn());else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.nodes = new xn(t);\n    }\n  }\n\n  function Sn() {\n    this.geometryFactory = null, this.shellList = new I();\n    var t = arguments[0];\n    this.geometryFactory = t;\n  }\n\n  function wn() {\n    this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new I(), this.resultLineList = new I();\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.op = t, this.geometryFactory = e, this.ptLocator = n;\n  }\n\n  function Ln() {\n    this.op = null, this.geometryFactory = null, this.resultPointList = new I();\n    var t = arguments[0],\n        e = arguments[1];\n    arguments[2];\n    this.op = t, this.geometryFactory = e;\n  }\n\n  function Rn() {}\n\n  function Tn() {\n    this.geom = null;\n    var t = arguments[0];\n    this.geom = t;\n  }\n\n  function Pn() {\n    this.edgeMap = new rt(), this.edgeList = null, this.ptInAreaLocation = [L.NONE, L.NONE];\n  }\n\n  function bn() {\n    Pn.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2;\n  }\n\n  function On() {\n    Nn.apply(this);\n  }\n\n  function _n() {\n    this.mce = null, this.chainIndex = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.mce = t, this.chainIndex = e;\n  }\n\n  function Mn() {\n    if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.eventType = Mn.DELETE, this.xValue = t, this.insertEvent = e;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.eventType = Mn.INSERT, this.label = n, this.xValue = i, this.obj = r;\n    }\n  }\n\n  function Dn() {}\n\n  function An() {\n    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = !1, this.isDoneWhenProperInt = !1;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.li = t, this.includeProper = e, this.recordIsolated = n;\n  }\n\n  function Fn() {\n    Dn.apply(this), this.events = new I(), this.nOverlaps = null;\n  }\n\n  function Gn() {\n    this.min = r.POSITIVE_INFINITY, this.max = r.NEGATIVE_INFINITY;\n  }\n\n  function qn() {}\n\n  function Bn() {\n    Gn.apply(this), this.item = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.min = t, this.max = e, this.item = n;\n  }\n\n  function zn() {\n    Gn.apply(this), this.node1 = null, this.node2 = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.node1 = t, this.node2 = e, this.buildExtent(this.node1, this.node2);\n  }\n\n  function Vn() {\n    this.leaves = new I(), this.root = null, this.level = 0;\n  }\n\n  function kn() {\n    if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) {\n      var t = arguments[0];\n      this.lines = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.lines = e, this.isForcedToLineString = n;\n    }\n  }\n\n  function Yn() {\n    this.items = new I();\n  }\n\n  function Un() {\n    this.index = null;\n    var t = arguments[0];\n    if (!R(t, Rt)) throw new i(\"Argument must be Polygonal\");\n    this.index = new Hn(t);\n  }\n\n  function Xn() {\n    this.counter = null;\n    var t = arguments[0];\n    this.counter = t;\n  }\n\n  function Hn() {\n    this.index = new Vn();\n    var t = arguments[0];\n    this.init(t);\n  }\n\n  function Wn() {\n    this.coord = null, this.segmentIndex = null, this.dist = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.coord = new g(t), this.segmentIndex = e, this.dist = n;\n  }\n\n  function jn() {\n    this.nodeMap = new rt(), this.edge = null;\n    var t = arguments[0];\n    this.edge = t;\n  }\n\n  function Kn() {}\n\n  function Zn() {\n    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new C(), this.env2 = new C();\n    var t = arguments[0];\n    this.e = t, this.pts = t.getCoordinates();\n    var e = new Kn();\n    this.startIndex = e.getChainStartIndices(this.pts);\n  }\n\n  function Qn() {\n    this.depth = Array(2).fill().map(function () {\n      return Array(3);\n    });\n\n    for (var t = 0; 2 > t; t++) {\n      for (var e = 0; 3 > e; e++) {\n        this.depth[t][e] = Qn.NULL_VALUE;\n      }\n    }\n  }\n\n  function Jn() {\n    if (mn.apply(this), this.pts = null, this.env = null, this.eiList = new jn(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new Qn(), this.depthDelta = 0, 1 === arguments.length) {\n      var t = arguments[0];\n      Jn.call(this, t, null);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.pts = e, this.label = n;\n    }\n  }\n\n  function $n() {\n    if (Cn.apply(this), this.parentGeom = null, this.lineEdgeMap = new te(), this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new Te(), 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      $n.call(this, t, e, V.OGC_SFS_BOUNDARY_RULE);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.argIndex = n, this.parentGeom = i, this.boundaryNodeRule = r, null !== i && this.add(i);\n    }\n  }\n\n  function ti() {\n    if (this.li = new ae(), this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.setComputationPrecision(t.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new $n(0, t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      ti.call(this, e, n, V.OGC_SFS_BOUNDARY_RULE);\n    } else if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2];\n      i.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new $n(0, i, s), this.arg[1] = new $n(1, r, s);\n    }\n  }\n\n  function ei() {\n    this.pts = null, this._orientation = null;\n    var t = arguments[0];\n    this.pts = t, this._orientation = ei.orientation(t);\n  }\n\n  function ni() {\n    this.edges = new I(), this.ocaMap = new rt();\n  }\n\n  function ii() {\n    this.ptLocator = new Te(), this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new ni(), this.resultPolyList = new I(), this.resultLineList = new I(), this.resultPointList = new I();\n    var t = arguments[0],\n        e = arguments[1];\n    ti.call(this, t, e), this.graph = new Cn(new On()), this.geomFact = t.getFactory();\n  }\n\n  function ri() {\n    this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance();\n  }\n\n  function si() {\n    this.geom = new Array(2).fill(null);\n    var t = arguments[0],\n        e = arguments[1];\n    this.geom[0] = t, this.geom[1] = e;\n  }\n\n  function oi() {\n    this.factory = null, this.interiorPoint = null, this.maxWidth = 0;\n    var t = arguments[0];\n    this.factory = t.getFactory(), this.add(t);\n  }\n\n  function ai() {\n    this.poly = null, this.centreY = null, this.hiY = r.MAX_VALUE, this.loY = -r.MAX_VALUE;\n    var t = arguments[0];\n    this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = oi.avg(this.loY, this.hiY);\n  }\n\n  function ui() {\n    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;\n    var t = arguments[0];\n    this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null === this.interiorPoint && this.addEndpoints(t);\n  }\n\n  function li() {\n    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;\n    var t = arguments[0];\n    this.centroid = t.getCentroid().getCoordinate(), this.add(t);\n  }\n\n  function hi() {}\n\n  function ci() {\n    this.p0 = null, this.p1 = null, this.p2 = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.p0 = t, this.p1 = e, this.p2 = n;\n  }\n\n  function fi() {\n    this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0;\n    var t = arguments[0];\n    this.input = t;\n  }\n\n  function gi() {\n    if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new ce(), this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) {\n      var t = arguments[0];\n      gi.call(this, t, !1);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.inputGeom = e, this.isConvex = n;\n    }\n  }\n\n  function di() {\n    this.inputGeom = null, this.distanceTolerance = null;\n    var t = arguments[0];\n    this.inputGeom = t;\n  }\n\n  function pi() {\n    xe.apply(this), this.distanceTolerance = null;\n    var t = arguments[0];\n    this.distanceTolerance = t;\n  }\n\n  function vi() {\n    this._orig = null, this._sym = null, this._next = null;\n    var t = arguments[0];\n    this._orig = t;\n  }\n\n  function mi() {\n    this._isMarked = !1;\n    var t = arguments[0];\n    vi.call(this, t);\n  }\n\n  function yi() {\n    this.vertexMap = new te();\n  }\n\n  function xi() {\n    this._isStart = !1;\n    var t = arguments[0];\n    mi.call(this, t);\n  }\n\n  function Ei() {\n    yi.apply(this);\n  }\n\n  function Ii() {\n    this.result = null, this.factory = null, this.graph = null, this.lines = new I(), this.nodeEdgeStack = new pe(), this.ringStartEdge = null, this.graph = new Ei();\n  }\n\n  function Ni() {\n    this.items = new I(), this.subnode = new Array(4).fill(null);\n  }\n\n  function Ci() {}\n\n  function Si(t, e) {\n    var n,\n        i,\n        r,\n        s,\n        o = {\n      32: {\n        d: 127,\n        c: 128,\n        b: 0,\n        a: 0\n      },\n      64: {\n        d: 32752,\n        c: 0,\n        b: 0,\n        a: 0\n      }\n    },\n        a = {\n      32: 8,\n      64: 11\n    }[t];\n\n    if (s || (n = 0 > e || 0 > 1 / e, isFinite(e) || (s = o[t], n && (s.d += 1 << t / 4 - 1), i = Math.pow(2, a) - 1, r = 0)), !s) {\n      for (i = {\n        32: 127,\n        64: 1023\n      }[t], r = Math.abs(e); r >= 2;) {\n        i++, r /= 2;\n      }\n\n      for (; 1 > r && i > 0;) {\n        i--, r *= 2;\n      }\n\n      0 >= i && (r /= 2), 32 === t && i > 254 && (s = {\n        d: n ? 255 : 127,\n        c: 128,\n        b: 0,\n        a: 0\n      }, i = Math.pow(2, a) - 1, r = 0);\n    }\n\n    return i;\n  }\n\n  function wi() {\n    this.pt = new g(), this.level = 0, this.env = null;\n    var t = arguments[0];\n    this.computeKey(t);\n  }\n\n  function Li() {\n    Ni.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.env = t, this.level = e, this.centrex = (t.getMinX() + t.getMaxX()) / 2, this.centrey = (t.getMinY() + t.getMaxY()) / 2;\n  }\n\n  function Ri() {}\n\n  function Ti() {\n    Ni.apply(this);\n  }\n\n  function Pi() {\n    this.root = null, this.minExtent = 1, this.root = new Ti();\n  }\n\n  function bi(t) {\n    this.geometryFactory = t || new ie();\n  }\n\n  function Oi(t) {\n    this.geometryFactory = t || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new bi(this.geometryFactory);\n  }\n\n  function _i() {\n    this.parser = new bi(this.geometryFactory);\n  }\n\n  function Mi(t) {\n    this.geometryFactory = t || new ie(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new re(this.geometryFactory);\n  }\n\n  function Di(t) {\n    return [t.x, t.y];\n  }\n\n  function Ai(t) {\n    this.geometryFactory = t || new ie();\n  }\n\n  function Fi() {\n    if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      Fi.call(this, t, e, 0, 0);\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      arguments[2], arguments[3];\n      this.noder = n, this.scaleFactor = i, this.isScaled = !this.isIntegerPrecision();\n    }\n  }\n\n  function Gi() {\n    if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.inputGeom = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.inputGeom = e, this.isClosedEndpointsInInterior = !n.isInBoundary(2);\n    }\n  }\n\n  function qi() {\n    this.pt = null, this.isClosed = null, this.degree = null;\n    var t = arguments[0];\n    this.pt = t, this.isClosed = !1, this.degree = 0;\n  }\n\n  function Bi() {\n    if (this.quadrantSegments = Bi.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Bi.CAP_ROUND, this.joinStyle = Bi.JOIN_ROUND, this.mitreLimit = Bi.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = Bi.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.setQuadrantSegments(t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.setQuadrantSegments(e), this.setEndCapStyle(n);\n    } else if (4 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2],\n          o = arguments[3];\n      this.setQuadrantSegments(i), this.setEndCapStyle(r), this.setJoinStyle(s), this.setMitreLimit(o);\n    }\n  }\n\n  function zi() {\n    this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null;\n  }\n\n  function Vi() {\n    this.array_ = [];\n  }\n\n  function ki() {\n    this.finder = null, this.dirEdgeList = new I(), this.nodes = new I(), this.rightMostCoord = null, this.env = null, this.finder = new zi();\n  }\n\n  function Yi() {\n    this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = he.COUNTERCLOCKWISE;\n    var t = arguments[0];\n    this.inputLine = t;\n  }\n\n  function Ui() {\n    this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new I();\n  }\n\n  function Xi() {\n    this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new ce(), this.seg1 = new ce(), this.offset0 = new ce(), this.offset1 = new ce(), this.side = 0, this._hasNarrowConcaveAngle = !1;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.precisionModel = t, this.bufParams = e, this.li = new ae(), this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Bi.JOIN_ROUND && (this.closingSegLengthFactor = Xi.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);\n  }\n\n  function Hi() {\n    this.distance = 0, this.precisionModel = null, this.bufParams = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.precisionModel = t, this.bufParams = e;\n  }\n\n  function Wi() {\n    this.subgraphs = null, this.seg = new ce(), this.cga = new he();\n    var t = arguments[0];\n    this.subgraphs = t;\n  }\n\n  function ji() {\n    this.upwardSeg = null, this.leftDepth = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.upwardSeg = new ce(t), this.leftDepth = e;\n  }\n\n  function Ki() {\n    this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new I();\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.inputGeom = t, this.distance = e, this.curveBuilder = n;\n  }\n\n  function Zi() {\n    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.hasInterior = !1, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;\n    var t = arguments[0];\n    this.li = t;\n  }\n\n  function Qi() {\n    this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new ni();\n    var t = arguments[0];\n    this.bufParams = t;\n  }\n\n  function Ji() {\n    this.li = new ae(), this.segStrings = null;\n    var t = arguments[0];\n    this.segStrings = t;\n  }\n\n  function $i() {\n    this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    if (this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = n, 0 >= e) throw new i(\"Scale factor must be non-zero\");\n    1 !== e && (this.pt = new g(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new g(), this.p1Scaled = new g()), this.initCorners(this.pt);\n  }\n\n  function tr() {\n    this.tempEnv1 = new C(), this.selectedSegment = new ce();\n  }\n\n  function er() {\n    this.index = null;\n    var t = arguments[0];\n    this.index = t;\n  }\n\n  function nr() {\n    tr.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = !1;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2];\n    this.hotPixel = t, this.parentEdge = e, this.hotPixelVertexIndex = n;\n  }\n\n  function ir() {\n    this.li = null, this.interiorIntersections = null;\n    var t = arguments[0];\n    this.li = t, this.interiorIntersections = new I();\n  }\n\n  function rr() {\n    this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;\n    var t = arguments[0];\n    this.pm = t, this.li = new ae(), this.li.setPrecisionModel(t), this.scaleFactor = t.getScale();\n  }\n\n  function sr() {\n    if (this.argGeom = null, this.distance = null, this.bufParams = new Bi(), this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.argGeom = t;\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.argGeom = e, this.bufParams = n;\n    }\n  }\n\n  function or() {\n    this.comps = null;\n    var t = arguments[0];\n    this.comps = t;\n  }\n\n  function ar() {\n    if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      ar.call(this, t, ar.INSIDE_AREA, e);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.component = n, this.segIndex = i, this.pt = r;\n    }\n  }\n\n  function ur() {\n    this.pts = null;\n    var t = arguments[0];\n    this.pts = t;\n  }\n\n  function lr() {\n    this.locations = null;\n    var t = arguments[0];\n    this.locations = t;\n  }\n\n  function hr() {\n    if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new Te(), this.minDistanceLocation = null, this.minDistance = r.MAX_VALUE, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      hr.call(this, t, e, 0);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          s = arguments[2];\n      this.geom = new Array(2).fill(null), this.geom[0] = n, this.geom[1] = i, this.terminateDistance = s;\n    }\n  }\n\n  function cr() {\n    this.factory = null, this.directedEdges = new I(), this.coordinates = null;\n    var t = arguments[0];\n    this.factory = t;\n  }\n\n  function fr() {\n    this._isMarked = !1, this._isVisited = !1, this.data = null;\n  }\n\n  function gr() {\n    fr.apply(this), this.parentEdge = null, this.from = null, this.to = null, this.p0 = null, this.p1 = null, this.sym = null, this.edgeDirection = null, this.quadrant = null, this.angle = null;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    this.from = t, this.to = e, this.edgeDirection = i, this.p0 = t.getCoordinate(), this.p1 = n;\n    var r = this.p1.x - this.p0.x,\n        s = this.p1.y - this.p0.y;\n    this.quadrant = Je.quadrant(r, s), this.angle = Math.atan2(s, r);\n  }\n\n  function dr() {\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    gr.call(this, t, e, n, i);\n  }\n\n  function pr() {\n    if (fr.apply(this), this.dirEdge = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.setDirectedEdges(t, e);\n    }\n  }\n\n  function vr() {\n    this.outEdges = new I(), this.sorted = !1;\n  }\n\n  function mr() {\n    if (fr.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) {\n      var t = arguments[0];\n      mr.call(this, t, new vr());\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.pt = e, this.deStar = n;\n    }\n  }\n\n  function yr() {\n    pr.apply(this), this.line = null;\n    var t = arguments[0];\n    this.line = t;\n  }\n\n  function xr() {\n    this.nodeMap = new rt();\n  }\n\n  function Er() {\n    this.edges = new J(), this.dirEdges = new J(), this.nodeMap = new xr();\n  }\n\n  function Ir() {\n    Er.apply(this);\n  }\n\n  function Nr() {\n    this.graph = new Ir(), this.mergedLineStrings = null, this.factory = null, this.edgeStrings = null;\n  }\n\n  function Cr() {\n    this.edgeRing = null, this.next = null, this.label = -1;\n    var t = arguments[0],\n        e = arguments[1],\n        n = arguments[2],\n        i = arguments[3];\n    gr.call(this, t, e, n, i);\n  }\n\n  function Sr() {\n    pr.apply(this), this.line = null;\n    var t = arguments[0];\n    this.line = t;\n  }\n\n  function wr() {\n    this.factory = null, this.deList = new I(), this.lowestEdge = null, this.ring = null, this.ringPts = null, this.holes = null, this.shell = null, this._isHole = null, this._isProcessed = !1, this._isIncludedSet = !1, this._isIncluded = !1;\n    var t = arguments[0];\n    this.factory = t;\n  }\n\n  function Lr() {}\n\n  function Rr() {\n    Er.apply(this), this.factory = null;\n    var t = arguments[0];\n    this.factory = t;\n  }\n\n  function Tr() {\n    if (this.lineStringAdder = new Pr(this), this.graph = null, this.dangles = new I(), this.cutEdges = new I(), this.invalidRingLines = new I(), this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = !0, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length) Tr.call(this, !1);else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.extractOnlyPolygonal = t;\n    }\n  }\n\n  function Pr() {\n    this.p = null;\n    var t = arguments[0];\n    this.p = t;\n  }\n\n  function br() {}\n\n  function Or() {\n    if (this.edgeEnds = new I(), 1 === arguments.length) {\n      var t = arguments[0];\n      Or.call(this, null, t);\n    } else if (2 === arguments.length) {\n      var e = (arguments[0], arguments[1]);\n      En.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new gn(e.getLabel())), this.insert(e);\n    }\n  }\n\n  function _r() {\n    Pn.apply(this);\n  }\n\n  function Mr() {\n    var t = arguments[0],\n        e = arguments[1];\n    yn.call(this, t, e);\n  }\n\n  function Dr() {\n    Nn.apply(this);\n  }\n\n  function Ar() {\n    this.li = new ae(), this.ptLocator = new Te(), this.arg = null, this.nodes = new xn(new Dr()), this.im = null, this.isolatedEdges = new I(), this.invalidPoint = null;\n    var t = arguments[0];\n    this.arg = t;\n  }\n\n  function Fr() {\n    this.rectEnv = null;\n    var t = arguments[0];\n    this.rectEnv = t.getEnvelopeInternal();\n  }\n\n  function Gr() {\n    this.li = new ae(), this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;\n    var t = arguments[0];\n    this.rectEnv = t, this.diagUp0 = new g(t.getMinX(), t.getMinY()), this.diagUp1 = new g(t.getMaxX(), t.getMaxY()), this.diagDown0 = new g(t.getMinX(), t.getMaxY()), this.diagDown1 = new g(t.getMaxX(), t.getMinY());\n  }\n\n  function qr() {\n    this._isDone = !1;\n  }\n\n  function Br() {\n    this.rectangle = null, this.rectEnv = null;\n    var t = arguments[0];\n    this.rectangle = t, this.rectEnv = t.getEnvelopeInternal();\n  }\n\n  function zr() {\n    qr.apply(this), this.rectEnv = null, this._intersects = !1;\n    var t = arguments[0];\n    this.rectEnv = t;\n  }\n\n  function Vr() {\n    qr.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = !1;\n    var t = arguments[0];\n    this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal();\n  }\n\n  function kr() {\n    qr.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = !1, this.p0 = new g(), this.p1 = new g();\n    var t = arguments[0];\n    this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new Gr(this.rectEnv);\n  }\n\n  function Yr() {\n    if (this._relate = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      ti.call(this, t, e), this._relate = new Ar(this.arg);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      ti.call(this, n, i, r), this._relate = new Ar(this.arg);\n    }\n  }\n\n  function Ur() {\n    this.geomFactory = null, this.skipEmpty = !1, this.inputGeoms = null;\n    var t = arguments[0];\n    this.geomFactory = Ur.extractFactory(t), this.inputGeoms = t;\n  }\n\n  function Xr() {\n    this.pointGeom = null, this.otherGeom = null, this.geomFact = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory();\n  }\n\n  function Hr() {\n    this.sortIndex = -1, this.comps = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.sortIndex = t, this.comps = e;\n  }\n\n  function Wr() {\n    this.inputPolys = null, this.geomFactory = null;\n    var t = arguments[0];\n    this.inputPolys = t, null === this.inputPolys && (this.inputPolys = new I());\n  }\n\n  function jr() {\n    if (this.polygons = new I(), this.lines = new I(), this.points = new I(), this.geomFact = null, 1 === arguments.length) {\n      if (R(arguments[0], v)) {\n        var t = arguments[0];\n        this.extract(t);\n      } else if (arguments[0] instanceof B) {\n        var e = arguments[0];\n        this.extract(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      this.geomFact = i, this.extract(n);\n    }\n  }\n\n  function Kr() {\n    this.geometryFactory = new ie(), this.geomGraph = null, this.disconnectedRingcoord = null;\n    var t = arguments[0];\n    this.geomGraph = t;\n  }\n\n  function Zr() {\n    this.items = new I(), this.subnode = [null, null];\n  }\n\n  function Qr() {\n    if (this.min = null, this.max = null, 0 === arguments.length) this.min = 0, this.max = 0;else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.init(t.min, t.max);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.init(e, n);\n    }\n  }\n\n  function Jr() {\n    this.pt = 0, this.level = 0, this.interval = null;\n    var t = arguments[0];\n    this.computeKey(t);\n  }\n\n  function $r() {\n    Zr.apply(this), this.interval = null, this.centre = null, this.level = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2;\n  }\n\n  function ts() {\n    Zr.apply(this);\n  }\n\n  function es() {\n    this.root = null, this.minExtent = 1, this.root = new ts();\n  }\n\n  function ns() {}\n\n  function is() {\n    this.ring = null, this.tree = null, this.crossings = 0, this.interval = new Qr();\n    var t = arguments[0];\n    this.ring = t, this.buildIndex();\n  }\n\n  function rs() {\n    tr.apply(this), this.mcp = null, this.p = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.mcp = t, this.p = e;\n  }\n\n  function ss() {\n    this.nodes = new xn(new Dr());\n  }\n\n  function os() {\n    this.li = new ae(), this.geomGraph = null, this.nodeGraph = new ss(), this.invalidPoint = null;\n    var t = arguments[0];\n    this.geomGraph = t;\n  }\n\n  function as() {\n    this.graph = null, this.rings = new I(), this.totalEnv = new C(), this.index = null, this.nestedPt = null;\n    var t = arguments[0];\n    this.graph = t;\n  }\n\n  function us() {\n    if (this.errorType = null, this.pt = null, 1 === arguments.length) {\n      var t = arguments[0];\n      us.call(this, t, null);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.errorType = e, null !== n && (this.pt = n.copy());\n    }\n  }\n\n  function ls() {\n    this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null;\n    var t = arguments[0];\n    this.parentGeometry = t;\n  }\n\n  function hs() {\n    _t.CoordinateOperation.apply(this), this.targetPM = null, this.removeCollapsed = !0;\n    var t = arguments[0],\n        e = arguments[1];\n    this.targetPM = t, this.removeCollapsed = e;\n  }\n\n  function cs() {\n    this.targetPM = null, this.removeCollapsed = !0, this.changePrecisionModel = !1, this.isPointwise = !1;\n    var t = arguments[0];\n    this.targetPM = t;\n  }\n\n  function fs() {\n    this.pts = null, this.usePt = null, this.distanceTolerance = null, this.seg = new ce();\n    var t = arguments[0];\n    this.pts = t;\n  }\n\n  function gs() {\n    this.inputGeom = null, this.distanceTolerance = null, this.isEnsureValidTopology = !0;\n    var t = arguments[0];\n    this.inputGeom = t;\n  }\n\n  function ds() {\n    xe.apply(this), this.isEnsureValidTopology = !0, this.distanceTolerance = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.isEnsureValidTopology = t, this.distanceTolerance = e;\n  }\n\n  function ps() {\n    if (this.parent = null, this.index = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      ps.call(this, t, e, null, -1);\n    } else if (4 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2],\n          s = arguments[3];\n      ce.call(this, n, i), this.parent = r, this.index = s;\n    }\n  }\n\n  function vs() {\n    if (this.parentLine = null, this.segs = null, this.resultSegs = new I(), this.minimumSize = null, 1 === arguments.length) {\n      var t = arguments[0];\n      vs.call(this, t, 2);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.parentLine = e, this.minimumSize = n, this.init();\n    }\n  }\n\n  function ms() {\n    this.index = new Pi();\n  }\n\n  function ys() {\n    this.querySeg = null, this.items = new I();\n    var t = arguments[0];\n    this.querySeg = t;\n  }\n\n  function xs() {\n    this.li = new ae(), this.inputIndex = new ms(), this.outputIndex = new ms(), this.line = null, this.linePts = null, this.distanceTolerance = 0;\n    var t = arguments[0],\n        e = arguments[1];\n    this.inputIndex = t, this.outputIndex = e;\n  }\n\n  function Es() {\n    this.inputIndex = new ms(), this.outputIndex = new ms(), this.distanceTolerance = 0;\n  }\n\n  function Is() {\n    this.inputGeom = null, this.lineSimplifier = new Es(), this.linestringMap = null;\n    var t = arguments[0];\n    this.inputGeom = t;\n  }\n\n  function Ns() {\n    xe.apply(this), this.linestringMap = null;\n    var t = arguments[0];\n    this.linestringMap = t;\n  }\n\n  function Cs() {\n    this.tps = null;\n    var t = arguments[0];\n    this.tps = t;\n  }\n\n  function Ss() {\n    this.seg = null, this.segLen = null, this.splitPt = null, this.minimumLen = 0;\n    var t = arguments[0];\n    this.seg = t, this.segLen = t.getLength();\n  }\n\n  function ws() {}\n\n  function Ls() {}\n\n  function Rs() {}\n\n  function Ts() {\n    if (this.p = null, 1 === arguments.length) {\n      var t = arguments[0];\n      this.p = new g(t);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      this.p = new g(e, n);\n    } else if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2];\n      this.p = new g(i, r, s);\n    }\n  }\n\n  function Ps() {\n    this._isOnConstraint = null, this.constraint = null;\n    var t = arguments[0];\n    Ts.call(this, t);\n  }\n\n  function bs() {\n    this._rot = null, this.vertex = null, this.next = null, this.data = null;\n  }\n\n  function Os() {\n    this.subdiv = null, this.isUsingTolerance = !1;\n    var t = arguments[0];\n    this.subdiv = t, this.isUsingTolerance = t.getTolerance() > 0;\n  }\n\n  function _s() {}\n\n  function Ms() {\n    this.subdiv = null, this.lastEdge = null;\n    var t = arguments[0];\n    this.subdiv = t, this.init();\n  }\n\n  function Ds() {\n    if (this.seg = null, 1 === arguments.length) {\n      if (\"string\" == typeof arguments[0]) {\n        var t = arguments[0];\n        l.call(this, t);\n      } else if (arguments[0] instanceof ce) {\n        var e = arguments[0];\n        l.call(this, \"Locate failed to converge (at edge: \" + e + \").  Possible causes include invalid Subdivision topology or very close sites\"), this.seg = new ce(e);\n      }\n    } else if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1];\n      l.call(this, Ds.msgWithSpatial(n, i)), this.seg = new ce(i);\n    }\n  }\n\n  function As() {}\n\n  function Fs() {\n    this.visitedKey = 0, this.quadEdges = new I(), this.startingEdge = null, this.tolerance = null, this.edgeCoincidenceTolerance = null, this.frameVertex = new Array(3).fill(null), this.frameEnv = null, this.locator = null, this.seg = new ce(), this.triEdges = new Array(3).fill(null);\n    var t = arguments[0],\n        e = arguments[1];\n    this.tolerance = e, this.edgeCoincidenceTolerance = e / Fs.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t), this.startingEdge = this.initSubdiv(), this.locator = new Ms(this);\n  }\n\n  function Gs() {}\n\n  function qs() {\n    this.triList = new I();\n  }\n\n  function Bs() {\n    this.triList = new I();\n  }\n\n  function zs() {\n    this.coordList = new N(), this.triCoords = new I();\n  }\n\n  function Vs() {\n    if (this.ls = null, this.data = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.ls = new ce(t, e);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.ls = new ce(n, i), this.data = r;\n    } else if (6 === arguments.length) {\n      var s = arguments[0],\n          o = arguments[1],\n          a = arguments[2],\n          u = arguments[3],\n          l = arguments[4],\n          h = arguments[5];\n      Vs.call(this, new g(s, o, a), new g(u, l, h));\n    } else if (7 === arguments.length) {\n      var c = arguments[0],\n          f = arguments[1],\n          d = arguments[2],\n          p = arguments[3],\n          v = arguments[4],\n          m = arguments[5],\n          y = arguments[6];\n      Vs.call(this, new g(c, f, d), new g(p, v, m), y);\n    }\n  }\n\n  function ks() {}\n\n  function Ys() {\n    if (this.p = null, this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      this.p = new g(t), this.left = null, this.right = null, this.count = 1, this.data = e;\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      this.p = new g(n, i), this.left = null, this.right = null, this.count = 1, this.data = r;\n    }\n  }\n\n  function Us() {\n    if (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length) Us.call(this, 0);else if (1 === arguments.length) {\n      var t = arguments[0];\n      this.tolerance = t;\n    }\n  }\n\n  function Xs() {\n    this.tolerance = null, this.matchNode = null, this.matchDist = 0, this.p = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.p = t, this.tolerance = e;\n  }\n\n  function Hs() {\n    this.initialVertices = null, this.segVertices = null, this.segments = new I(), this.subdiv = null, this.incDel = null, this.convexHull = null, this.splitFinder = new Ls(), this.kdt = null, this.vertexFactory = null, this.computeAreaEnv = null, this.splitPt = null, this.tolerance = null;\n    var t = arguments[0],\n        e = arguments[1];\n    this.initialVertices = new I(t), this.tolerance = e, this.kdt = new Us(e);\n  }\n\n  function Ws() {\n    this.siteCoords = null, this.tolerance = 0, this.subdiv = null;\n  }\n\n  function js() {\n    this.siteCoords = null, this.constraintLines = null, this.tolerance = 0, this.subdiv = null, this.constraintVertexMap = new rt();\n  }\n\n  function Ks() {\n    this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null;\n  }\n\n  function Zs() {}\n\n  Array.prototype.fill || (Array.prototype.fill = function (t) {\n    for (var e = Object(this), n = parseInt(e.length, 10), i = arguments[1], r = parseInt(i, 10) || 0, s = 0 > r ? Math.max(n + r, 0) : Math.min(r, n), o = arguments[2], a = void 0 === o ? n : parseInt(o, 10) || 0, u = 0 > a ? Math.max(n + a, 0) : Math.min(a, n); u > s; s++) {\n      e[s] = t;\n    }\n\n    return e;\n  }), Number.isFinite = Number.isFinite || function (t) {\n    return \"number\" == typeof t && isFinite(t);\n  }, Number.isInteger = Number.isInteger || function (t) {\n    return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n  }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) {\n    return t !== t;\n  }, Math.trunc = Math.trunc || function (t) {\n    return 0 > t ? Math.ceil(t) : Math.floor(t);\n  }, e(n.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return n;\n    }\n  }), n.equalsWithTolerance = function (t, e, n) {\n    return Math.abs(t - e) <= n;\n  }, r.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, r.doubleToLongBits = function (t) {\n    return t;\n  }, r.longBitsToDouble = function (t) {\n    return t;\n  }, r.isInfinite = function (t) {\n    return !Number.isFinite(t);\n  }, r.MAX_VALUE = Number.MAX_VALUE, h(c, l), e(c.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return c;\n    }\n  }), e(f.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return f;\n    }\n  }), f.shouldNeverReachHere = function () {\n    if (0 === arguments.length) f.shouldNeverReachHere(null);else if (1 === arguments.length) {\n      var t = arguments[0];\n      throw new c(\"Should never reach here\" + (null !== t ? \": \" + t : \"\"));\n    }\n  }, f.isTrue = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      f.isTrue(t, null);\n    } else if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      if (!e) throw null === n ? new c() : new c(n);\n    }\n  }, f.equals = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      f.equals(t, e, null);\n    } else if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      if (!i.equals(n)) throw new c(\"Expected \" + n + \" but encountered \" + i + (null !== r ? \": \" + r : \"\"));\n    }\n  }, e(g.prototype, {\n    setOrdinate: function setOrdinate(t, e) {\n      switch (t) {\n        case g.X:\n          this.x = e;\n          break;\n\n        case g.Y:\n          this.y = e;\n          break;\n\n        case g.Z:\n          this.z = e;\n          break;\n\n        default:\n          throw new i(\"Invalid ordinate index: \" + t);\n      }\n    },\n    equals2D: function equals2D() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.x !== t.x ? !1 : this.y === t.y;\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            i = arguments[1];\n        return n.equalsWithTolerance(this.x, e.x, i) ? !!n.equalsWithTolerance(this.y, e.y, i) : !1;\n      }\n    },\n    getOrdinate: function getOrdinate(t) {\n      switch (t) {\n        case g.X:\n          return this.x;\n\n        case g.Y:\n          return this.y;\n\n        case g.Z:\n          return this.z;\n      }\n\n      throw new i(\"Invalid ordinate index: \" + t);\n    },\n    equals3D: function equals3D(t) {\n      return this.x === t.x && this.y === t.y && (this.z === t.z || r.isNaN(this.z) && r.isNaN(t.z));\n    },\n    equals: function equals(t) {\n      return t instanceof g ? this.equals2D(t) : !1;\n    },\n    equalInZ: function equalInZ(t, e) {\n      return n.equalsWithTolerance(this.z, t.z, e);\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;\n    },\n    clone: function clone() {\n      try {\n        var t = null;\n        return t;\n      } catch (t) {\n        if (t instanceof CloneNotSupportedException) return f.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\"), null;\n        throw t;\n      } finally {}\n    },\n    copy: function copy() {\n      return new g(this);\n    },\n    toString: function toString() {\n      return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n    },\n    distance3D: function distance3D(t) {\n      var e = this.x - t.x,\n          n = this.y - t.y,\n          i = this.z - t.z;\n      return Math.sqrt(e * e + n * n + i * i);\n    },\n    distance: function distance(t) {\n      var e = this.x - t.x,\n          n = this.y - t.y;\n      return Math.sqrt(e * e + n * n);\n    },\n    hashCode: function hashCode() {\n      var t = 17;\n      return t = 37 * t + g.hashCode(this.x), t = 37 * t + g.hashCode(this.y);\n    },\n    setCoordinate: function setCoordinate(t) {\n      this.x = t.x, this.y = t.y, this.z = t.z;\n    },\n    interfaces_: function interfaces_() {\n      return [s, o, u];\n    },\n    getClass: function getClass() {\n      return g;\n    }\n  }), g.hashCode = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = r.doubleToLongBits(t);\n      return Math.trunc(e ^ e >>> 32);\n    }\n  }, e(d.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e,\n          r = d.compare(n.x, i.x);\n      if (0 !== r) return r;\n      var s = d.compare(n.y, i.y);\n      if (0 !== s) return s;\n      if (this.dimensionsToTest <= 2) return 0;\n      var o = d.compare(n.z, i.z);\n      return o;\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return d;\n    }\n  }), d.compare = function (t, e) {\n    return e > t ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0;\n  }, g.DimensionalComparator = d, g.serialVersionUID = 0x5cbf2c235c7e5800, g.NULL_ORDINATE = r.NaN, g.X = 0, g.Y = 1, g.Z = 2, p.prototype.hasNext = function () {}, p.prototype.next = function () {}, p.prototype.remove = function () {}, v.prototype.add = function () {}, v.prototype.addAll = function () {}, v.prototype.isEmpty = function () {}, v.prototype.iterator = function () {}, v.prototype.size = function () {}, v.prototype.toArray = function () {}, v.prototype.remove = function () {}, m.prototype = new Error(), m.prototype.name = \"IndexOutOfBoundsException\", y.prototype = Object.create(v.prototype), y.prototype.constructor = y, y.prototype.get = function () {}, y.prototype.set = function () {}, y.prototype.isEmpty = function () {}, x.prototype = new Error(), x.prototype.name = \"NoSuchElementException\", E.prototype = new Error(), E.prototype.name = \"OperationNotSupported\", I.prototype = Object.create(y.prototype), I.prototype.constructor = I, I.prototype.ensureCapacity = function () {}, I.prototype.interfaces_ = function () {\n    return [y, v];\n  }, I.prototype.add = function (t) {\n    return this.array_.push(t), !0;\n  }, I.prototype.clear = function () {\n    this.array_ = [];\n  }, I.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      this.add(e.next());\n    }\n\n    return !0;\n  }, I.prototype.set = function (t, e) {\n    var n = this.array_[t];\n    return this.array_[t] = e, n;\n  }, I.prototype.iterator = function () {\n    return new Qs(this);\n  }, I.prototype.get = function (t) {\n    if (0 > t || t >= this.size()) throw new m();\n    return this.array_[t];\n  }, I.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, I.prototype.size = function () {\n    return this.array_.length;\n  }, I.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; n > e; e++) {\n      t.push(this.array_[e]);\n    }\n\n    return t;\n  }, I.prototype.remove = function (t) {\n    for (var e = !1, n = 0, i = this.array_.length; i > n; n++) {\n      if (this.array_[n] === t) {\n        this.array_.splice(n, 1), e = !0;\n        break;\n      }\n    }\n\n    return e;\n  };\n\n  var Qs = function Qs(t) {\n    this.arrayList_ = t, this.position_ = 0;\n  };\n\n  Qs.prototype.next = function () {\n    if (this.position_ === this.arrayList_.size()) throw new x();\n    return this.arrayList_.get(this.position_++);\n  }, Qs.prototype.hasNext = function () {\n    return this.position_ < this.arrayList_.size();\n  }, Qs.prototype.set = function (t) {\n    return this.arrayList_.set(this.position_ - 1, t);\n  }, Qs.prototype.remove = function () {\n    throw new E();\n  }, h(N, I), e(N.prototype, {\n    getCoordinate: function getCoordinate(t) {\n      return this.get(t);\n    },\n    addAll: function addAll() {\n      if (2 === arguments.length) {\n        for (var t = arguments[0], e = arguments[1], n = !1, i = t.iterator(); i.hasNext();) {\n          this.add(i.next(), e), n = !0;\n        }\n\n        return n;\n      }\n\n      return I.prototype.addAll.apply(this, arguments);\n    },\n    clone: function t() {\n      for (var t = I.prototype.clone.call(this), e = 0; e < this.size(); e++) {\n        t.add(e, this.get(e).copy());\n      }\n\n      return t;\n    },\n    toCoordinateArray: function toCoordinateArray() {\n      return this.toArray(N.coordArrayType);\n    },\n    add: function add() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        I.prototype.add.call(this, t);\n      } else if (2 === arguments.length) {\n        if (arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n          var e = arguments[0],\n              n = arguments[1];\n          return this.add(e, n, !0), !0;\n        }\n\n        if (arguments[0] instanceof g && \"boolean\" == typeof arguments[1]) {\n          var i = arguments[0],\n              r = arguments[1];\n\n          if (!r && this.size() >= 1) {\n            var s = this.get(this.size() - 1);\n            if (s.equals2D(i)) return null;\n          }\n\n          I.prototype.add.call(this, i);\n        } else if (arguments[0] instanceof Object && \"boolean\" == typeof arguments[1]) {\n          var o = arguments[0],\n              a = arguments[1];\n          return this.add(o, a), !0;\n        }\n      } else if (3 === arguments.length) {\n        if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n          var u = arguments[0],\n              l = arguments[1],\n              h = arguments[2];\n          if (h) for (var c = 0; c < u.length; c++) {\n            this.add(u[c], l);\n          } else for (var c = u.length - 1; c >= 0; c--) {\n            this.add(u[c], l);\n          }\n          return !0;\n        }\n\n        if (\"boolean\" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof g) {\n          var f = arguments[0],\n              d = arguments[1],\n              p = arguments[2];\n\n          if (!p) {\n            var v = this.size();\n\n            if (v > 0) {\n              if (f > 0) {\n                var m = this.get(f - 1);\n                if (m.equals2D(d)) return null;\n              }\n\n              if (v > f) {\n                var y = this.get(f);\n                if (y.equals2D(d)) return null;\n              }\n            }\n          }\n\n          I.prototype.add.call(this, f, d);\n        }\n      } else if (4 === arguments.length) {\n        var x = arguments[0],\n            E = arguments[1],\n            N = arguments[2],\n            C = arguments[3],\n            S = 1;\n        N > C && (S = -1);\n\n        for (var c = N; c !== C; c += S) {\n          this.add(x[c], E);\n        }\n\n        return !0;\n      }\n    },\n    closeRing: function closeRing() {\n      this.size() > 0 && this.add(new g(this.get(0)), !1);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return N;\n    }\n  }), N.coordArrayType = new Array(0).fill(null), e(C.prototype, {\n    getArea: function getArea() {\n      return this.getWidth() * this.getHeight();\n    },\n    equals: function equals(t) {\n      if (!(t instanceof C)) return !1;\n      var e = t;\n      return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY();\n    },\n    intersection: function intersection(t) {\n      if (this.isNull() || t.isNull() || !this.intersects(t)) return new C();\n      var e = this.minx > t.minx ? this.minx : t.minx,\n          n = this.miny > t.miny ? this.miny : t.miny,\n          i = this.maxx < t.maxx ? this.maxx : t.maxx,\n          r = this.maxy < t.maxy ? this.maxy : t.maxy;\n      return new C(e, i, n, r);\n    },\n    isNull: function isNull() {\n      return this.maxx < this.minx;\n    },\n    getMaxX: function getMaxX() {\n      return this.maxx;\n    },\n    covers: function covers() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof g) {\n          var t = arguments[0];\n          return this.covers(t.x, t.y);\n        }\n\n        if (arguments[0] instanceof C) {\n          var e = arguments[0];\n          return this.isNull() || e.isNull() ? !1 : e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy;\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        return this.isNull() ? !1 : n >= this.minx && n <= this.maxx && i >= this.miny && i <= this.maxy;\n      }\n    },\n    intersects: function intersects() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof C) {\n          var t = arguments[0];\n          return this.isNull() || t.isNull() ? !1 : !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny);\n        }\n\n        if (arguments[0] instanceof g) {\n          var e = arguments[0];\n          return this.intersects(e.x, e.y);\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        return this.isNull() ? !1 : !(n > this.maxx || n < this.minx || i > this.maxy || i < this.miny);\n      }\n    },\n    getMinY: function getMinY() {\n      return this.miny;\n    },\n    getMinX: function getMinX() {\n      return this.minx;\n    },\n    expandToInclude: function expandToInclude() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof g) {\n          var t = arguments[0];\n          this.expandToInclude(t.x, t.y);\n        } else if (arguments[0] instanceof C) {\n          var e = arguments[0];\n          if (e.isNull()) return null;\n          this.isNull() ? (this.minx = e.getMinX(), this.maxx = e.getMaxX(), this.miny = e.getMinY(), this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx), e.maxx > this.maxx && (this.maxx = e.maxx), e.miny < this.miny && (this.miny = e.miny), e.maxy > this.maxy && (this.maxy = e.maxy));\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.isNull() ? (this.minx = n, this.maxx = n, this.miny = i, this.maxy = i) : (n < this.minx && (this.minx = n), n > this.maxx && (this.maxx = n), i < this.miny && (this.miny = i), i > this.maxy && (this.maxy = i));\n      }\n    },\n    minExtent: function minExtent() {\n      if (this.isNull()) return 0;\n      var t = this.getWidth(),\n          e = this.getHeight();\n      return e > t ? t : e;\n    },\n    getWidth: function getWidth() {\n      return this.isNull() ? 0 : this.maxx - this.minx;\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0;\n    },\n    translate: function translate(t, e) {\n      return this.isNull() ? null : void this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);\n    },\n    toString: function toString() {\n      return \"Env[\" + this.minx + \" : \" + this.maxx + \", \" + this.miny + \" : \" + this.maxy + \"]\";\n    },\n    setToNull: function setToNull() {\n      this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1;\n    },\n    getHeight: function getHeight() {\n      return this.isNull() ? 0 : this.maxy - this.miny;\n    },\n    maxExtent: function maxExtent() {\n      if (this.isNull()) return 0;\n      var t = this.getWidth(),\n          e = this.getHeight();\n      return t > e ? t : e;\n    },\n    expandBy: function expandBy() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.expandBy(t, t);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (this.isNull()) return null;\n        this.minx -= e, this.maxx += e, this.miny -= n, this.maxy += n, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull();\n      }\n    },\n    contains: function contains() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof C) {\n          var t = arguments[0];\n          return this.covers(t);\n        }\n\n        if (arguments[0] instanceof g) {\n          var e = arguments[0];\n          return this.covers(e);\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        return this.covers(n, i);\n      }\n    },\n    centre: function centre() {\n      return this.isNull() ? null : new g((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);\n    },\n    init: function init() {\n      if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {\n        if (arguments[0] instanceof g) {\n          var t = arguments[0];\n          this.init(t.x, t.x, t.y, t.y);\n        } else if (arguments[0] instanceof C) {\n          var e = arguments[0];\n          this.minx = e.minx, this.maxx = e.maxx, this.miny = e.miny, this.maxy = e.maxy;\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.init(n.x, i.x, n.y, i.y);\n      } else if (4 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2],\n            a = arguments[3];\n        s > r ? (this.minx = r, this.maxx = s) : (this.minx = s, this.maxx = r), a > o ? (this.miny = o, this.maxy = a) : (this.miny = a, this.maxy = o);\n      }\n    },\n    getMaxY: function getMaxY() {\n      return this.maxy;\n    },\n    distance: function distance(t) {\n      if (this.intersects(t)) return 0;\n      var e = 0;\n      this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);\n      var n = 0;\n      return this.maxy < t.miny ? n = t.miny - this.maxy : this.miny > t.maxy && (n = this.miny - t.maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);\n    },\n    hashCode: function hashCode() {\n      var t = 17;\n      return t = 37 * t + g.hashCode(this.minx), t = 37 * t + g.hashCode(this.maxx), t = 37 * t + g.hashCode(this.miny), t = 37 * t + g.hashCode(this.maxy);\n    },\n    interfaces_: function interfaces_() {\n      return [s, u];\n    },\n    getClass: function getClass() {\n      return C;\n    }\n  }), C.intersects = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);\n    }\n\n    if (4 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2],\n          o = arguments[3],\n          a = Math.min(s.x, o.x),\n          u = Math.max(s.x, o.x),\n          l = Math.min(i.x, r.x),\n          h = Math.max(i.x, r.x);\n      return l > u ? !1 : a > h ? !1 : (a = Math.min(s.y, o.y), u = Math.max(s.y, o.y), l = Math.min(i.y, r.y), h = Math.max(i.y, r.y), l > u ? !1 : !(a > h));\n    }\n  }, C.serialVersionUID = 0x51845cd552189800, h(w, S), e(w.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return w;\n    }\n  }), e(L.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return L;\n    }\n  }), L.toLocationSymbol = function (t) {\n    switch (t) {\n      case L.EXTERIOR:\n        return \"e\";\n\n      case L.BOUNDARY:\n        return \"b\";\n\n      case L.INTERIOR:\n        return \"i\";\n\n      case L.NONE:\n        return \"-\";\n    }\n\n    throw new i(\"Unknown location value: \" + t);\n  }, L.INTERIOR = 0, L.BOUNDARY = 1, L.EXTERIOR = 2, L.NONE = -1, e(T.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return T;\n    }\n  }), T.log10 = function (t) {\n    var e = Math.log(t);\n    return r.isInfinite(e) ? e : r.isNaN(e) ? e : e / T.LOG_10;\n  }, T.min = function (t, e, n, i) {\n    var r = t;\n    return r > e && (r = e), r > n && (r = n), r > i && (r = i), r;\n  }, T.clamp = function () {\n    if (\"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      return e > t ? e : t > n ? n : t;\n    }\n\n    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2];\n      return r > i ? r : i > s ? s : i;\n    }\n  }, T.wrap = function (t, e) {\n    return 0 > t ? e - -t % e : t % e;\n  }, T.max = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = t;\n      return e > i && (i = e), n > i && (i = n), i;\n    }\n\n    if (4 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2],\n          a = arguments[3],\n          i = r;\n      return s > i && (i = s), o > i && (i = o), a > i && (i = a), i;\n    }\n  }, T.average = function (t, e) {\n    return (t + e) / 2;\n  }, T.LOG_10 = Math.log(10), P.prototype.append = function (t) {\n    this.str += t;\n  }, P.prototype.setCharAt = function (t, e) {\n    return this.str.substr(0, t) + e + this.str.substr(t + 1);\n  }, P.prototype.toString = function (t) {\n    return this.str;\n  }, b.prototype.intValue = function () {\n    return this.value;\n  }, b.prototype.compareTo = function (t) {\n    return this.value < t ? -1 : this.value > t ? 1 : 0;\n  }, b.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, O.isWhitespace = function (t) {\n    return 32 >= t && t >= 0 || 127 == t;\n  }, O.toUpperCase = function (t) {\n    return t.toUpperCase();\n  }, e(_.prototype, {\n    le: function le(t) {\n      return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo;\n    },\n    extractSignificantDigits: function extractSignificantDigits(t, e) {\n      var n = this.abs(),\n          i = _.magnitude(n.hi),\n          r = _.TEN.pow(i);\n\n      n = n.divide(r), n.gt(_.TEN) ? (n = n.divide(_.TEN), i += 1) : n.lt(_.ONE) && (n = n.multiply(_.TEN), i -= 1);\n\n      for (var s = i + 1, o = new P(), a = _.MAX_PRINT_DIGITS - 1, u = 0; a >= u; u++) {\n        t && u === s && o.append(\".\");\n        var l = Math.trunc(n.hi);\n        if (0 > l) break;\n        var h = !1,\n            c = 0;\n        l > 9 ? (h = !0, c = \"9\") : c = \"0\" + l, o.append(c), n = n.subtract(_.valueOf(l)).multiply(_.TEN), h && n.selfAdd(_.TEN);\n\n        var f = !0,\n            g = _.magnitude(n.hi);\n\n        if (0 > g && Math.abs(g) >= a - u && (f = !1), !f) break;\n      }\n\n      return e[0] = i, o.toString();\n    },\n    sqr: function sqr() {\n      return this.multiply(this);\n    },\n    doubleValue: function doubleValue() {\n      return this.hi + this.lo;\n    },\n    subtract: function subtract() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0];\n        return this.add(t.negate());\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.add(-e);\n      }\n    },\n    equals: function equals() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.hi === t.hi && this.lo === t.lo;\n      }\n    },\n    isZero: function isZero() {\n      return 0 === this.hi && 0 === this.lo;\n    },\n    selfSubtract: function selfSubtract() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0];\n        return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.isNaN() ? this : this.selfAdd(-e, 0);\n      }\n    },\n    getSpecialNumberString: function getSpecialNumberString() {\n      return this.isZero() ? \"0.0\" : this.isNaN() ? \"NaN \" : null;\n    },\n    min: function min(t) {\n      return this.le(t) ? this : t;\n    },\n    selfDivide: function selfDivide() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof _) {\n          var t = arguments[0];\n          return this.selfDivide(t.hi, t.lo);\n        }\n\n        if (\"number\" == typeof arguments[0]) {\n          var e = arguments[0];\n          return this.selfDivide(e, 0);\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = null,\n            s = null,\n            o = null,\n            a = null,\n            u = null,\n            l = null,\n            h = null,\n            c = null;\n        return u = this.hi / n, l = _.SPLIT * u, r = l - u, c = _.SPLIT * n, r = l - r, s = u - r, o = c - n, h = u * n, o = c - o, a = n - o, c = r * o - h + r * a + s * o + s * a, l = (this.hi - h - c + this.lo - u * i) / n, c = u + l, this.hi = c, this.lo = u - c + l, this;\n      }\n    },\n    dump: function dump() {\n      return \"DD<\" + this.hi + \", \" + this.lo + \">\";\n    },\n    divide: function divide() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0],\n            e = null,\n            n = null,\n            i = null,\n            s = null,\n            o = null,\n            a = null,\n            u = null,\n            l = null;\n        o = this.hi / t.hi, a = _.SPLIT * o, e = a - o, l = _.SPLIT * t.hi, e = a - e, n = o - e, i = l - t.hi, u = o * t.hi, i = l - i, s = t.hi - i, l = e * i - u + e * s + n * i + n * s, a = (this.hi - u - l + this.lo - o * t.lo) / t.hi, l = o + a;\n        var h = l,\n            c = o - l + a;\n        return new _(h, c);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var f = arguments[0];\n        return r.isNaN(f) ? _.createNaN() : _.copy(this).selfDivide(f, 0);\n      }\n    },\n    ge: function ge(t) {\n      return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo;\n    },\n    pow: function pow(t) {\n      if (0 === t) return _.valueOf(1);\n\n      var e = new _(this),\n          n = _.valueOf(1),\n          i = Math.abs(t);\n\n      if (i > 1) for (; i > 0;) {\n        i % 2 === 1 && n.selfMultiply(e), i /= 2, i > 0 && (e = e.sqr());\n      } else n = e;\n      return 0 > t ? n.reciprocal() : n;\n    },\n    ceil: function ceil() {\n      if (this.isNaN()) return _.NaN;\n      var t = Math.ceil(this.hi),\n          e = 0;\n      return t === this.hi && (e = Math.ceil(this.lo)), new _(t, e);\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0;\n    },\n    rint: function rint() {\n      if (this.isNaN()) return this;\n      var t = this.add(.5);\n      return t.floor();\n    },\n    setValue: function setValue() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0];\n        return this.init(t), this;\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return this.init(e), this;\n      }\n    },\n    max: function max(t) {\n      return this.ge(t) ? this : t;\n    },\n    sqrt: function sqrt() {\n      if (this.isZero()) return _.valueOf(0);\n      if (this.isNegative()) return _.NaN;\n\n      var t = 1 / Math.sqrt(this.hi),\n          e = this.hi * t,\n          n = _.valueOf(e),\n          i = this.subtract(n.sqr()),\n          r = i.hi * (.5 * t);\n\n      return n.add(r);\n    },\n    selfAdd: function selfAdd() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof _) {\n          var t = arguments[0];\n          return this.selfAdd(t.hi, t.lo);\n        }\n\n        if (\"number\" == typeof arguments[0]) {\n          var e = arguments[0],\n              n = null,\n              i = null,\n              r = null,\n              s = null,\n              o = null,\n              a = null;\n          return r = this.hi + e, o = r - this.hi, s = r - o, s = e - o + (this.hi - s), a = s + this.lo, n = r + a, i = a + (r - n), this.hi = n + i, this.lo = i + (n - this.hi), this;\n        }\n      } else if (2 === arguments.length) {\n        var u = arguments[0],\n            l = arguments[1],\n            n = null,\n            i = null,\n            h = null,\n            c = null,\n            r = null,\n            s = null,\n            o = null,\n            a = null;\n        r = this.hi + u, h = this.lo + l, o = r - this.hi, a = h - this.lo, s = r - o, c = h - a, s = u - o + (this.hi - s), c = l - a + (this.lo - c), o = s + h, n = r + o, i = o + (r - n), o = c + i;\n        var f = n + o,\n            g = o + (n - f);\n        return this.hi = f, this.lo = g, this;\n      }\n    },\n    selfMultiply: function selfMultiply() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof _) {\n          var t = arguments[0];\n          return this.selfMultiply(t.hi, t.lo);\n        }\n\n        if (\"number\" == typeof arguments[0]) {\n          var e = arguments[0];\n          return this.selfMultiply(e, 0);\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = null,\n            s = null,\n            o = null,\n            a = null,\n            u = null,\n            l = null;\n        u = _.SPLIT * this.hi, r = u - this.hi, l = _.SPLIT * n, r = u - r, s = this.hi - r, o = l - n, u = this.hi * n, o = l - o, a = n - o, l = r * o - u + r * a + s * o + s * a + (this.hi * i + this.lo * n);\n        var h = u + l;\n        r = u - h;\n        var c = l + r;\n        return this.hi = h, this.lo = c, this;\n      }\n    },\n    selfSqr: function selfSqr() {\n      return this.selfMultiply(this);\n    },\n    floor: function floor() {\n      if (this.isNaN()) return _.NaN;\n      var t = Math.floor(this.hi),\n          e = 0;\n      return t === this.hi && (e = Math.floor(this.lo)), new _(t, e);\n    },\n    negate: function negate() {\n      return this.isNaN() ? this : new _(-this.hi, -this.lo);\n    },\n    clone: function clone() {\n      try {\n        return null;\n      } catch (t) {\n        if (t instanceof CloneNotSupportedException) return null;\n        throw t;\n      } finally {}\n    },\n    multiply: function multiply() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0];\n        return t.isNaN() ? _.createNaN() : _.copy(this).selfMultiply(t);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return r.isNaN(e) ? _.createNaN() : _.copy(this).selfMultiply(e, 0);\n      }\n    },\n    isNaN: function isNaN() {\n      return r.isNaN(this.hi);\n    },\n    intValue: function intValue() {\n      return Math.trunc(this.hi);\n    },\n    toString: function toString() {\n      var t = _.magnitude(this.hi);\n\n      return t >= -3 && 20 >= t ? this.toStandardNotation() : this.toSciNotation();\n    },\n    toStandardNotation: function toStandardNotation() {\n      var t = this.getSpecialNumberString();\n      if (null !== t) return t;\n      var e = new Array(1).fill(null),\n          n = this.extractSignificantDigits(!0, e),\n          i = e[0] + 1,\n          r = n;\n      if (\".\" === n.charAt(0)) r = \"0\" + n;else if (0 > i) r = \"0.\" + _.stringOfChar(\"0\", -i) + n;else if (-1 === n.indexOf(\".\")) {\n        var s = i - n.length,\n            o = _.stringOfChar(\"0\", s);\n\n        r = n + o + \".0\";\n      }\n      return this.isNegative() ? \"-\" + r : r;\n    },\n    reciprocal: function reciprocal() {\n      var t = null,\n          e = null,\n          n = null,\n          i = null,\n          r = null,\n          s = null,\n          o = null,\n          a = null;\n      r = 1 / this.hi, s = _.SPLIT * r, t = s - r, a = _.SPLIT * this.hi, t = s - t, e = r - t, n = a - this.hi, o = r * this.hi, n = a - n, i = this.hi - n, a = t * n - o + t * i + e * n + e * i, s = (1 - o - a - r * this.lo) / this.hi;\n      var u = r + s,\n          l = r - u + s;\n      return new _(u, l);\n    },\n    toSciNotation: function toSciNotation() {\n      if (this.isZero()) return _.SCI_NOT_ZERO;\n      var t = this.getSpecialNumberString();\n      if (null !== t) return t;\n      var e = new Array(1).fill(null),\n          n = this.extractSignificantDigits(!1, e),\n          i = _.SCI_NOT_EXPONENT_CHAR + e[0];\n      if (\"0\" === n.charAt(0)) throw new IllegalStateException(\"Found leading zero: \" + n);\n      var r = \"\";\n      n.length > 1 && (r = n.substring(1));\n      var s = n.charAt(0) + \".\" + r;\n      return this.isNegative() ? \"-\" + s + i : s + i;\n    },\n    abs: function abs() {\n      return this.isNaN() ? _.NaN : this.isNegative() ? this.negate() : new _(this);\n    },\n    isPositive: function isPositive() {\n      return this.hi > 0 || 0 === this.hi && this.lo > 0;\n    },\n    lt: function lt(t) {\n      return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo;\n    },\n    add: function add() {\n      if (arguments[0] instanceof _) {\n        var t = arguments[0];\n        return _.copy(this).selfAdd(t);\n      }\n\n      if (\"number\" == typeof arguments[0]) {\n        var e = arguments[0];\n        return _.copy(this).selfAdd(e);\n      }\n    },\n    init: function init() {\n      if (1 === arguments.length) {\n        if (\"number\" == typeof arguments[0]) {\n          var t = arguments[0];\n          this.hi = t, this.lo = 0;\n        } else if (arguments[0] instanceof _) {\n          var e = arguments[0];\n          this.hi = e.hi, this.lo = e.lo;\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.hi = n, this.lo = i;\n      }\n    },\n    gt: function gt(t) {\n      return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo;\n    },\n    isNegative: function isNegative() {\n      return this.hi < 0 || 0 === this.hi && this.lo < 0;\n    },\n    trunc: function trunc() {\n      return this.isNaN() ? _.NaN : this.isPositive() ? this.floor() : this.ceil();\n    },\n    signum: function signum() {\n      return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0;\n    },\n    interfaces_: function interfaces_() {\n      return [u, s, o];\n    },\n    getClass: function getClass() {\n      return _;\n    }\n  }), _.sqr = function (t) {\n    return _.valueOf(t).selfMultiply(t);\n  }, _.valueOf = function () {\n    if (\"string\" == typeof arguments[0]) {\n      var t = arguments[0];\n      return _.parse(t);\n    }\n\n    if (\"number\" == typeof arguments[0]) {\n      var e = arguments[0];\n      return new _(e);\n    }\n  }, _.sqrt = function (t) {\n    return _.valueOf(t).sqrt();\n  }, _.parse = function (t) {\n    for (var e = 0, n = t.length; O.isWhitespace(t.charAt(e));) {\n      e++;\n    }\n\n    var i = !1;\n\n    if (n > e) {\n      var r = t.charAt(e);\n      \"-\" !== r && \"+\" !== r || (e++, \"-\" === r && (i = !0));\n    }\n\n    for (var s = new _(), o = 0, a = 0, u = 0;;) {\n      if (e >= n) break;\n      var l = t.charAt(e);\n\n      if (e++, O.isDigit(l)) {\n        var h = l - \"0\";\n        s.selfMultiply(_.TEN), s.selfAdd(h), o++;\n      } else {\n        if (\".\" !== l) {\n          if (\"e\" === l || \"E\" === l) {\n            var c = t.substring(e);\n\n            try {\n              u = b.parseInt(c);\n            } catch (e) {\n              throw e instanceof NumberFormatException ? new NumberFormatException(\"Invalid exponent \" + c + \" in string \" + t) : e;\n            } finally {}\n\n            break;\n          }\n\n          throw new NumberFormatException(\"Unexpected character '\" + l + \"' at position \" + e + \" in string \" + t);\n        }\n\n        a = o;\n      }\n    }\n\n    var f = s,\n        g = o - a - u;\n    if (0 === g) f = s;else if (g > 0) {\n      var d = _.TEN.pow(g);\n\n      f = s.divide(d);\n    } else if (0 > g) {\n      var d = _.TEN.pow(-g);\n\n      f = s.multiply(d);\n    }\n    return i ? f.negate() : f;\n  }, _.createNaN = function () {\n    return new _(r.NaN, r.NaN);\n  }, _.copy = function (t) {\n    return new _(t);\n  }, _.magnitude = function (t) {\n    var e = Math.abs(t),\n        n = Math.log(e) / Math.log(10),\n        i = Math.trunc(Math.floor(n)),\n        r = Math.pow(10, i);\n    return e >= 10 * r && (i += 1), i;\n  }, _.stringOfChar = function (t, e) {\n    for (var n = new P(), i = 0; e > i; i++) {\n      n.append(t);\n    }\n\n    return n.toString();\n  }, _.PI = new _(3.141592653589793, 1.2246467991473532e-16), _.TWO_PI = new _(6.283185307179586, 2.4492935982947064e-16), _.PI_2 = new _(1.5707963267948966, 6.123233995736766e-17), _.E = new _(2.718281828459045, 1.4456468917292502e-16), _.NaN = new _(r.NaN, r.NaN), _.EPS = 1.23259516440783e-32, _.SPLIT = 134217729, _.MAX_PRINT_DIGITS = 32, _.TEN = _.valueOf(10), _.ONE = _.valueOf(1), _.SCI_NOT_EXPONENT_CHAR = \"E\", _.SCI_NOT_ZERO = \"0.0E0\", e(M.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return M;\n    }\n  }), M.orientationIndex = function (t, e, n) {\n    var i = M.orientationIndexFilter(t, e, n);\n    if (1 >= i) return i;\n\n    var r = _.valueOf(e.x).selfAdd(-t.x),\n        s = _.valueOf(e.y).selfAdd(-t.y),\n        o = _.valueOf(n.x).selfAdd(-e.x),\n        a = _.valueOf(n.y).selfAdd(-e.y);\n\n    return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum();\n  }, M.signOfDet2x2 = function (t, e, n, i) {\n    var r = t.multiply(i).selfSubtract(e.multiply(n));\n    return r.signum();\n  }, M.intersection = function (t, e, n, i) {\n    var r = _.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),\n        s = _.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),\n        o = r.subtract(s),\n        a = _.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),\n        u = _.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),\n        l = a.subtract(u),\n        h = l.selfDivide(o).doubleValue(),\n        c = _.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),\n        f = _.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),\n        d = _.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),\n        p = f.subtract(d),\n        v = p.selfDivide(o).doubleValue(),\n        m = _.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();\n\n    return new g(c, m);\n  }, M.orientationIndexFilter = function (t, e, n) {\n    var i = null,\n        r = (t.x - n.x) * (e.y - n.y),\n        s = (t.y - n.y) * (e.x - n.x),\n        o = r - s;\n\n    if (r > 0) {\n      if (0 >= s) return M.signum(o);\n      i = r + s;\n    } else {\n      if (!(0 > r)) return M.signum(o);\n      if (s >= 0) return M.signum(o);\n      i = -r - s;\n    }\n\n    var a = M.DP_SAFE_EPSILON * i;\n    return o >= a || -o >= a ? M.signum(o) : 2;\n  }, M.signum = function (t) {\n    return t > 0 ? 1 : 0 > t ? -1 : 0;\n  }, M.DP_SAFE_EPSILON = 1e-15, e(D.prototype, {\n    setOrdinate: function setOrdinate(t, e, n) {},\n    size: function size() {},\n    getOrdinate: function getOrdinate(t, e) {},\n    getCoordinate: function getCoordinate() {\n      if (1 === arguments.length) {\n        arguments[0];\n      } else if (2 === arguments.length) {\n        arguments[0], arguments[1];\n      }\n    },\n    getCoordinateCopy: function getCoordinateCopy(t) {},\n    getDimension: function getDimension() {},\n    getX: function getX(t) {},\n    clone: function clone() {},\n    expandEnvelope: function expandEnvelope(t) {},\n    copy: function copy() {},\n    getY: function getY(t) {},\n    toCoordinateArray: function toCoordinateArray() {},\n    interfaces_: function interfaces_() {\n      return [o];\n    },\n    getClass: function getClass() {\n      return D;\n    }\n  }), D.X = 0, D.Y = 1, D.Z = 2, D.M = 3, A.arraycopy = function (t, e, n, i, r) {\n    for (var s = 0, o = e; e + r > o; o++) {\n      n[i + s] = t[o], s++;\n    }\n  }, A.getProperty = function (t) {\n    return {\n      \"line.separator\": \"\\n\"\n    }[t];\n  }, e(F.prototype, {\n    getY: function getY() {\n      var t = this.y / this.w;\n      if (r.isNaN(t) || r.isInfinite(t)) throw new w();\n      return t;\n    },\n    getX: function getX() {\n      var t = this.x / this.w;\n      if (r.isNaN(t) || r.isInfinite(t)) throw new w();\n      return t;\n    },\n    getCoordinate: function getCoordinate() {\n      var t = new g();\n      return t.x = this.getX(), t.y = this.getY(), t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return F;\n    }\n  }), F.intersection = function (t, e, n, i) {\n    var s = t.y - e.y,\n        o = e.x - t.x,\n        a = t.x * e.y - e.x * t.y,\n        u = n.y - i.y,\n        l = i.x - n.x,\n        h = n.x * i.y - i.x * n.y,\n        c = o * h - l * a,\n        f = u * a - s * h,\n        d = s * l - u * o,\n        p = c / d,\n        v = f / d;\n    if (r.isNaN(p) || r.isInfinite(p) || r.isNaN(v) || r.isInfinite(v)) throw new w();\n    return new g(p, v);\n  }, e(G.prototype, {\n    create: function create() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Array) {\n          arguments[0];\n        } else if (R(arguments[0], D)) {\n          arguments[0];\n        }\n      } else if (2 === arguments.length) {\n        arguments[0], arguments[1];\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return G;\n    }\n  }), e(q.prototype, {\n    filter: function filter(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return q;\n    }\n  }), e(B.prototype, {\n    isGeometryCollection: function isGeometryCollection() {\n      return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION;\n    },\n    getFactory: function getFactory() {\n      return this.factory;\n    },\n    getGeometryN: function getGeometryN(t) {\n      return this;\n    },\n    getArea: function getArea() {\n      return 0;\n    },\n    isRectangle: function isRectangle() {\n      return !1;\n    },\n    equals: function equals() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof B) {\n          var t = arguments[0];\n          return null === t ? !1 : this.equalsTopo(t);\n        }\n\n        if (arguments[0] instanceof Object) {\n          var e = arguments[0];\n          if (!(e instanceof B)) return !1;\n          var n = e;\n          return this.equalsExact(n);\n        }\n      }\n    },\n    equalsExact: function equalsExact(t) {\n      return this === t || this.equalsExact(t, 0);\n    },\n    geometryChanged: function geometryChanged() {\n      this.apply(B.geometryChangedFilter);\n    },\n    geometryChangedAction: function geometryChangedAction() {\n      this.envelope = null;\n    },\n    equalsNorm: function equalsNorm(t) {\n      return null === t ? !1 : this.norm().equalsExact(t.norm());\n    },\n    getLength: function getLength() {\n      return 0;\n    },\n    getNumGeometries: function getNumGeometries() {\n      return 1;\n    },\n    compareTo: function compareTo() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = t;\n        return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            e = n;\n        return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(n, i);\n      }\n    },\n    getUserData: function getUserData() {\n      return this.userData;\n    },\n    getSRID: function getSRID() {\n      return this.SRID;\n    },\n    getEnvelope: function getEnvelope() {\n      return this.getFactory().toGeometry(this.getEnvelopeInternal());\n    },\n    checkNotGeometryCollection: function checkNotGeometryCollection(t) {\n      if (t.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION) throw new i(\"This method does not support GeometryCollection arguments\");\n    },\n    equal: function equal(t, e, n) {\n      return 0 === n ? t.equals(e) : t.distance(e) <= n;\n    },\n    norm: function norm() {\n      var t = this.copy();\n      return t.normalize(), t;\n    },\n    getPrecisionModel: function getPrecisionModel() {\n      return this.factory.getPrecisionModel();\n    },\n    getEnvelopeInternal: function getEnvelopeInternal() {\n      return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new C(this.envelope);\n    },\n    setSRID: function setSRID(t) {\n      this.SRID = t;\n    },\n    setUserData: function setUserData(t) {\n      this.userData = t;\n    },\n    compare: function compare(t, e) {\n      for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {\n        var r = n.next(),\n            s = i.next(),\n            o = r.compareTo(s);\n        if (0 !== o) return o;\n      }\n\n      return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;\n    },\n    hashCode: function hashCode() {\n      return this.getEnvelopeInternal().hashCode();\n    },\n    isGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {\n      return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === B.SORTINDEX_MULTIPOINT || this.getSortIndex() === B.SORTINDEX_MULTILINESTRING || this.getSortIndex() === B.SORTINDEX_MULTIPOLYGON;\n    },\n    interfaces_: function interfaces_() {\n      return [o, s, u];\n    },\n    getClass: function getClass() {\n      return B;\n    }\n  }), B.hasNonEmptyElements = function (t) {\n    for (var e = 0; e < t.length; e++) {\n      if (!t[e].isEmpty()) return !0;\n    }\n\n    return !1;\n  }, B.hasNullElements = function (t) {\n    for (var e = 0; e < t.length; e++) {\n      if (null === t[e]) return !0;\n    }\n\n    return !1;\n  }, B.serialVersionUID = 0x799ea46522854c00, B.SORTINDEX_POINT = 0, B.SORTINDEX_MULTIPOINT = 1, B.SORTINDEX_LINESTRING = 2, B.SORTINDEX_LINEARRING = 3, B.SORTINDEX_MULTILINESTRING = 4, B.SORTINDEX_POLYGON = 5, B.SORTINDEX_MULTIPOLYGON = 6, B.SORTINDEX_GEOMETRYCOLLECTION = 7, B.geometryChangedFilter = {\n    interfaces_: function interfaces_() {\n      return [q];\n    },\n    filter: function filter(t) {\n      t.geometryChangedAction();\n    }\n  }, e(z.prototype, {\n    filter: function filter(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return z;\n    }\n  }), e(V.prototype, {\n    isInBoundary: function isInBoundary(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return V;\n    }\n  }), e(k.prototype, {\n    isInBoundary: function isInBoundary(t) {\n      return t % 2 === 1;\n    },\n    interfaces_: function interfaces_() {\n      return [V];\n    },\n    getClass: function getClass() {\n      return k;\n    }\n  }), e(Y.prototype, {\n    isInBoundary: function isInBoundary(t) {\n      return t > 0;\n    },\n    interfaces_: function interfaces_() {\n      return [V];\n    },\n    getClass: function getClass() {\n      return Y;\n    }\n  }), e(U.prototype, {\n    isInBoundary: function isInBoundary(t) {\n      return t > 1;\n    },\n    interfaces_: function interfaces_() {\n      return [V];\n    },\n    getClass: function getClass() {\n      return U;\n    }\n  }), e(X.prototype, {\n    isInBoundary: function isInBoundary(t) {\n      return 1 === t;\n    },\n    interfaces_: function interfaces_() {\n      return [V];\n    },\n    getClass: function getClass() {\n      return X;\n    }\n  }), V.Mod2BoundaryNodeRule = k, V.EndPointBoundaryNodeRule = Y, V.MultiValentEndPointBoundaryNodeRule = U, V.MonoValentEndPointBoundaryNodeRule = X, V.MOD2_BOUNDARY_RULE = new k(), V.ENDPOINT_BOUNDARY_RULE = new Y(), V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new U(), V.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new X(), V.OGC_SFS_BOUNDARY_RULE = V.MOD2_BOUNDARY_RULE, e(H.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return H;\n    }\n  }), H.isRing = function (t) {\n    return t.length < 4 ? !1 : !!t[0].equals2D(t[t.length - 1]);\n  }, H.ptNotInList = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n];\n      if (H.indexOf(i, e) < 0) return i;\n    }\n\n    return null;\n  }, H.scroll = function (t, e) {\n    var n = H.indexOf(e, t);\n    if (0 > n) return null;\n    var i = new Array(t.length).fill(null);\n    A.arraycopy(t, n, i, 0, t.length - n), A.arraycopy(t, 0, i, t.length - n, n), A.arraycopy(i, 0, t, 0, t.length);\n  }, H.equals = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (t === e) return !0;\n      if (null === t || null === e) return !1;\n      if (t.length !== e.length) return !1;\n\n      for (var n = 0; n < t.length; n++) {\n        if (!t[n].equals(e[n])) return !1;\n      }\n\n      return !0;\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2];\n      if (i === r) return !0;\n      if (null === i || null === r) return !1;\n      if (i.length !== r.length) return !1;\n\n      for (var n = 0; n < i.length; n++) {\n        if (0 !== s.compare(i[n], r[n])) return !1;\n      }\n\n      return !0;\n    }\n  }, H.intersection = function (t, e) {\n    for (var n = new N(), i = 0; i < t.length; i++) {\n      e.intersects(t[i]) && n.add(t[i], !0);\n    }\n\n    return n.toCoordinateArray();\n  }, H.hasRepeatedPoints = function (t) {\n    for (var e = 1; e < t.length; e++) {\n      if (t[e - 1].equals(t[e])) return !0;\n    }\n\n    return !1;\n  }, H.removeRepeatedPoints = function (t) {\n    if (!H.hasRepeatedPoints(t)) return t;\n    var e = new N(t, !1);\n    return e.toCoordinateArray();\n  }, H.reverse = function (t) {\n    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; n >= i; i++) {\n      var r = t[i];\n      t[i] = t[e - i], t[e - i] = r;\n    }\n  }, H.removeNull = function (t) {\n    for (var e = 0, n = 0; n < t.length; n++) {\n      null !== t[n] && e++;\n    }\n\n    var i = new Array(e).fill(null);\n    if (0 === e) return i;\n\n    for (var r = 0, n = 0; n < t.length; n++) {\n      null !== t[n] && (i[r++] = t[n]);\n    }\n\n    return i;\n  }, H.copyDeep = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) {\n        e[n] = new g(t[n]);\n      }\n\n      return e;\n    }\n\n    if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], s = arguments[2], o = arguments[3], a = arguments[4], n = 0; a > n; n++) {\n      s[o + n] = new g(i[r + n]);\n    }\n  }, H.isEqualReversed = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n],\n          r = e[t.length - n - 1];\n      if (0 !== i.compareTo(r)) return !1;\n    }\n\n    return !0;\n  }, H.envelope = function (t) {\n    for (var e = new C(), n = 0; n < t.length; n++) {\n      e.expandToInclude(t[n]);\n    }\n\n    return e;\n  }, H.toCoordinateArray = function (t) {\n    return t.toArray(H.coordArrayType);\n  }, H.atLeastNCoordinatesOrNothing = function (t, e) {\n    return e.length >= t ? e : [];\n  }, H.indexOf = function (t, e) {\n    for (var n = 0; n < e.length; n++) {\n      if (t.equals(e[n])) return n;\n    }\n\n    return -1;\n  }, H.increasingDirection = function (t) {\n    for (var e = 0; e < Math.trunc(t.length / 2); e++) {\n      var n = t.length - 1 - e,\n          i = t[e].compareTo(t[n]);\n      if (0 !== i) return i;\n    }\n\n    return 1;\n  }, H.compare = function (t, e) {\n    for (var n = 0; n < t.length && n < e.length;) {\n      var i = t[n].compareTo(e[n]);\n      if (0 !== i) return i;\n      n++;\n    }\n\n    return n < e.length ? -1 : n < t.length ? 1 : 0;\n  }, H.minCoordinate = function (t) {\n    for (var e = null, n = 0; n < t.length; n++) {\n      (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);\n    }\n\n    return e;\n  }, H.extract = function (t, e, n) {\n    e = T.clamp(e, 0, t.length), n = T.clamp(n, -1, t.length);\n    var i = n - e + 1;\n    0 > n && (i = 0), e >= t.length && (i = 0), e > n && (i = 0);\n    var r = new Array(i).fill(null);\n    if (0 === i) return r;\n\n    for (var s = 0, o = e; n >= o; o++) {\n      r[s++] = t[o];\n    }\n\n    return r;\n  }, e(W.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e;\n      return H.compare(n, i);\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return W;\n    }\n  }), e(j.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e;\n      if (n.length < i.length) return -1;\n      if (n.length > i.length) return 1;\n      if (0 === n.length) return 0;\n      var r = H.compare(n, i),\n          s = H.isEqualReversed(n, i);\n      return s ? 0 : r;\n    },\n    OLDcompare: function OLDcompare(t, e) {\n      var n = t,\n          i = e;\n      if (n.length < i.length) return -1;\n      if (n.length > i.length) return 1;\n      if (0 === n.length) return 0;\n\n      for (var r = H.increasingDirection(n), s = H.increasingDirection(i), o = r > 0 ? 0 : n.length - 1, a = s > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {\n        var l = n[o].compareTo(i[a]);\n        if (0 !== l) return l;\n        o += r, a += s;\n      }\n\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return j;\n    }\n  }), H.ForwardComparator = W, H.BidirectionalComparator = j, H.coordArrayType = new Array(0).fill(null), K.prototype.get = function () {}, K.prototype.put = function () {}, K.prototype.size = function () {}, K.prototype.values = function () {}, K.prototype.entrySet = function () {}, Z.prototype = new K(), Q.prototype = new v(), Q.prototype.contains = function () {}, J.prototype = new Q(), J.prototype.contains = function (t) {\n    for (var e = 0, n = this.array_.length; n > e; e++) {\n      var i = this.array_[e];\n      if (i === t) return !0;\n    }\n\n    return !1;\n  }, J.prototype.add = function (t) {\n    return this.contains(t) ? !1 : (this.array_.push(t), !0);\n  }, J.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      this.add(e.next());\n    }\n\n    return !0;\n  }, J.prototype.remove = function (t) {\n    throw new javascript.util.OperationNotSupported();\n  }, J.prototype.size = function () {\n    return this.array_.length;\n  }, J.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, J.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; n > e; e++) {\n      t.push(this.array_[e]);\n    }\n\n    return t;\n  }, J.prototype.iterator = function () {\n    return new Js(this);\n  };\n\n  var Js = function Js(t) {\n    this.hashSet_ = t, this.position_ = 0;\n  };\n\n  Js.prototype.next = function () {\n    if (this.position_ === this.hashSet_.size()) throw new x();\n    return this.hashSet_.array_[this.position_++];\n  }, Js.prototype.hasNext = function () {\n    return this.position_ < this.hashSet_.size();\n  }, Js.prototype.remove = function () {\n    throw new E();\n  };\n  var $s = 0,\n      to = 1;\n  rt.prototype = new Z(), rt.prototype.get = function (t) {\n    for (var e = this.root_; null !== e;) {\n      var n = t.compareTo(e.key);\n      if (0 > n) e = e.left;else {\n        if (!(n > 0)) return e.value;\n        e = e.right;\n      }\n    }\n\n    return null;\n  }, rt.prototype.put = function (t, e) {\n    if (null === this.root_) return this.root_ = {\n      key: t,\n      value: e,\n      left: null,\n      right: null,\n      parent: null,\n      color: $s,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    }, this.size_ = 1, null;\n    var n,\n        i,\n        r = this.root_;\n\n    do {\n      if (n = r, i = t.compareTo(r.key), 0 > i) r = r.left;else {\n        if (!(i > 0)) {\n          var s = r.value;\n          return r.value = e, s;\n        }\n\n        r = r.right;\n      }\n    } while (null !== r);\n\n    var o = {\n      key: t,\n      left: null,\n      right: null,\n      value: e,\n      parent: n,\n      color: $s,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n    return 0 > i ? n.left = o : n.right = o, this.fixAfterInsertion(o), this.size_++, null;\n  }, rt.prototype.fixAfterInsertion = function (t) {\n    for (t.color = to; null != t && t != this.root_ && t.parent.color == to;) {\n      if (tt(t) == nt(tt(tt(t)))) {\n        var e = it(tt(tt(t)));\n        $(e) == to ? (et(tt(t), $s), et(e, $s), et(tt(tt(t)), to), t = tt(tt(t))) : (t == it(tt(t)) && (t = tt(t), this.rotateLeft(t)), et(tt(t), $s), et(tt(tt(t)), to), this.rotateRight(tt(tt(t))));\n      } else {\n        var e = nt(tt(tt(t)));\n        $(e) == to ? (et(tt(t), $s), et(e, $s), et(tt(tt(t)), to), t = tt(tt(t))) : (t == nt(tt(t)) && (t = tt(t), this.rotateRight(t)), et(tt(t), $s), et(tt(tt(t)), to), this.rotateLeft(tt(tt(t))));\n      }\n    }\n\n    this.root_.color = $s;\n  }, rt.prototype.values = function () {\n    var t = new I(),\n        e = this.getFirstEntry();\n    if (null !== e) for (t.add(e.value); null !== (e = rt.successor(e));) {\n      t.add(e.value);\n    }\n    return t;\n  }, rt.prototype.entrySet = function () {\n    var t = new J(),\n        e = this.getFirstEntry();\n    if (null !== e) for (t.add(e); null !== (e = rt.successor(e));) {\n      t.add(e);\n    }\n    return t;\n  }, rt.prototype.rotateLeft = function (t) {\n    if (null != t) {\n      var e = t.right;\n      t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n    }\n  }, rt.prototype.rotateRight = function (t) {\n    if (null != t) {\n      var e = t.left;\n      t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n    }\n  }, rt.prototype.getFirstEntry = function () {\n    var t = this.root_;\n    if (null != t) for (; null != t.left;) {\n      t = t.left;\n    }\n    return t;\n  }, rt.successor = function (t) {\n    if (null === t) return null;\n\n    if (null !== t.right) {\n      for (var e = t.right; null !== e.left;) {\n        e = e.left;\n      }\n\n      return e;\n    }\n\n    for (var e = t.parent, n = t; null !== e && n === e.right;) {\n      n = e, e = e.parent;\n    }\n\n    return e;\n  }, rt.prototype.size = function () {\n    return this.size_;\n  }, e(st.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return st;\n    }\n  }), ot.prototype = new Q(), at.prototype = new ot(), at.prototype.contains = function (t) {\n    for (var e = 0, n = this.array_.length; n > e; e++) {\n      var i = this.array_[e];\n      if (0 === i.compareTo(t)) return !0;\n    }\n\n    return !1;\n  }, at.prototype.add = function (t) {\n    if (this.contains(t)) return !1;\n\n    for (var e = 0, n = this.array_.length; n > e; e++) {\n      var i = this.array_[e];\n      if (1 === i.compareTo(t)) return this.array_.splice(e, 0, t), !0;\n    }\n\n    return this.array_.push(t), !0;\n  }, at.prototype.addAll = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      this.add(e.next());\n    }\n\n    return !0;\n  }, at.prototype.remove = function (t) {\n    throw new E();\n  }, at.prototype.size = function () {\n    return this.array_.length;\n  }, at.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, at.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; n > e; e++) {\n      t.push(this.array_[e]);\n    }\n\n    return t;\n  }, at.prototype.iterator = function () {\n    return new eo(this);\n  };\n\n  var eo = function eo(t) {\n    this.treeSet_ = t, this.position_ = 0;\n  };\n\n  eo.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) throw new x();\n    return this.treeSet_.array_[this.position_++];\n  }, eo.prototype.hasNext = function () {\n    return this.position_ < this.treeSet_.size();\n  }, eo.prototype.remove = function () {\n    throw new E();\n  }, ut.sort = function () {\n    var t,\n        e,\n        n,\n        i,\n        r = arguments[0];\n    if (1 === arguments.length) return i = function i(t, e) {\n      return t.compareTo(e);\n    }, void r.sort(i);\n    if (2 === arguments.length) n = arguments[1], i = function i(t, e) {\n      return n.compare(t, e);\n    }, r.sort(i);else {\n      if (3 === arguments.length) {\n        e = r.slice(arguments[1], arguments[2]), e.sort();\n        var s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));\n\n        for (r.splice(0, r.length), t = 0; t < s.length; t++) {\n          r.push(s[t]);\n        }\n\n        return;\n      }\n\n      if (4 === arguments.length) {\n        for (e = r.slice(arguments[1], arguments[2]), n = arguments[3], i = function i(t, e) {\n          return n.compare(t, e);\n        }, e.sort(i), s = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < s.length; t++) {\n          r.push(s[t]);\n        }\n\n        return;\n      }\n    }\n  }, ut.asList = function (t) {\n    for (var e = new I(), n = 0, i = t.length; i > n; n++) {\n      e.add(t[n]);\n    }\n\n    return e;\n  }, e(lt.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return lt;\n    }\n  }), lt.toDimensionSymbol = function (t) {\n    switch (t) {\n      case lt.FALSE:\n        return lt.SYM_FALSE;\n\n      case lt.TRUE:\n        return lt.SYM_TRUE;\n\n      case lt.DONTCARE:\n        return lt.SYM_DONTCARE;\n\n      case lt.P:\n        return lt.SYM_P;\n\n      case lt.L:\n        return lt.SYM_L;\n\n      case lt.A:\n        return lt.SYM_A;\n    }\n\n    throw new i(\"Unknown dimension value: \" + t);\n  }, lt.toDimensionValue = function (t) {\n    switch (O.toUpperCase(t)) {\n      case lt.SYM_FALSE:\n        return lt.FALSE;\n\n      case lt.SYM_TRUE:\n        return lt.TRUE;\n\n      case lt.SYM_DONTCARE:\n        return lt.DONTCARE;\n\n      case lt.SYM_P:\n        return lt.P;\n\n      case lt.SYM_L:\n        return lt.L;\n\n      case lt.SYM_A:\n        return lt.A;\n    }\n\n    throw new i(\"Unknown dimension symbol: \" + t);\n  }, lt.P = 0, lt.L = 1, lt.A = 2, lt.FALSE = -1, lt.TRUE = -2, lt.DONTCARE = -3, lt.SYM_FALSE = \"F\", lt.SYM_TRUE = \"T\", lt.SYM_DONTCARE = \"*\", lt.SYM_P = \"0\", lt.SYM_L = \"1\", lt.SYM_A = \"2\", e(ht.prototype, {\n    filter: function filter(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ht;\n    }\n  }), e(ct.prototype, {\n    filter: function filter(t, e) {},\n    isDone: function isDone() {},\n    isGeometryChanged: function isGeometryChanged() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ct;\n    }\n  }), h(ft, B), e(ft.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      for (var t = new C(), e = 0; e < this.geometries.length; e++) {\n        t.expandToInclude(this.geometries[e].getEnvelopeInternal());\n      }\n\n      return t;\n    },\n    getGeometryN: function getGeometryN(t) {\n      return this.geometries[t];\n    },\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_GEOMETRYCOLLECTION;\n    },\n    getCoordinates: function getCoordinates() {\n      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this.geometries.length; n++) {\n        for (var i = this.geometries[n].getCoordinates(), r = 0; r < i.length; r++) {\n          e++, t[e] = i[r];\n        }\n      }\n\n      return t;\n    },\n    getArea: function getArea() {\n      for (var t = 0, e = 0; e < this.geometries.length; e++) {\n        t += this.geometries[e].getArea();\n      }\n\n      return t;\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        if (!this.isEquivalentClass(t)) return !1;\n        var n = t;\n        if (this.geometries.length !== n.geometries.length) return !1;\n\n        for (var i = 0; i < this.geometries.length; i++) {\n          if (!this.geometries[i].equalsExact(n.geometries[i], e)) return !1;\n        }\n\n        return !0;\n      }\n\n      return B.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      for (var t = 0; t < this.geometries.length; t++) {\n        this.geometries[t].normalize();\n      }\n\n      ut.sort(this.geometries);\n    },\n    getCoordinate: function getCoordinate() {\n      return this.isEmpty() ? null : this.geometries[0].getCoordinate();\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) {\n        t = Math.max(t, this.geometries[e].getBoundaryDimension());\n      }\n\n      return t;\n    },\n    getDimension: function getDimension() {\n      for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) {\n        t = Math.max(t, this.geometries[e].getDimension());\n      }\n\n      return t;\n    },\n    getLength: function getLength() {\n      for (var t = 0, e = 0; e < this.geometries.length; e++) {\n        t += this.geometries[e].getLength();\n      }\n\n      return t;\n    },\n    getNumPoints: function getNumPoints() {\n      for (var t = 0, e = 0; e < this.geometries.length; e++) {\n        t += this.geometries[e].getNumPoints();\n      }\n\n      return t;\n    },\n    getNumGeometries: function getNumGeometries() {\n      return this.geometries.length;\n    },\n    reverse: function reverse() {\n      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {\n        e[n] = this.geometries[n].reverse();\n      }\n\n      return this.getFactory().createGeometryCollection(e);\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = new at(ut.asList(this.geometries)),\n            n = new at(ut.asList(t.geometries));\n        return this.compare(e, n);\n      }\n\n      if (2 === arguments.length) {\n        for (var i = arguments[0], r = arguments[1], s = i, o = this.getNumGeometries(), a = s.getNumGeometries(), u = 0; o > u && a > u;) {\n          var l = this.getGeometryN(u),\n              h = s.getGeometryN(u),\n              c = l.compareToSameClass(h, r);\n          if (0 !== c) return c;\n          u++;\n        }\n\n        return o > u ? 1 : a > u ? -1 : 0;\n      }\n    },\n    apply: function apply() {\n      if (R(arguments[0], z)) for (var t = arguments[0], e = 0; e < this.geometries.length; e++) {\n        this.geometries[e].apply(t);\n      } else if (R(arguments[0], ct)) {\n        var n = arguments[0];\n        if (0 === this.geometries.length) return null;\n\n        for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(n), !n.isDone()); e++) {\n          ;\n        }\n\n        n.isGeometryChanged() && this.geometryChanged();\n      } else if (R(arguments[0], ht)) {\n        var i = arguments[0];\n        i.filter(this);\n\n        for (var e = 0; e < this.geometries.length; e++) {\n          this.geometries[e].apply(i);\n        }\n      } else if (R(arguments[0], q)) {\n        var r = arguments[0];\n        r.filter(this);\n\n        for (var e = 0; e < this.geometries.length; e++) {\n          this.geometries[e].apply(r);\n        }\n      }\n    },\n    getBoundary: function getBoundary() {\n      return this.checkNotGeometryCollection(this), f.shouldNeverReachHere(), null;\n    },\n    clone: function clone() {\n      var t = B.prototype.clone.call(this);\n      t.geometries = new Array(this.geometries.length).fill(null);\n\n      for (var e = 0; e < this.geometries.length; e++) {\n        t.geometries[e] = this.geometries[e].clone();\n      }\n\n      return t;\n    },\n    getGeometryType: function getGeometryType() {\n      return \"GeometryCollection\";\n    },\n    copy: function copy() {\n      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {\n        t[e] = this.geometries[e].copy();\n      }\n\n      return new ft(t, this.factory);\n    },\n    isEmpty: function isEmpty() {\n      for (var t = 0; t < this.geometries.length; t++) {\n        if (!this.geometries[t].isEmpty()) return !1;\n      }\n\n      return !0;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ft;\n    }\n  }), ft.serialVersionUID = -0x4f07bcb1f857d800, h(gt, ft), e(gt.prototype, {\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_MULTILINESTRING;\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.isEquivalentClass(t) ? ft.prototype.equalsExact.call(this, t, e) : !1;\n      }\n\n      return ft.prototype.equalsExact.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return this.isClosed() ? lt.FALSE : 0;\n    },\n    isClosed: function isClosed() {\n      if (this.isEmpty()) return !1;\n\n      for (var t = 0; t < this.geometries.length; t++) {\n        if (!this.geometries[t].isClosed()) return !1;\n      }\n\n      return !0;\n    },\n    getDimension: function getDimension() {\n      return 1;\n    },\n    reverse: function reverse() {\n      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {\n        e[t - 1 - n] = this.geometries[n].reverse();\n      }\n\n      return this.getFactory().createMultiLineString(e);\n    },\n    getBoundary: function getBoundary() {\n      return new dt(this).getBoundary();\n    },\n    getGeometryType: function getGeometryType() {\n      return \"MultiLineString\";\n    },\n    copy: function copy() {\n      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {\n        t[e] = this.geometries[e].copy();\n      }\n\n      return new gt(t, this.factory);\n    },\n    interfaces_: function interfaces_() {\n      return [st];\n    },\n    getClass: function getClass() {\n      return gt;\n    }\n  }), gt.serialVersionUID = 0x7155d2ab4afa8000, e(dt.prototype, {\n    boundaryMultiLineString: function boundaryMultiLineString(t) {\n      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();\n      var e = this.computeBoundaryCoordinates(t);\n      return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e);\n    },\n    getBoundary: function getBoundary() {\n      return this.geom instanceof St ? this.boundaryLineString(this.geom) : this.geom instanceof gt ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary();\n    },\n    boundaryLineString: function boundaryLineString(t) {\n      if (this.geom.isEmpty()) return this.getEmptyMultiPoint();\n\n      if (t.isClosed()) {\n        var e = this.bnRule.isInBoundary(2);\n        return e ? t.getStartPoint() : this.geomFact.createMultiPoint();\n      }\n\n      return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);\n    },\n    getEmptyMultiPoint: function getEmptyMultiPoint() {\n      return this.geomFact.createMultiPoint();\n    },\n    computeBoundaryCoordinates: function computeBoundaryCoordinates(t) {\n      var e = new I();\n      this.endpointMap = new rt();\n\n      for (var n = 0; n < t.getNumGeometries(); n++) {\n        var i = t.getGeometryN(n);\n        0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)));\n      }\n\n      for (var r = this.endpointMap.entrySet().iterator(); r.hasNext();) {\n        var s = r.next(),\n            o = s.getValue(),\n            a = o.count;\n        this.bnRule.isInBoundary(a) && e.add(s.getKey());\n      }\n\n      return H.toCoordinateArray(e);\n    },\n    addEndpoint: function addEndpoint(t) {\n      var e = this.endpointMap.get(t);\n      null === e && (e = new pt(), this.endpointMap.put(t, e)), e.count++;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return dt;\n    }\n  }), dt.getBoundary = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new dt(t);\n      return e.getBoundary();\n    }\n\n    if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          e = new dt(n, i);\n      return e.getBoundary();\n    }\n  }, e(pt.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return pt;\n    }\n  }), e(Nt.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Nt;\n    }\n  }), Nt.chars = function (t, e) {\n    for (var n = new Array(e).fill(null), i = 0; e > i; i++) {\n      n[i] = t;\n    }\n\n    return new String(n);\n  }, Nt.getStackTrace = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new xt(),\n          n = new vt(e);\n      return t.printStackTrace(n), e.toString();\n    }\n\n    if (2 === arguments.length) {\n      for (var i = arguments[0], r = arguments[1], s = \"\", o = new mt(Nt.getStackTrace(i)), a = new It(o), u = 0; r > u; u++) {\n        try {\n          s += a.readLine() + Nt.NEWLINE;\n        } catch (t) {\n          if (!(t instanceof Et)) throw t;\n          f.shouldNeverReachHere();\n        } finally {}\n      }\n\n      return s;\n    }\n  }, Nt.split = function (t, e) {\n    for (var n = e.length, i = new I(), r = \"\" + t, s = r.indexOf(e); s >= 0;) {\n      var o = r.substring(0, s);\n      i.add(o), r = r.substring(s + n), s = r.indexOf(e);\n    }\n\n    r.length > 0 && i.add(r);\n\n    for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++) {\n      a[u] = i.get(u);\n    }\n\n    return a;\n  }, Nt.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Nt.SIMPLE_ORDINATE_FORMAT.format(t);\n    }\n  }, Nt.spaces = function (t) {\n    return Nt.chars(\" \", t);\n  }, Nt.NEWLINE = A.getProperty(\"line.separator\"), Nt.SIMPLE_ORDINATE_FORMAT = new yt(\"0.#\"), e(Ct.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ct;\n    }\n  }), Ct.copyCoord = function (t, e, n, i) {\n    for (var r = Math.min(t.getDimension(), n.getDimension()), s = 0; r > s; s++) {\n      n.setOrdinate(i, s, t.getOrdinate(e, s));\n    }\n  }, Ct.isRing = function (t) {\n    var e = t.size();\n    return 0 === e ? !0 : 3 >= e ? !1 : t.getOrdinate(0, D.X) === t.getOrdinate(e - 1, D.X) && t.getOrdinate(0, D.Y) === t.getOrdinate(e - 1, D.Y);\n  }, Ct.isEqual = function (t, e) {\n    var n = t.size(),\n        i = e.size();\n    if (n !== i) return !1;\n\n    for (var s = Math.min(t.getDimension(), e.getDimension()), o = 0; n > o; o++) {\n      for (var a = 0; s > a; a++) {\n        var u = t.getOrdinate(o, a),\n            l = e.getOrdinate(o, a);\n        if (!(t.getOrdinate(o, a) === e.getOrdinate(o, a) || r.isNaN(u) && r.isNaN(l))) return !1;\n      }\n    }\n\n    return !0;\n  }, Ct.extend = function (t, e, n) {\n    var i = t.create(n, e.getDimension()),\n        r = e.size();\n    if (Ct.copy(e, 0, i, 0, r), r > 0) for (var s = r; n > s; s++) {\n      Ct.copy(e, r - 1, i, s, 1);\n    }\n    return i;\n  }, Ct.reverse = function (t) {\n    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; n >= i; i++) {\n      Ct.swap(t, i, e - i);\n    }\n  }, Ct.swap = function (t, e, n) {\n    if (e === n) return null;\n\n    for (var i = 0; i < t.getDimension(); i++) {\n      var r = t.getOrdinate(e, i);\n      t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);\n    }\n  }, Ct.copy = function (t, e, n, i, r) {\n    for (var s = 0; r > s; s++) {\n      Ct.copyCoord(t, e + s, n, i + s);\n    }\n  }, Ct.toString = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = t.size();\n      if (0 === e) return \"()\";\n      var n = t.getDimension(),\n          i = new P();\n      i.append(\"(\");\n\n      for (var r = 0; e > r; r++) {\n        r > 0 && i.append(\" \");\n\n        for (var s = 0; n > s; s++) {\n          s > 0 && i.append(\",\"), i.append(Nt.toString(t.getOrdinate(r, s)));\n        }\n      }\n\n      return i.append(\")\"), i.toString();\n    }\n  }, Ct.ensureValidRing = function (t, e) {\n    var n = e.size();\n    if (0 === n) return e;\n    if (3 >= n) return Ct.createClosedRing(t, e, 4);\n    var i = e.getOrdinate(0, D.X) === e.getOrdinate(n - 1, D.X) && e.getOrdinate(0, D.Y) === e.getOrdinate(n - 1, D.Y);\n    return i ? e : Ct.createClosedRing(t, e, n + 1);\n  }, Ct.createClosedRing = function (t, e, n) {\n    var i = t.create(n, e.getDimension()),\n        r = e.size();\n    Ct.copy(e, 0, i, 0, r);\n\n    for (var s = r; n > s; s++) {\n      Ct.copy(e, 0, i, s, 1);\n    }\n\n    return i;\n  }, h(St, B), e(St.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      return this.isEmpty() ? new C() : this.points.expandEnvelope(new C());\n    },\n    isRing: function isRing() {\n      return this.isClosed() && this.isSimple();\n    },\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_LINESTRING;\n    },\n    getCoordinates: function getCoordinates() {\n      return this.points.toCoordinateArray();\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        if (!this.isEquivalentClass(t)) return !1;\n        var n = t;\n        if (this.points.size() !== n.points.size()) return !1;\n\n        for (var i = 0; i < this.points.size(); i++) {\n          if (!this.equal(this.points.getCoordinate(i), n.points.getCoordinate(i), e)) return !1;\n        }\n\n        return !0;\n      }\n\n      return B.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) {\n        var e = this.points.size() - 1 - t;\n        if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e))) return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && Ct.reverse(this.points), null;\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this.isEmpty() ? null : this.points.getCoordinate(0);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return this.isClosed() ? lt.FALSE : 0;\n    },\n    isClosed: function isClosed() {\n      return this.isEmpty() ? !1 : this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n    },\n    getEndPoint: function getEndPoint() {\n      return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);\n    },\n    getDimension: function getDimension() {\n      return 1;\n    },\n    getLength: function getLength() {\n      return he.computeLength(this.points);\n    },\n    getNumPoints: function getNumPoints() {\n      return this.points.size();\n    },\n    reverse: function reverse() {\n      var t = this.points.copy();\n      Ct.reverse(t);\n      var e = this.getFactory().createLineString(t);\n      return e;\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = t, n = 0, i = 0; n < this.points.size() && i < e.points.size();) {\n          var r = this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));\n          if (0 !== r) return r;\n          n++, i++;\n        }\n\n        return n < this.points.size() ? 1 : i < e.points.size() ? -1 : 0;\n      }\n\n      if (2 === arguments.length) {\n        var s = arguments[0],\n            o = arguments[1],\n            e = s;\n        return o.compare(this.points, e.points);\n      }\n    },\n    apply: function apply() {\n      if (R(arguments[0], z)) for (var t = arguments[0], e = 0; e < this.points.size(); e++) {\n        t.filter(this.points.getCoordinate(e));\n      } else if (R(arguments[0], ct)) {\n        var n = arguments[0];\n        if (0 === this.points.size()) return null;\n\n        for (var e = 0; e < this.points.size() && (n.filter(this.points, e), !n.isDone()); e++) {\n          ;\n        }\n\n        n.isGeometryChanged() && this.geometryChanged();\n      } else if (R(arguments[0], ht)) {\n        var i = arguments[0];\n        i.filter(this);\n      } else if (R(arguments[0], q)) {\n        var r = arguments[0];\n        r.filter(this);\n      }\n    },\n    getBoundary: function getBoundary() {\n      return new dt(this).getBoundary();\n    },\n    isEquivalentClass: function isEquivalentClass(t) {\n      return t instanceof St;\n    },\n    clone: function clone() {\n      var t = B.prototype.clone.call(this);\n      return t.points = this.points.clone(), t;\n    },\n    getCoordinateN: function getCoordinateN(t) {\n      return this.points.getCoordinate(t);\n    },\n    getGeometryType: function getGeometryType() {\n      return \"LineString\";\n    },\n    copy: function copy() {\n      return new St(this.points.copy(), this.factory);\n    },\n    getCoordinateSequence: function getCoordinateSequence() {\n      return this.points;\n    },\n    isEmpty: function isEmpty() {\n      return 0 === this.points.size();\n    },\n    init: function init(t) {\n      if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new i(\"Invalid number of points in LineString (found \" + t.size() + \" - must be 0 or >= 2)\");\n      this.points = t;\n    },\n    isCoordinate: function isCoordinate(t) {\n      for (var e = 0; e < this.points.size(); e++) {\n        if (this.points.getCoordinate(e).equals(t)) return !0;\n      }\n\n      return !1;\n    },\n    getStartPoint: function getStartPoint() {\n      return this.isEmpty() ? null : this.getPointN(0);\n    },\n    getPointN: function getPointN(t) {\n      return this.getFactory().createPoint(this.points.getCoordinate(t));\n    },\n    interfaces_: function interfaces_() {\n      return [st];\n    },\n    getClass: function getClass() {\n      return St;\n    }\n  }), St.serialVersionUID = 0x2b2b51ba435c8e00, e(wt.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return wt;\n    }\n  }), h(Lt, B), e(Lt.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      if (this.isEmpty()) return new C();\n      var t = new C();\n      return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t;\n    },\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_POINT;\n    },\n    getCoordinates: function getCoordinates() {\n      return this.isEmpty() ? [] : [this.getCoordinate()];\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.isEquivalentClass(t) ? this.isEmpty() && t.isEmpty() ? !0 : this.isEmpty() !== t.isEmpty() ? !1 : this.equal(t.getCoordinate(), this.getCoordinate(), e) : !1;\n      }\n\n      return B.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {},\n    getCoordinate: function getCoordinate() {\n      return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null;\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return lt.FALSE;\n    },\n    getDimension: function getDimension() {\n      return 0;\n    },\n    getNumPoints: function getNumPoints() {\n      return this.isEmpty() ? 0 : 1;\n    },\n    reverse: function reverse() {\n      return this.copy();\n    },\n    getX: function getX() {\n      if (null === this.getCoordinate()) throw new IllegalStateException(\"getX called on empty Point\");\n      return this.getCoordinate().x;\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = t;\n        return this.getCoordinate().compareTo(e.getCoordinate());\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            e = n;\n        return i.compare(this.coordinates, e.coordinates);\n      }\n    },\n    apply: function apply() {\n      if (R(arguments[0], z)) {\n        var t = arguments[0];\n        if (this.isEmpty()) return null;\n        t.filter(this.getCoordinate());\n      } else if (R(arguments[0], ct)) {\n        var e = arguments[0];\n        if (this.isEmpty()) return null;\n        e.filter(this.coordinates, 0), e.isGeometryChanged() && this.geometryChanged();\n      } else if (R(arguments[0], ht)) {\n        var n = arguments[0];\n        n.filter(this);\n      } else if (R(arguments[0], q)) {\n        var i = arguments[0];\n        i.filter(this);\n      }\n    },\n    getBoundary: function getBoundary() {\n      return this.getFactory().createGeometryCollection(null);\n    },\n    clone: function clone() {\n      var t = B.prototype.clone.call(this);\n      return t.coordinates = this.coordinates.clone(), t;\n    },\n    getGeometryType: function getGeometryType() {\n      return \"Point\";\n    },\n    copy: function copy() {\n      return new Lt(this.coordinates.copy(), this.factory);\n    },\n    getCoordinateSequence: function getCoordinateSequence() {\n      return this.coordinates;\n    },\n    getY: function getY() {\n      if (null === this.getCoordinate()) throw new IllegalStateException(\"getY called on empty Point\");\n      return this.getCoordinate().y;\n    },\n    isEmpty: function isEmpty() {\n      return 0 === this.coordinates.size();\n    },\n    init: function init(t) {\n      null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), f.isTrue(t.size() <= 1), this.coordinates = t;\n    },\n    isSimple: function isSimple() {\n      return !0;\n    },\n    interfaces_: function interfaces_() {\n      return [wt];\n    },\n    getClass: function getClass() {\n      return Lt;\n    }\n  }), Lt.serialVersionUID = 0x44077bad161cbc00, e(Rt.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Rt;\n    }\n  }), h(Tt, B), e(Tt.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      return this.shell.getEnvelopeInternal();\n    },\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_POLYGON;\n    },\n    getCoordinates: function getCoordinates() {\n      if (this.isEmpty()) return [];\n\n      for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this.shell.getCoordinates(), i = 0; i < n.length; i++) {\n        e++, t[e] = n[i];\n      }\n\n      for (var r = 0; r < this.holes.length; r++) {\n        for (var s = this.holes[r].getCoordinates(), o = 0; o < s.length; o++) {\n          e++, t[e] = s[o];\n        }\n      }\n\n      return t;\n    },\n    getArea: function getArea() {\n      var t = 0;\n      t += Math.abs(he.signedArea(this.shell.getCoordinateSequence()));\n\n      for (var e = 0; e < this.holes.length; e++) {\n        t -= Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));\n      }\n\n      return t;\n    },\n    isRectangle: function isRectangle() {\n      if (0 !== this.getNumInteriorRing()) return !1;\n      if (null === this.shell) return !1;\n      if (5 !== this.shell.getNumPoints()) return !1;\n\n      for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; 5 > n; n++) {\n        var i = t.getX(n);\n        if (i !== e.getMinX() && i !== e.getMaxX()) return !1;\n        var r = t.getY(n);\n        if (r !== e.getMinY() && r !== e.getMaxY()) return !1;\n      }\n\n      for (var s = t.getX(0), o = t.getY(0), n = 1; 4 >= n; n++) {\n        var i = t.getX(n),\n            r = t.getY(n),\n            a = i !== s,\n            u = r !== o;\n        if (a === u) return !1;\n        s = i, o = r;\n      }\n\n      return !0;\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        if (!this.isEquivalentClass(t)) return !1;\n        var n = t,\n            i = this.shell,\n            r = n.shell;\n        if (!i.equalsExact(r, e)) return !1;\n        if (this.holes.length !== n.holes.length) return !1;\n\n        for (var s = 0; s < this.holes.length; s++) {\n          if (!this.holes[s].equalsExact(n.holes[s], e)) return !1;\n        }\n\n        return !0;\n      }\n\n      return B.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      if (0 === arguments.length) {\n        this.normalize(this.shell, !0);\n\n        for (var t = 0; t < this.holes.length; t++) {\n          this.normalize(this.holes[t], !1);\n        }\n\n        ut.sort(this.holes);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (e.isEmpty()) return null;\n        var i = new Array(e.getCoordinates().length - 1).fill(null);\n        A.arraycopy(e.getCoordinates(), 0, i, 0, i.length);\n        var r = H.minCoordinate(e.getCoordinates());\n        H.scroll(i, r), A.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], he.isCCW(e.getCoordinates()) === n && H.reverse(e.getCoordinates());\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this.shell.getCoordinate();\n    },\n    getNumInteriorRing: function getNumInteriorRing() {\n      return this.holes.length;\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return 1;\n    },\n    getDimension: function getDimension() {\n      return 2;\n    },\n    getLength: function getLength() {\n      var t = 0;\n      t += this.shell.getLength();\n\n      for (var e = 0; e < this.holes.length; e++) {\n        t += this.holes[e].getLength();\n      }\n\n      return t;\n    },\n    getNumPoints: function getNumPoints() {\n      for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) {\n        t += this.holes[e].getNumPoints();\n      }\n\n      return t;\n    },\n    reverse: function reverse() {\n      var t = this.copy();\n      t.shell = this.shell.copy().reverse(), t.holes = new Array(this.holes.length).fill(null);\n\n      for (var e = 0; e < this.holes.length; e++) {\n        t.holes[e] = this.holes[e].copy().reverse();\n      }\n\n      return t;\n    },\n    convexHull: function convexHull() {\n      return this.getExteriorRing().convexHull();\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this.shell,\n            n = t.shell;\n        return e.compareToSameClass(n);\n      }\n\n      if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1],\n            s = i,\n            e = this.shell,\n            n = s.shell,\n            o = e.compareToSameClass(n, r);\n        if (0 !== o) return o;\n\n        for (var a = this.getNumInteriorRing(), u = s.getNumInteriorRing(), l = 0; a > l && u > l;) {\n          var h = this.getInteriorRingN(l),\n              c = s.getInteriorRingN(l),\n              f = h.compareToSameClass(c, r);\n          if (0 !== f) return f;\n          l++;\n        }\n\n        return a > l ? 1 : u > l ? -1 : 0;\n      }\n    },\n    apply: function apply() {\n      if (R(arguments[0], z)) {\n        var t = arguments[0];\n        this.shell.apply(t);\n\n        for (var e = 0; e < this.holes.length; e++) {\n          this.holes[e].apply(t);\n        }\n      } else if (R(arguments[0], ct)) {\n        var n = arguments[0];\n        if (this.shell.apply(n), !n.isDone()) for (var e = 0; e < this.holes.length && (this.holes[e].apply(n), !n.isDone()); e++) {\n          ;\n        }\n        n.isGeometryChanged() && this.geometryChanged();\n      } else if (R(arguments[0], ht)) {\n        var i = arguments[0];\n        i.filter(this);\n      } else if (R(arguments[0], q)) {\n        var r = arguments[0];\n        r.filter(this), this.shell.apply(r);\n\n        for (var e = 0; e < this.holes.length; e++) {\n          this.holes[e].apply(r);\n        }\n      }\n    },\n    getBoundary: function getBoundary() {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n      var t = new Array(this.holes.length + 1).fill(null);\n      t[0] = this.shell;\n\n      for (var e = 0; e < this.holes.length; e++) {\n        t[e + 1] = this.holes[e];\n      }\n\n      return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);\n    },\n    clone: function clone() {\n      var t = B.prototype.clone.call(this);\n      t.shell = this.shell.clone(), t.holes = new Array(this.holes.length).fill(null);\n\n      for (var e = 0; e < this.holes.length; e++) {\n        t.holes[e] = this.holes[e].clone();\n      }\n\n      return t;\n    },\n    getGeometryType: function getGeometryType() {\n      return \"Polygon\";\n    },\n    copy: function copy() {\n      for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), n = 0; n < e.length; n++) {\n        e[n] = this.holes[n].copy();\n      }\n\n      return new Tt(t, e, this.factory);\n    },\n    getExteriorRing: function getExteriorRing() {\n      return this.shell;\n    },\n    isEmpty: function isEmpty() {\n      return this.shell.isEmpty();\n    },\n    getInteriorRingN: function getInteriorRingN(t) {\n      return this.holes[t];\n    },\n    interfaces_: function interfaces_() {\n      return [Rt];\n    },\n    getClass: function getClass() {\n      return Tt;\n    }\n  }), Tt.serialVersionUID = -0x307ffefd8dc97200, h(Pt, ft), e(Pt.prototype, {\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_MULTIPOINT;\n    },\n    isValid: function isValid() {\n      return !0;\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.isEquivalentClass(t) ? ft.prototype.equalsExact.call(this, t, e) : !1;\n      }\n\n      return ft.prototype.equalsExact.apply(this, arguments);\n    },\n    getCoordinate: function getCoordinate() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.geometries[t].getCoordinate();\n      }\n\n      return ft.prototype.getCoordinate.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return lt.FALSE;\n    },\n    getDimension: function getDimension() {\n      return 0;\n    },\n    getBoundary: function getBoundary() {\n      return this.getFactory().createGeometryCollection(null);\n    },\n    getGeometryType: function getGeometryType() {\n      return \"MultiPoint\";\n    },\n    copy: function copy() {\n      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {\n        t[e] = this.geometries[e].copy();\n      }\n\n      return new Pt(t, this.factory);\n    },\n    interfaces_: function interfaces_() {\n      return [wt];\n    },\n    getClass: function getClass() {\n      return Pt;\n    }\n  }), Pt.serialVersionUID = -0x6fb1ed4162e0fc00, h(bt, St), e(bt.prototype, {\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_LINEARRING;\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return lt.FALSE;\n    },\n    isClosed: function isClosed() {\n      return this.isEmpty() ? !0 : St.prototype.isClosed.call(this);\n    },\n    reverse: function reverse() {\n      var t = this.points.copy();\n      Ct.reverse(t);\n      var e = this.getFactory().createLinearRing(t);\n      return e;\n    },\n    validateConstruction: function validateConstruction() {\n      if (!this.isEmpty() && !St.prototype.isClosed.call(this)) throw new i(\"Points of LinearRing do not form a closed linestring\");\n      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < bt.MINIMUM_VALID_SIZE) throw new i(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n    },\n    getGeometryType: function getGeometryType() {\n      return \"LinearRing\";\n    },\n    copy: function copy() {\n      return new bt(this.points.copy(), this.factory);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return bt;\n    }\n  }), bt.MINIMUM_VALID_SIZE = 4, bt.serialVersionUID = -0x3b229e262367a600, h(Ot, ft), e(Ot.prototype, {\n    getSortIndex: function getSortIndex() {\n      return B.SORTINDEX_MULTIPOLYGON;\n    },\n    equalsExact: function equalsExact() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.isEquivalentClass(t) ? ft.prototype.equalsExact.call(this, t, e) : !1;\n      }\n\n      return ft.prototype.equalsExact.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return 1;\n    },\n    getDimension: function getDimension() {\n      return 2;\n    },\n    reverse: function reverse() {\n      for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++) {\n        e[n] = this.geometries[n].reverse();\n      }\n\n      return this.getFactory().createMultiPolygon(e);\n    },\n    getBoundary: function getBoundary() {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n\n      for (var t = new I(), e = 0; e < this.geometries.length; e++) {\n        for (var n = this.geometries[e], i = n.getBoundary(), r = 0; r < i.getNumGeometries(); r++) {\n          t.add(i.getGeometryN(r));\n        }\n      }\n\n      var s = new Array(t.size()).fill(null);\n      return this.getFactory().createMultiLineString(t.toArray(s));\n    },\n    getGeometryType: function getGeometryType() {\n      return \"MultiPolygon\";\n    },\n    copy: function copy() {\n      for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) {\n        t[e] = this.geometries[e].copy();\n      }\n\n      return new Ot(t, this.factory);\n    },\n    interfaces_: function interfaces_() {\n      return [Rt];\n    },\n    getClass: function getClass() {\n      return Ot;\n    }\n  }), Ot.serialVersionUID = -0x7a5aa1369171980, e(_t.prototype, {\n    setCopyUserData: function setCopyUserData(t) {\n      this.isUserDataCopied = t;\n    },\n    edit: function edit(t, e) {\n      if (null === t) return null;\n      var n = this.editInternal(t, e);\n      return this.isUserDataCopied && n.setUserData(t.getUserData()), n;\n    },\n    editInternal: function editInternal(t, e) {\n      return null === this.factory && (this.factory = t.getFactory()), t instanceof ft ? this.editGeometryCollection(t, e) : t instanceof Tt ? this.editPolygon(t, e) : t instanceof Lt ? e.edit(t, this.factory) : t instanceof St ? e.edit(t, this.factory) : (f.shouldNeverReachHere(\"Unsupported Geometry class: \" + t.getClass().getName()), null);\n    },\n    editGeometryCollection: function editGeometryCollection(t, e) {\n      for (var n = e.edit(t, this.factory), i = new I(), r = 0; r < n.getNumGeometries(); r++) {\n        var s = this.edit(n.getGeometryN(r), e);\n        null === s || s.isEmpty() || i.add(s);\n      }\n\n      return n.getClass() === Pt ? this.factory.createMultiPoint(i.toArray([])) : n.getClass() === gt ? this.factory.createMultiLineString(i.toArray([])) : n.getClass() === Ot ? this.factory.createMultiPolygon(i.toArray([])) : this.factory.createGeometryCollection(i.toArray([]));\n    },\n    editPolygon: function editPolygon(t, e) {\n      var n = e.edit(t, this.factory);\n      if (null === n && (n = this.factory.createPolygon(null)), n.isEmpty()) return n;\n      var i = this.edit(n.getExteriorRing(), e);\n      if (null === i || i.isEmpty()) return this.factory.createPolygon();\n\n      for (var r = new I(), s = 0; s < n.getNumInteriorRing(); s++) {\n        var o = this.edit(n.getInteriorRingN(s), e);\n        null === o || o.isEmpty() || r.add(o);\n      }\n\n      return this.factory.createPolygon(i, r.toArray([]));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return _t;\n    }\n  }), _t.GeometryEditorOperation = Mt, e(Dt.prototype, {\n    edit: function edit(t, e) {\n      return t;\n    },\n    interfaces_: function interfaces_() {\n      return [Mt];\n    },\n    getClass: function getClass() {\n      return Dt;\n    }\n  }), e(At.prototype, {\n    edit: function edit(t, e) {\n      if (t instanceof bt) return e.createLinearRing(this.editCoordinates(t.getCoordinates(), t));\n      if (t instanceof St) return e.createLineString(this.editCoordinates(t.getCoordinates(), t));\n\n      if (t instanceof Lt) {\n        var n = this.editCoordinates(t.getCoordinates(), t);\n        return n.length > 0 ? e.createPoint(n[0]) : e.createPoint();\n      }\n\n      return t;\n    },\n    interfaces_: function interfaces_() {\n      return [Mt];\n    },\n    getClass: function getClass() {\n      return At;\n    }\n  }), e(Ft.prototype, {\n    edit: function edit(t, e) {\n      return t instanceof bt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof St ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Lt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;\n    },\n    interfaces_: function interfaces_() {\n      return [Mt];\n    },\n    getClass: function getClass() {\n      return Ft;\n    }\n  }), _t.NoOpGeometryOperation = Dt, _t.CoordinateOperation = At, _t.CoordinateSequenceOperation = Ft, e(Gt.prototype, {\n    setOrdinate: function setOrdinate(t, e, n) {\n      switch (e) {\n        case D.X:\n          this.coordinates[t].x = n;\n          break;\n\n        case D.Y:\n          this.coordinates[t].y = n;\n          break;\n\n        case D.Z:\n          this.coordinates[t].z = n;\n          break;\n\n        default:\n          throw new i(\"invalid ordinateIndex\");\n      }\n    },\n    size: function size() {\n      return this.coordinates.length;\n    },\n    getOrdinate: function getOrdinate(t, e) {\n      switch (e) {\n        case D.X:\n          return this.coordinates[t].x;\n\n        case D.Y:\n          return this.coordinates[t].y;\n\n        case D.Z:\n          return this.coordinates[t].z;\n      }\n\n      return r.NaN;\n    },\n    getCoordinate: function getCoordinate() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.coordinates[t];\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        n.x = this.coordinates[e].x, n.y = this.coordinates[e].y, n.z = this.coordinates[e].z;\n      }\n    },\n    getCoordinateCopy: function getCoordinateCopy(t) {\n      return new g(this.coordinates[t]);\n    },\n    getDimension: function getDimension() {\n      return this.dimension;\n    },\n    getX: function getX(t) {\n      return this.coordinates[t].x;\n    },\n    clone: function clone() {\n      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) {\n        t[e] = this.coordinates[e].clone();\n      }\n\n      return new Gt(t, this.dimension);\n    },\n    expandEnvelope: function expandEnvelope(t) {\n      for (var e = 0; e < this.coordinates.length; e++) {\n        t.expandToInclude(this.coordinates[e]);\n      }\n\n      return t;\n    },\n    copy: function copy() {\n      for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) {\n        t[e] = this.coordinates[e].copy();\n      }\n\n      return new Gt(t, this.dimension);\n    },\n    toString: function toString() {\n      if (this.coordinates.length > 0) {\n        var t = new P(17 * this.coordinates.length);\n        t.append(\"(\"), t.append(this.coordinates[0]);\n\n        for (var e = 1; e < this.coordinates.length; e++) {\n          t.append(\", \"), t.append(this.coordinates[e]);\n        }\n\n        return t.append(\")\"), t.toString();\n      }\n\n      return \"()\";\n    },\n    getY: function getY(t) {\n      return this.coordinates[t].y;\n    },\n    toCoordinateArray: function toCoordinateArray() {\n      return this.coordinates;\n    },\n    interfaces_: function interfaces_() {\n      return [D, u];\n    },\n    getClass: function getClass() {\n      return Gt;\n    }\n  }), Gt.serialVersionUID = -0xcb44a778db18e00, e(qt.prototype, {\n    readResolve: function readResolve() {\n      return qt.instance();\n    },\n    create: function create() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Array) {\n          var t = arguments[0];\n          return new Gt(t);\n        }\n\n        if (R(arguments[0], D)) {\n          var e = arguments[0];\n          return new Gt(e);\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        return i > 3 && (i = 3), 2 > i ? new Gt(n) : new Gt(n, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [G, u];\n    },\n    getClass: function getClass() {\n      return qt;\n    }\n  }), qt.instance = function () {\n    return qt.instanceObject;\n  }, qt.serialVersionUID = -0x38e49fa6cf6f2e00, qt.instanceObject = new qt();\n  var no,\n      io = Object.defineProperty,\n      ro = zt({\n    delete: kt,\n    has: Xt,\n    get: Yt,\n    set: Ht,\n    keys: jt,\n    values: Kt,\n    entries: Zt,\n    forEach: $t,\n    clear: Wt\n  }),\n      so = \"undefined\" != typeof Map && Map.prototype.values ? Map : ro;\n  te.prototype = new K(), te.prototype.get = function (t) {\n    return this.map_.get(t) || null;\n  }, te.prototype.put = function (t, e) {\n    return this.map_.set(t, e), e;\n  }, te.prototype.values = function () {\n    for (var t = new I(), e = this.map_.values(), n = e.next(); !n.done;) {\n      t.add(n.value), n = e.next();\n    }\n\n    return t;\n  }, te.prototype.entrySet = function () {\n    var t = new J();\n    return this.map_.entries().forEach(function (e) {\n      return t.add(e);\n    }), t;\n  }, te.prototype.size = function () {\n    return this.map_.size();\n  }, e(ee.prototype, {\n    equals: function equals(t) {\n      if (!(t instanceof ee)) return !1;\n      var e = t;\n      return this.modelType === e.modelType && this.scale === e.scale;\n    },\n    compareTo: function compareTo(t) {\n      var e = t,\n          n = this.getMaximumSignificantDigits(),\n          i = e.getMaximumSignificantDigits();\n      return new b(n).compareTo(new b(i));\n    },\n    getScale: function getScale() {\n      return this.scale;\n    },\n    isFloating: function isFloating() {\n      return this.modelType === ee.FLOATING || this.modelType === ee.FLOATING_SINGLE;\n    },\n    getType: function getType() {\n      return this.modelType;\n    },\n    toString: function toString() {\n      var t = \"UNKNOWN\";\n      return this.modelType === ee.FLOATING ? t = \"Floating\" : this.modelType === ee.FLOATING_SINGLE ? t = \"Floating-Single\" : this.modelType === ee.FIXED && (t = \"Fixed (Scale=\" + this.getScale() + \")\"), t;\n    },\n    makePrecise: function makePrecise() {\n      if (\"number\" == typeof arguments[0]) {\n        var t = arguments[0];\n        if (r.isNaN(t)) return t;\n\n        if (this.modelType === ee.FLOATING_SINGLE) {\n          var e = t;\n          return e;\n        }\n\n        return this.modelType === ee.FIXED ? Math.round(t * this.scale) / this.scale : t;\n      }\n\n      if (arguments[0] instanceof g) {\n        var n = arguments[0];\n        if (this.modelType === ee.FLOATING) return null;\n        n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);\n      }\n    },\n    getMaximumSignificantDigits: function getMaximumSignificantDigits() {\n      var t = 16;\n      return this.modelType === ee.FLOATING ? t = 16 : this.modelType === ee.FLOATING_SINGLE ? t = 6 : this.modelType === ee.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;\n    },\n    setScale: function setScale(t) {\n      this.scale = Math.abs(t);\n    },\n    interfaces_: function interfaces_() {\n      return [u, s];\n    },\n    getClass: function getClass() {\n      return ee;\n    }\n  }), ee.mostPrecise = function (t, e) {\n    return t.compareTo(e) >= 0 ? t : e;\n  }, e(ne.prototype, {\n    readResolve: function readResolve() {\n      return ne.nameToTypeMap.get(this.name);\n    },\n    toString: function toString() {\n      return this.name;\n    },\n    interfaces_: function interfaces_() {\n      return [u];\n    },\n    getClass: function getClass() {\n      return ne;\n    }\n  }), ne.serialVersionUID = -552860263173159e4, ne.nameToTypeMap = new te(), ee.Type = ne, ee.serialVersionUID = 0x6bee6404e9a25c00, ee.FIXED = new ne(\"FIXED\"), ee.FLOATING = new ne(\"FLOATING\"), ee.FLOATING_SINGLE = new ne(\"FLOATING SINGLE\"), ee.maximumPreciseValue = 9007199254740992, e(ie.prototype, {\n    toGeometry: function toGeometry(t) {\n      return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new g(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new g(t.getMinX(), t.getMinY()), new g(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new g(t.getMinX(), t.getMinY()), new g(t.getMinX(), t.getMaxY()), new g(t.getMaxX(), t.getMaxY()), new g(t.getMaxX(), t.getMinY()), new g(t.getMinX(), t.getMinY())]), null);\n    },\n    createLineString: function createLineString() {\n      if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Array) {\n          var t = arguments[0];\n          return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n        }\n\n        if (R(arguments[0], D)) {\n          var e = arguments[0];\n          return new St(e, this);\n        }\n      }\n    },\n    createMultiLineString: function createMultiLineString() {\n      if (0 === arguments.length) return new gt(null, this);\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return new gt(t, this);\n      }\n    },\n    buildGeometry: function buildGeometry(t) {\n      for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext();) {\n        var s = r.next(),\n            o = s.getClass();\n        null === e && (e = o), o !== e && (n = !0), s.isGeometryCollectionOrDerived() && (i = !0);\n      }\n\n      if (null === e) return this.createGeometryCollection();\n      if (n || i) return this.createGeometryCollection(ie.toGeometryArray(t));\n      var a = t.iterator().next(),\n          u = t.size() > 1;\n\n      if (u) {\n        if (a instanceof Tt) return this.createMultiPolygon(ie.toPolygonArray(t));\n        if (a instanceof St) return this.createMultiLineString(ie.toLineStringArray(t));\n        if (a instanceof Lt) return this.createMultiPoint(ie.toPointArray(t));\n        f.shouldNeverReachHere(\"Unhandled class: \" + a.getClass().getName());\n      }\n\n      return a;\n    },\n    createMultiPointFromCoords: function createMultiPointFromCoords(t) {\n      return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n    },\n    createPoint: function createPoint() {\n      if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof g) {\n          var t = arguments[0];\n          return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);\n        }\n\n        if (R(arguments[0], D)) {\n          var e = arguments[0];\n          return new Lt(e, this);\n        }\n      }\n    },\n    getCoordinateSequenceFactory: function getCoordinateSequenceFactory() {\n      return this.coordinateSequenceFactory;\n    },\n    createPolygon: function createPolygon() {\n      if (0 === arguments.length) return new Tt(null, null, this);\n\n      if (1 === arguments.length) {\n        if (R(arguments[0], D)) {\n          var t = arguments[0];\n          return this.createPolygon(this.createLinearRing(t));\n        }\n\n        if (arguments[0] instanceof Array) {\n          var e = arguments[0];\n          return this.createPolygon(this.createLinearRing(e));\n        }\n\n        if (arguments[0] instanceof bt) {\n          var n = arguments[0];\n          return this.createPolygon(n, null);\n        }\n      } else if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1];\n        return new Tt(i, r, this);\n      }\n    },\n    getSRID: function getSRID() {\n      return this.SRID;\n    },\n    createGeometryCollection: function createGeometryCollection() {\n      if (0 === arguments.length) return new ft(null, this);\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return new ft(t, this);\n      }\n    },\n    createGeometry: function createGeometry(t) {\n      var e = new _t(this);\n      return e.edit(t, {\n        edit: function edit() {\n          if (2 === arguments.length) {\n            var t = arguments[0];\n            arguments[1];\n            return this.coordinateSequenceFactory.create(t);\n          }\n        }\n      });\n    },\n    getPrecisionModel: function getPrecisionModel() {\n      return this.precisionModel;\n    },\n    createLinearRing: function createLinearRing() {\n      if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Array) {\n          var t = arguments[0];\n          return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n        }\n\n        if (R(arguments[0], D)) {\n          var e = arguments[0];\n          return new bt(e, this);\n        }\n      }\n    },\n    createMultiPolygon: function createMultiPolygon() {\n      if (0 === arguments.length) return new Ot(null, this);\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return new Ot(t, this);\n      }\n    },\n    createMultiPoint: function createMultiPoint() {\n      if (0 === arguments.length) return new Pt(null, this);\n\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Array) {\n          var t = arguments[0];\n          return new Pt(t, this);\n        }\n\n        if (arguments[0] instanceof Array) {\n          var e = arguments[0];\n          return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null);\n        }\n\n        if (R(arguments[0], D)) {\n          var n = arguments[0];\n          if (null === n) return this.createMultiPoint(new Array(0).fill(null));\n\n          for (var i = new Array(n.size()).fill(null), r = 0; r < n.size(); r++) {\n            var s = this.getCoordinateSequenceFactory().create(1, n.getDimension());\n            Ct.copy(n, r, s, 0, 1), i[r] = this.createPoint(s);\n          }\n\n          return this.createMultiPoint(i);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [u];\n    },\n    getClass: function getClass() {\n      return ie;\n    }\n  }), ie.toMultiPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toGeometryArray = function (t) {\n    if (null === t) return null;\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.getDefaultCoordinateSequenceFactory = function () {\n    return qt.instance();\n  }, ie.toMultiLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toLineStringArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toMultiPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toLinearRingArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toPointArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.toPolygonArray = function (t) {\n    var e = new Array(t.size()).fill(null);\n    return t.toArray(e);\n  }, ie.createPointFromInternalCoord = function (t, e) {\n    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n  }, ie.serialVersionUID = -0x5ea75f2051eeb400;\n  var oo = {\n    typeStr: /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    emptyTypeStr: /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    spaces: /\\s+/,\n    parenComma: /\\)\\s*,\\s*\\(/,\n    doubleParenComma: /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    trimParens: /^\\s*\\(?(.*?)\\)?\\s*$/\n  };\n  e(re.prototype, {\n    read: function read(t) {\n      var e, n, i;\n      t = t.replace(/[\\n\\r]/g, \" \");\n      var r = oo.typeStr.exec(t);\n      if (-1 !== t.search(\"EMPTY\") && (r = oo.emptyTypeStr.exec(t), r[2] = void 0), r && (n = r[1].toLowerCase(), i = r[2], uo[n] && (e = uo[n].apply(this, [i]))), void 0 === e) throw new Error(\"Could not parse WKT \" + t);\n      return e;\n    },\n    write: function write(t) {\n      return this.extractGeometry(t);\n    },\n    extractGeometry: function extractGeometry(t) {\n      var e = t.getGeometryType().toLowerCase();\n      if (!ao[e]) return null;\n      var n,\n          i = e.toUpperCase();\n      return n = t.isEmpty() ? i + \" EMPTY\" : i + \"(\" + ao[e].apply(this, [t]) + \")\";\n    }\n  });\n  var ao = {\n    coordinate: function coordinate(t) {\n      return t.x + \" \" + t.y;\n    },\n    point: function point(t) {\n      return ao.coordinate.call(this, t.coordinates.coordinates[0]);\n    },\n    multipoint: function multipoint(t) {\n      for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) {\n        e.push(\"(\" + ao.point.apply(this, [t.geometries[n]]) + \")\");\n      }\n\n      return e.join(\",\");\n    },\n    linestring: function linestring(t) {\n      for (var e = [], n = 0, i = t.points.coordinates.length; i > n; ++n) {\n        e.push(ao.coordinate.apply(this, [t.points.coordinates[n]]));\n      }\n\n      return e.join(\",\");\n    },\n    linearring: function linearring(t) {\n      for (var e = [], n = 0, i = t.points.coordinates.length; i > n; ++n) {\n        e.push(ao.coordinate.apply(this, [t.points.coordinates[n]]));\n      }\n\n      return e.join(\",\");\n    },\n    multilinestring: function multilinestring(t) {\n      for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) {\n        e.push(\"(\" + ao.linestring.apply(this, [t.geometries[n]]) + \")\");\n      }\n\n      return e.join(\",\");\n    },\n    polygon: function polygon(t) {\n      var e = [];\n      e.push(\"(\" + ao.linestring.apply(this, [t.shell]) + \")\");\n\n      for (var n = 0, i = t.holes.length; i > n; ++n) {\n        e.push(\"(\" + ao.linestring.apply(this, [t.holes[n]]) + \")\");\n      }\n\n      return e.join(\",\");\n    },\n    multipolygon: function multipolygon(t) {\n      for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) {\n        e.push(\"(\" + ao.polygon.apply(this, [t.geometries[n]]) + \")\");\n      }\n\n      return e.join(\",\");\n    },\n    geometrycollection: function geometrycollection(t) {\n      for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) {\n        e.push(this.extractGeometry(t.geometries[n]));\n      }\n\n      return e.join(\",\");\n    }\n  },\n      uo = {\n    point: function point(t) {\n      if (void 0 === t) return this.geometryFactory.createPoint();\n      var e = t.trim().split(oo.spaces);\n      return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n    },\n    multipoint: function multipoint(t) {\n      if (void 0 === t) return this.geometryFactory.createMultiPoint();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, s = n.length; s > r; ++r) {\n        e = n[r].replace(oo.trimParens, \"$1\"), i.push(uo.point.apply(this, [e]));\n      }\n\n      return this.geometryFactory.createMultiPoint(i);\n    },\n    linestring: function linestring(t) {\n      if (void 0 === t) return this.geometryFactory.createLineString();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, s = n.length; s > r; ++r) {\n        e = n[r].trim().split(oo.spaces), i.push(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n      }\n\n      return this.geometryFactory.createLineString(i);\n    },\n    linearring: function linearring(t) {\n      if (void 0 === t) return this.geometryFactory.createLinearRing();\n\n      for (var e, n = t.trim().split(\",\"), i = [], r = 0, s = n.length; s > r; ++r) {\n        e = n[r].trim().split(oo.spaces), i.push(new g(Number.parseFloat(e[0]), Number.parseFloat(e[1])));\n      }\n\n      return this.geometryFactory.createLinearRing(i);\n    },\n    multilinestring: function multilinestring(t) {\n      if (void 0 === t) return this.geometryFactory.createMultiLineString();\n\n      for (var e, n = t.trim().split(oo.parenComma), i = [], r = 0, s = n.length; s > r; ++r) {\n        e = n[r].replace(oo.trimParens, \"$1\"), i.push(uo.linestring.apply(this, [e]));\n      }\n\n      return this.geometryFactory.createMultiLineString(i);\n    },\n    polygon: function polygon(t) {\n      if (void 0 === t) return this.geometryFactory.createPolygon();\n\n      for (var e, n, i, r, s = t.trim().split(oo.parenComma), o = [], a = 0, u = s.length; u > a; ++a) {\n        e = s[a].replace(oo.trimParens, \"$1\"), n = uo.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n.points), 0 === a ? r = i : o.push(i);\n      }\n\n      return this.geometryFactory.createPolygon(r, o);\n    },\n    multipolygon: function multipolygon(t) {\n      if (void 0 === t) return this.geometryFactory.createMultiPolygon();\n\n      for (var e, n = t.trim().split(oo.doubleParenComma), i = [], r = 0, s = n.length; s > r; ++r) {\n        e = n[r].replace(oo.trimParens, \"$1\"), i.push(uo.polygon.apply(this, [e]));\n      }\n\n      return this.geometryFactory.createMultiPolygon(i);\n    },\n    geometrycollection: function geometrycollection(t) {\n      if (void 0 === t) return this.geometryFactory.createGeometryCollection();\n      t = t.replace(/,\\s*([A-Za-z])/g, \"|$1\");\n\n      for (var e = t.trim().split(\"|\"), n = [], i = 0, r = e.length; r > i; ++i) {\n        n.push(this.read(e[i]));\n      }\n\n      return this.geometryFactory.createGeometryCollection(n);\n    }\n  };\n  e(se.prototype, {\n    write: function write(t) {\n      return this.parser.write(t);\n    }\n  }), e(se, {\n    toLineString: function toLineString(t, e) {\n      if (2 !== arguments.length) throw new Error(\"Not implemented\");\n      return \"LINESTRING ( \" + t.x + \" \" + t.y + \", \" + e.x + \" \" + e.y + \" )\";\n    }\n  }), e(oe.prototype, {\n    getIndexAlongSegment: function getIndexAlongSegment(t, e) {\n      return this.computeIntLineIndex(), this.intLineIndex[t][e];\n    },\n    getTopologySummary: function getTopologySummary() {\n      var t = new P();\n      return this.isEndPoint() && t.append(\" endpoint\"), this._isProper && t.append(\" proper\"), this.isCollinear() && t.append(\" collinear\"), t.toString();\n    },\n    computeIntersection: function computeIntersection(t, e, n, i) {\n      this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = n, this.inputLines[1][1] = i, this.result = this.computeIntersect(t, e, n, i);\n    },\n    getIntersectionNum: function getIntersectionNum() {\n      return this.result;\n    },\n    computeIntLineIndex: function computeIntLineIndex() {\n      if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function () {\n        return Array(2);\n      }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this.getEdgeDistance(t, 0),\n            n = this.getEdgeDistance(t, 1);\n        e > n ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0);\n      }\n    },\n    isProper: function isProper() {\n      return this.hasIntersection() && this._isProper;\n    },\n    setPrecisionModel: function setPrecisionModel(t) {\n      this.precisionModel = t;\n    },\n    isInteriorIntersection: function isInteriorIntersection() {\n      if (0 === arguments.length) return this.isInteriorIntersection(0) ? !0 : !!this.isInteriorIntersection(1);\n\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = 0; e < this.result; e++) {\n          if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;\n        }\n\n        return !1;\n      }\n    },\n    getIntersection: function getIntersection(t) {\n      return this.intPt[t];\n    },\n    isEndPoint: function isEndPoint() {\n      return this.hasIntersection() && !this._isProper;\n    },\n    hasIntersection: function hasIntersection() {\n      return this.result !== oe.NO_INTERSECTION;\n    },\n    getEdgeDistance: function getEdgeDistance(t, e) {\n      var n = oe.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1]);\n      return n;\n    },\n    isCollinear: function isCollinear() {\n      return this.result === oe.COLLINEAR_INTERSECTION;\n    },\n    toString: function toString() {\n      return se.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + \" - \" + se.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary();\n    },\n    getEndpoint: function getEndpoint(t, e) {\n      return this.inputLines[t][e];\n    },\n    isIntersection: function isIntersection(t) {\n      for (var e = 0; e < this.result; e++) {\n        if (this.intPt[e].equals2D(t)) return !0;\n      }\n\n      return !1;\n    },\n    getIntersectionAlongSegment: function getIntersectionAlongSegment(t, e) {\n      return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t][e]];\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return oe;\n    }\n  }), oe.computeEdgeDistance = function (t, e, n) {\n    var i = Math.abs(n.x - e.x),\n        r = Math.abs(n.y - e.y),\n        s = -1;\n    if (t.equals(e)) s = 0;else if (t.equals(n)) s = i > r ? i : r;else {\n      var o = Math.abs(t.x - e.x),\n          a = Math.abs(t.y - e.y);\n      s = i > r ? o : a, 0 !== s || t.equals(e) || (s = Math.max(o, a));\n    }\n    return f.isTrue(!(0 === s && !t.equals(e)), \"Bad distance calculation\"), s;\n  }, oe.nonRobustComputeEdgeDistance = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y,\n        s = Math.sqrt(i * i + r * r);\n    return f.isTrue(!(0 === s && !t.equals(e)), \"Invalid distance calculation\"), s;\n  }, oe.DONT_INTERSECT = 0, oe.DO_INTERSECT = 1, oe.COLLINEAR = 2, oe.NO_INTERSECTION = 0, oe.POINT_INTERSECTION = 1, oe.COLLINEAR_INTERSECTION = 2, h(ae, oe), e(ae.prototype, {\n    isInSegmentEnvelopes: function isInSegmentEnvelopes(t) {\n      var e = new C(this.inputLines[0][0], this.inputLines[0][1]),\n          n = new C(this.inputLines[1][0], this.inputLines[1][1]);\n      return e.contains(t) && n.contains(t);\n    },\n    computeIntersection: function computeIntersection() {\n      if (3 !== arguments.length) return oe.prototype.computeIntersection.apply(this, arguments);\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n      return this._isProper = !1, C.intersects(e, n, t) && 0 === he.orientationIndex(e, n, t) && 0 === he.orientationIndex(n, e, t) ? (this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this.result = oe.POINT_INTERSECTION, null) : void (this.result = oe.NO_INTERSECTION);\n    },\n    normalizeToMinimum: function normalizeToMinimum(t, e, n, i, r) {\n      r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;\n    },\n    safeHCoordinateIntersection: function safeHCoordinateIntersection(t, e, n, i) {\n      var r = null;\n\n      try {\n        r = F.intersection(t, e, n, i);\n      } catch (s) {\n        if (!(s instanceof w)) throw s;\n        r = ae.nearestEndpoint(t, e, n, i);\n      } finally {}\n\n      return r;\n    },\n    intersection: function intersection(t, e, n, i) {\n      var r = this.intersectionWithNormalization(t, e, n, i);\n      return this.isInSegmentEnvelopes(r) || (r = new g(ae.nearestEndpoint(t, e, n, i))), null !== this.precisionModel && this.precisionModel.makePrecise(r), r;\n    },\n    smallestInAbsValue: function smallestInAbsValue(t, e, n, i) {\n      var r = t,\n          s = Math.abs(r);\n      return Math.abs(e) < s && (r = e, s = Math.abs(e)), Math.abs(n) < s && (r = n, s = Math.abs(n)), Math.abs(i) < s && (r = i), r;\n    },\n    checkDD: function checkDD(t, e, n, i, r) {\n      var s = M.intersection(t, e, n, i),\n          o = this.isInSegmentEnvelopes(s);\n      A.out.println(\"DD in env = \" + o + \"  --------------------- \" + s), r.distance(s) > 1e-4 && A.out.println(\"Distance = \" + r.distance(s));\n    },\n    intersectionWithNormalization: function intersectionWithNormalization(t, e, n, i) {\n      var r = new g(t),\n          s = new g(e),\n          o = new g(n),\n          a = new g(i),\n          u = new g();\n      this.normalizeToEnvCentre(r, s, o, a, u);\n      var l = this.safeHCoordinateIntersection(r, s, o, a);\n      return l.x += u.x, l.y += u.y, l;\n    },\n    computeCollinearIntersection: function computeCollinearIntersection(t, e, n, i) {\n      var r = C.intersects(t, e, n),\n          s = C.intersects(t, e, i),\n          o = C.intersects(n, i, t),\n          a = C.intersects(n, i, e);\n      return r && s ? (this.intPt[0] = n, this.intPt[1] = i, oe.COLLINEAR_INTERSECTION) : o && a ? (this.intPt[0] = t, this.intPt[1] = e, oe.COLLINEAR_INTERSECTION) : r && o ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || s || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : r && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || s || o ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s && o ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || r || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : s && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || r || o ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : oe.NO_INTERSECTION;\n    },\n    normalizeToEnvCentre: function normalizeToEnvCentre(t, e, n, i, r) {\n      var s = t.x < e.x ? t.x : e.x,\n          o = t.y < e.y ? t.y : e.y,\n          a = t.x > e.x ? t.x : e.x,\n          u = t.y > e.y ? t.y : e.y,\n          l = n.x < i.x ? n.x : i.x,\n          h = n.y < i.y ? n.y : i.y,\n          c = n.x > i.x ? n.x : i.x,\n          f = n.y > i.y ? n.y : i.y,\n          g = s > l ? s : l,\n          d = c > a ? a : c,\n          p = o > h ? o : h,\n          v = f > u ? u : f,\n          m = (g + d) / 2,\n          y = (p + v) / 2;\n      r.x = m, r.y = y, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, n.x -= r.x, n.y -= r.y, i.x -= r.x, i.y -= r.y;\n    },\n    computeIntersect: function computeIntersect(t, e, n, i) {\n      if (this._isProper = !1, !C.intersects(t, e, n, i)) return oe.NO_INTERSECTION;\n      var r = he.orientationIndex(t, e, n),\n          s = he.orientationIndex(t, e, i);\n      if (r > 0 && s > 0 || 0 > r && 0 > s) return oe.NO_INTERSECTION;\n      var o = he.orientationIndex(n, i, t),\n          a = he.orientationIndex(n, i, e);\n      if (o > 0 && a > 0 || 0 > o && 0 > a) return oe.NO_INTERSECTION;\n      var u = 0 === r && 0 === s && 0 === o && 0 === a;\n      return u ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === o || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this.intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new g(n) : 0 === s ? this.intPt[0] = new g(i) : 0 === o ? this.intPt[0] = new g(t) : 0 === a && (this.intPt[0] = new g(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, n, i)), oe.POINT_INTERSECTION);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ae;\n    }\n  }), ae.nearestEndpoint = function (t, e, n, i) {\n    var r = t,\n        s = he.distancePointLine(t, n, i),\n        o = he.distancePointLine(e, n, i);\n    return s > o && (s = o, r = e), o = he.distancePointLine(n, t, e), s > o && (s = o, r = n), o = he.distancePointLine(i, t, e), s > o && (s = o, r = i), r;\n  }, e(ue.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ue;\n    }\n  }), ue.orientationIndex = function (t, e, n) {\n    var i = e.x - t.x,\n        r = e.y - t.y,\n        s = n.x - e.x,\n        o = n.y - e.y;\n    return ue.signOfDet2x2(i, r, s, o);\n  }, ue.signOfDet2x2 = function (t, e, n, i) {\n    var r = null,\n        s = null,\n        o = null,\n        a = 0;\n    if (r = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;\n    if (0 === e || 0 === n) return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;\n\n    if (e > 0 ? i > 0 ? i >= e || (r = -r, s = t, t = n, n = s, s = e, e = i, i = s) : -i >= e ? (r = -r, n = -n, i = -i) : (s = t, t = -n, n = s, s = e, e = -i, i = s) : i > 0 ? i >= -e ? (r = -r, t = -t, e = -e) : (s = -t, t = n, n = s, s = -e, e = i, i = s) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (r = -r, s = -t, t = -n, n = s, s = -e, e = -i, i = s), t > 0) {\n      if (!(n > 0)) return r;\n      if (!(n >= t)) return r;\n    } else {\n      if (n > 0) return -r;\n      if (!(t >= n)) return -r;\n      r = -r, t = -t, n = -n;\n    }\n\n    for (;;) {\n      if (a += 1, o = Math.floor(n / t), n -= o * t, i -= o * e, 0 > i) return -r;\n      if (i > e) return r;\n\n      if (t > n + n) {\n        if (i + i > e) return r;\n      } else {\n        if (e > i + i) return -r;\n        n = t - n, i = e - i, r = -r;\n      }\n\n      if (0 === i) return 0 === n ? 0 : -r;\n      if (0 === n) return r;\n      if (o = Math.floor(t / n), t -= o * n, e -= o * i, 0 > e) return r;\n      if (e > i) return -r;\n\n      if (n > t + t) {\n        if (e + e > i) return -r;\n      } else {\n        if (i > e + e) return r;\n        t = n - t, e = i - e, r = -r;\n      }\n\n      if (0 === e) return 0 === t ? 0 : r;\n      if (0 === t) return -r;\n    }\n  }, e(le.prototype, {\n    countSegment: function countSegment(t, e) {\n      if (t.x < this.p.x && e.x < this.p.x) return null;\n      if (this.p.x === e.x && this.p.y === e.y) return this.isPointOnSegment = !0, null;\n\n      if (t.y === this.p.y && e.y === this.p.y) {\n        var n = t.x,\n            i = e.x;\n        return n > i && (n = e.x, i = t.x), this.p.x >= n && this.p.x <= i && (this.isPointOnSegment = !0), null;\n      }\n\n      if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {\n        var r = t.x - this.p.x,\n            s = t.y - this.p.y,\n            o = e.x - this.p.x,\n            a = e.y - this.p.y,\n            u = ue.signOfDet2x2(r, s, o, a);\n        if (0 === u) return this.isPointOnSegment = !0, null;\n        s > a && (u = -u), u > 0 && this.crossingCount++;\n      }\n    },\n    isPointInPolygon: function isPointInPolygon() {\n      return this.getLocation() !== L.EXTERIOR;\n    },\n    getLocation: function getLocation() {\n      return this.isPointOnSegment ? L.BOUNDARY : this.crossingCount % 2 === 1 ? L.INTERIOR : L.EXTERIOR;\n    },\n    isOnSegment: function isOnSegment() {\n      return this.isPointOnSegment;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return le;\n    }\n  }), le.locatePointInRing = function () {\n    if (arguments[0] instanceof g && R(arguments[1], D)) {\n      for (var t = arguments[0], e = arguments[1], n = new le(t), i = new g(), r = new g(), s = 1; s < e.size(); s++) {\n        if (e.getCoordinate(s, i), e.getCoordinate(s - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();\n      }\n\n      return n.getLocation();\n    }\n\n    if (arguments[0] instanceof g && arguments[1] instanceof Array) {\n      for (var o = arguments[0], a = arguments[1], n = new le(o), s = 1; s < a.length; s++) {\n        var i = a[s],\n            r = a[s - 1];\n        if (n.countSegment(i, r), n.isOnSegment()) return n.getLocation();\n      }\n\n      return n.getLocation();\n    }\n  }, e(he.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return he;\n    }\n  }), he.orientationIndex = function (t, e, n) {\n    return M.orientationIndex(t, e, n);\n  }, he.signedArea = function () {\n    if (arguments[0] instanceof Array) {\n      var t = arguments[0];\n      if (t.length < 3) return 0;\n\n      for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {\n        var r = t[i].x - n,\n            s = t[i + 1].y,\n            o = t[i - 1].y;\n        e += r * (o - s);\n      }\n\n      return e / 2;\n    }\n\n    if (R(arguments[0], D)) {\n      var a = arguments[0],\n          u = a.size();\n      if (3 > u) return 0;\n      var l = new g(),\n          h = new g(),\n          c = new g();\n      a.getCoordinate(0, h), a.getCoordinate(1, c);\n      var n = h.x;\n      c.x -= n;\n\n      for (var e = 0, i = 1; u - 1 > i; i++) {\n        l.y = h.y, h.x = c.x, h.y = c.y, a.getCoordinate(i + 1, c), c.x -= n, e += h.x * (l.y - c.y);\n      }\n\n      return e / 2;\n    }\n  }, he.distanceLineLine = function (t, e, n, i) {\n    if (t.equals(e)) return he.distancePointLine(t, n, i);\n    if (n.equals(i)) return he.distancePointLine(i, t, e);\n    var r = !1;\n\n    if (C.intersects(t, e, n, i)) {\n      var s = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);\n      if (0 === s) r = !0;else {\n        var o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),\n            a = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y),\n            u = a / s,\n            l = o / s;\n        (0 > l || l > 1 || 0 > u || u > 1) && (r = !0);\n      }\n    } else r = !0;\n\n    return r ? T.min(he.distancePointLine(t, n, i), he.distancePointLine(e, n, i), he.distancePointLine(n, t, e), he.distancePointLine(i, t, e)) : 0;\n  }, he.isPointInRing = function (t, e) {\n    return he.locatePointInRing(t, e) !== L.EXTERIOR;\n  }, he.computeLength = function (t) {\n    var e = t.size();\n    if (1 >= e) return 0;\n    var n = 0,\n        i = new g();\n    t.getCoordinate(0, i);\n\n    for (var r = i.x, s = i.y, o = 1; e > o; o++) {\n      t.getCoordinate(o, i);\n      var a = i.x,\n          u = i.y,\n          l = a - r,\n          h = u - s;\n      n += Math.sqrt(l * l + h * h), r = a, s = u;\n    }\n\n    return n;\n  }, he.isCCW = function (t) {\n    var e = t.length - 1;\n    if (3 > e) throw new i(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\n    for (var n = t[0], r = 0, s = 1; e >= s; s++) {\n      var o = t[s];\n      o.y > n.y && (n = o, r = s);\n    }\n\n    var a = r;\n\n    do {\n      a -= 1, 0 > a && (a = e);\n    } while (t[a].equals2D(n) && a !== r);\n\n    var u = r;\n\n    do {\n      u = (u + 1) % e;\n    } while (t[u].equals2D(n) && u !== r);\n\n    var l = t[a],\n        h = t[u];\n    if (l.equals2D(n) || h.equals2D(n) || l.equals2D(h)) return !1;\n    var c = he.computeOrientation(l, n, h),\n        f = !1;\n    return f = 0 === c ? l.x > h.x : c > 0;\n  }, he.locatePointInRing = function (t, e) {\n    return le.locatePointInRing(t, e);\n  }, he.distancePointLinePerpendicular = function (t, e, n) {\n    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n        r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n    return Math.abs(r) * Math.sqrt(i);\n  }, he.computeOrientation = function (t, e, n) {\n    return he.orientationIndex(t, e, n);\n  }, he.distancePointLine = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === e.length) throw new i(\"Line array must contain at least one vertex\");\n\n      for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {\n        var s = he.distancePointLine(t, e[r], e[r + 1]);\n        n > s && (n = s);\n      }\n\n      return n;\n    }\n\n    if (3 === arguments.length) {\n      var o = arguments[0],\n          a = arguments[1],\n          u = arguments[2];\n      if (a.x === u.x && a.y === u.y) return o.distance(a);\n      var l = (u.x - a.x) * (u.x - a.x) + (u.y - a.y) * (u.y - a.y),\n          h = ((o.x - a.x) * (u.x - a.x) + (o.y - a.y) * (u.y - a.y)) / l;\n      if (0 >= h) return o.distance(a);\n      if (h >= 1) return o.distance(u);\n      var c = ((a.y - o.y) * (u.x - a.x) - (a.x - o.x) * (u.y - a.y)) / l;\n      return Math.abs(c) * Math.sqrt(l);\n    }\n  }, he.isOnLine = function (t, e) {\n    for (var n = new ae(), i = 1; i < e.length; i++) {\n      var r = e[i - 1],\n          s = e[i];\n      if (n.computeIntersection(t, r, s), n.hasIntersection()) return !0;\n    }\n\n    return !1;\n  }, he.CLOCKWISE = -1, he.RIGHT = he.CLOCKWISE, he.COUNTERCLOCKWISE = 1, he.LEFT = he.COUNTERCLOCKWISE, he.COLLINEAR = 0, he.STRAIGHT = he.COLLINEAR, e(ce.prototype, {\n    minX: function minX() {\n      return Math.min(this.p0.x, this.p1.x);\n    },\n    orientationIndex: function orientationIndex() {\n      if (arguments[0] instanceof ce) {\n        var t = arguments[0],\n            e = he.orientationIndex(this.p0, this.p1, t.p0),\n            n = he.orientationIndex(this.p0, this.p1, t.p1);\n        return e >= 0 && n >= 0 ? Math.max(e, n) : 0 >= e && 0 >= n ? Math.max(e, n) : 0;\n      }\n\n      if (arguments[0] instanceof g) {\n        var i = arguments[0];\n        return he.orientationIndex(this.p0, this.p1, i);\n      }\n    },\n    toGeometry: function toGeometry(t) {\n      return t.createLineString([this.p0, this.p1]);\n    },\n    isVertical: function isVertical() {\n      return this.p0.x === this.p1.x;\n    },\n    equals: function equals(t) {\n      if (!(t instanceof ce)) return !1;\n      var e = t;\n      return this.p0.equals(e.p0) && this.p1.equals(e.p1);\n    },\n    intersection: function intersection(t) {\n      var e = new ae();\n      return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;\n    },\n    project: function project() {\n      if (arguments[0] instanceof g) {\n        var t = arguments[0];\n        if (t.equals(this.p0) || t.equals(this.p1)) return new g(t);\n        var e = this.projectionFactor(t),\n            n = new g();\n        return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;\n      }\n\n      if (arguments[0] instanceof ce) {\n        var i = arguments[0],\n            r = this.projectionFactor(i.p0),\n            s = this.projectionFactor(i.p1);\n        if (r >= 1 && s >= 1) return null;\n        if (0 >= r && 0 >= s) return null;\n        var o = this.project(i.p0);\n        0 > r && (o = this.p0), r > 1 && (o = this.p1);\n        var a = this.project(i.p1);\n        return 0 > s && (a = this.p0), s > 1 && (a = this.p1), new ce(o, a);\n      }\n    },\n    normalize: function normalize() {\n      this.p1.compareTo(this.p0) < 0 && this.reverse();\n    },\n    angle: function angle() {\n      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n    },\n    getCoordinate: function getCoordinate(t) {\n      return 0 === t ? this.p0 : this.p1;\n    },\n    distancePerpendicular: function distancePerpendicular(t) {\n      return he.distancePointLinePerpendicular(t, this.p0, this.p1);\n    },\n    minY: function minY() {\n      return Math.min(this.p0.y, this.p1.y);\n    },\n    midPoint: function midPoint() {\n      return ce.midPoint(this.p0, this.p1);\n    },\n    projectionFactor: function projectionFactor(t) {\n      if (t.equals(this.p0)) return 0;\n      if (t.equals(this.p1)) return 1;\n      var e = this.p1.x - this.p0.x,\n          n = this.p1.y - this.p0.y,\n          i = e * e + n * n;\n      if (0 >= i) return r.NaN;\n      var s = ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;\n      return s;\n    },\n    closestPoints: function closestPoints(t) {\n      var e = this.intersection(t);\n      if (null !== e) return [e, e];\n      var n = new Array(2).fill(null),\n          i = r.MAX_VALUE,\n          s = null,\n          o = this.closestPoint(t.p0);\n      i = o.distance(t.p0), n[0] = o, n[1] = t.p0;\n      var a = this.closestPoint(t.p1);\n      s = a.distance(t.p1), i > s && (i = s, n[0] = a, n[1] = t.p1);\n      var u = t.closestPoint(this.p0);\n      s = u.distance(this.p0), i > s && (i = s, n[0] = this.p0, n[1] = u);\n      var l = t.closestPoint(this.p1);\n      return s = l.distance(this.p1), i > s && (i = s, n[0] = this.p1, n[1] = l), n;\n    },\n    closestPoint: function closestPoint(t) {\n      var e = this.projectionFactor(t);\n      if (e > 0 && 1 > e) return this.project(t);\n      var n = this.p0.distance(t),\n          i = this.p1.distance(t);\n      return i > n ? this.p0 : this.p1;\n    },\n    maxX: function maxX() {\n      return Math.max(this.p0.x, this.p1.x);\n    },\n    getLength: function getLength() {\n      return this.p0.distance(this.p1);\n    },\n    compareTo: function compareTo(t) {\n      var e = t,\n          n = this.p0.compareTo(e.p0);\n      return 0 !== n ? n : this.p1.compareTo(e.p1);\n    },\n    reverse: function reverse() {\n      var t = this.p0;\n      this.p0 = this.p1, this.p1 = t;\n    },\n    equalsTopo: function equalsTopo(t) {\n      return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);\n    },\n    lineIntersection: function lineIntersection(t) {\n      try {\n        var e = F.intersection(this.p0, this.p1, t.p0, t.p1);\n        return e;\n      } catch (t) {\n        if (!(t instanceof w)) throw t;\n      } finally {}\n\n      return null;\n    },\n    maxY: function maxY() {\n      return Math.max(this.p0.y, this.p1.y);\n    },\n    pointAlongOffset: function pointAlongOffset(t, e) {\n      var n = this.p0.x + t * (this.p1.x - this.p0.x),\n          i = this.p0.y + t * (this.p1.y - this.p0.y),\n          r = this.p1.x - this.p0.x,\n          s = this.p1.y - this.p0.y,\n          o = Math.sqrt(r * r + s * s),\n          a = 0,\n          u = 0;\n\n      if (0 !== e) {\n        if (0 >= o) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n        a = e * r / o, u = e * s / o;\n      }\n\n      var l = n - u,\n          h = i + a,\n          c = new g(l, h);\n      return c;\n    },\n    setCoordinates: function setCoordinates() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.setCoordinates(t.p0, t.p1);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;\n      }\n    },\n    segmentFraction: function segmentFraction(t) {\n      var e = this.projectionFactor(t);\n      return 0 > e ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1), e;\n    },\n    toString: function toString() {\n      return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n    },\n    isHorizontal: function isHorizontal() {\n      return this.p0.y === this.p1.y;\n    },\n    distance: function distance() {\n      if (arguments[0] instanceof ce) {\n        var t = arguments[0];\n        return he.distanceLineLine(this.p0, this.p1, t.p0, t.p1);\n      }\n\n      if (arguments[0] instanceof g) {\n        var e = arguments[0];\n        return he.distancePointLine(e, this.p0, this.p1);\n      }\n    },\n    pointAlong: function pointAlong(t) {\n      var e = new g();\n      return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;\n    },\n    hashCode: function hashCode() {\n      var t = java.lang.Double.doubleToLongBits(this.p0.x);\n      t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);\n      var e = Math.trunc(t) ^ Math.trunc(t >> 32),\n          n = java.lang.Double.doubleToLongBits(this.p1.x);\n      n ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y);\n      var i = Math.trunc(n) ^ Math.trunc(n >> 32);\n      return e ^ i;\n    },\n    interfaces_: function interfaces_() {\n      return [s, u];\n    },\n    getClass: function getClass() {\n      return ce;\n    }\n  }), ce.midPoint = function (t, e) {\n    return new g((t.x + e.x) / 2, (t.y + e.y) / 2);\n  }, ce.serialVersionUID = 0x2d2172135f411c00, e(fe.prototype, {\n    isIntersects: function isIntersects() {\n      return !this.isDisjoint();\n    },\n    isCovers: function isCovers() {\n      var t = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);\n      return t && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;\n    },\n    isCoveredBy: function isCoveredBy() {\n      var t = fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) || fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);\n      return t && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;\n    },\n    set: function set() {\n      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n        var n = Math.trunc(e / 3),\n            i = e % 3;\n        this.matrix[n][i] = lt.toDimensionValue(t.charAt(e));\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2];\n        this.matrix[r][s] = o;\n      }\n    },\n    isContains: function isContains() {\n      return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;\n    },\n    setAtLeast: function setAtLeast() {\n      if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n        var n = Math.trunc(e / 3),\n            i = e % 3;\n        this.setAtLeast(n, i, lt.toDimensionValue(t.charAt(e)));\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2];\n        this.matrix[r][s] < o && (this.matrix[r][s] = o);\n      }\n    },\n    setAtLeastIfValid: function setAtLeastIfValid(t, e, n) {\n      t >= 0 && e >= 0 && this.setAtLeast(t, e, n);\n    },\n    isWithin: function isWithin() {\n      return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE;\n    },\n    isTouches: function isTouches(t, e) {\n      return t > e ? this.isTouches(e, t) : t === lt.A && e === lt.A || t === lt.L && e === lt.L || t === lt.L && e === lt.A || t === lt.P && e === lt.A || t === lt.P && e === lt.L ? this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && (fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY]) || fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR]) || fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])) : !1;\n    },\n    isOverlaps: function isOverlaps(t, e) {\n      return t === lt.P && e === lt.P || t === lt.A && e === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t === lt.L && e === lt.L ? 1 === this.matrix[L.INTERIOR][L.INTERIOR] && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : !1;\n    },\n    isEquals: function isEquals(t, e) {\n      return t !== e ? !1 : fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && this.matrix[L.INTERIOR][L.EXTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.EXTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.EXTERIOR][L.BOUNDARY] === lt.FALSE;\n    },\n    toString: function toString() {\n      for (var t = new P(\"123456789\"), e = 0; 3 > e; e++) {\n        for (var n = 0; 3 > n; n++) {\n          t.setCharAt(3 * e + n, lt.toDimensionSymbol(this.matrix[e][n]));\n        }\n      }\n\n      return t.toString();\n    },\n    setAll: function setAll(t) {\n      for (var e = 0; 3 > e; e++) {\n        for (var n = 0; 3 > n; n++) {\n          this.matrix[e][n] = t;\n        }\n      }\n    },\n    get: function get(t, e) {\n      return this.matrix[t][e];\n    },\n    transpose: function transpose() {\n      var t = this.matrix[1][0];\n      return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this;\n    },\n    matches: function matches(t) {\n      if (9 !== t.length) throw new i(\"Should be length 9: \" + t);\n\n      for (var e = 0; 3 > e; e++) {\n        for (var n = 0; 3 > n; n++) {\n          if (!fe.matches(this.matrix[e][n], t.charAt(3 * e + n))) return !1;\n        }\n      }\n\n      return !0;\n    },\n    add: function add(t) {\n      for (var e = 0; 3 > e; e++) {\n        for (var n = 0; 3 > n; n++) {\n          this.setAtLeast(e, n, t.get(e, n));\n        }\n      }\n    },\n    isDisjoint: function isDisjoint() {\n      return this.matrix[L.INTERIOR][L.INTERIOR] === lt.FALSE && this.matrix[L.INTERIOR][L.BOUNDARY] === lt.FALSE && this.matrix[L.BOUNDARY][L.INTERIOR] === lt.FALSE && this.matrix[L.BOUNDARY][L.BOUNDARY] === lt.FALSE;\n    },\n    isCrosses: function isCrosses(t, e) {\n      return t === lt.P && e === lt.L || t === lt.P && e === lt.A || t === lt.L && e === lt.A ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]) : t === lt.L && e === lt.P || t === lt.A && e === lt.P || t === lt.A && e === lt.L ? fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR]) && fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]) : t === lt.L && e === lt.L ? 0 === this.matrix[L.INTERIOR][L.INTERIOR] : !1;\n    },\n    interfaces_: function interfaces_() {\n      return [o];\n    },\n    getClass: function getClass() {\n      return fe;\n    }\n  }), fe.matches = function () {\n    if (Number.isInteger(arguments[0]) && \"string\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      return e === lt.SYM_DONTCARE ? !0 : e === lt.SYM_TRUE && (t >= 0 || t === lt.TRUE) ? !0 : e === lt.SYM_FALSE && t === lt.FALSE ? !0 : e === lt.SYM_P && t === lt.P ? !0 : e === lt.SYM_L && t === lt.L ? !0 : e === lt.SYM_A && t === lt.A;\n    }\n\n    if (\"string\" == typeof arguments[0] && \"string\" == typeof arguments[1]) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = new fe(n);\n      return r.matches(i);\n    }\n  }, fe.isTrue = function (t) {\n    return t >= 0 || t === lt.TRUE;\n  };\n  var lo = Object.freeze({\n    Coordinate: g,\n    CoordinateList: N,\n    Envelope: C,\n    LineSegment: ce,\n    GeometryFactory: ie,\n    Geometry: B,\n    Point: Lt,\n    LineString: St,\n    LinearRing: bt,\n    Polygon: Tt,\n    GeometryCollection: ft,\n    MultiPoint: Pt,\n    MultiLineString: gt,\n    MultiPolygon: Ot,\n    Dimension: lt,\n    IntersectionMatrix: fe\n  });\n  e(ge.prototype, {\n    addPoint: function addPoint(t) {\n      this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y;\n    },\n    setBasePoint: function setBasePoint(t) {\n      null === this.areaBasePt && (this.areaBasePt = t);\n    },\n    addLineSegments: function addLineSegments(t) {\n      for (var e = 0, n = 0; n < t.length - 1; n++) {\n        var i = t[n].distance(t[n + 1]);\n\n        if (0 !== i) {\n          e += i;\n          var r = (t[n].x + t[n + 1].x) / 2;\n          this.lineCentSum.x += i * r;\n          var s = (t[n].y + t[n + 1].y) / 2;\n          this.lineCentSum.y += i * s;\n        }\n      }\n\n      this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0]);\n    },\n    addHole: function addHole(t) {\n      for (var e = he.isCCW(t), n = 0; n < t.length - 1; n++) {\n        this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);\n      }\n\n      this.addLineSegments(t);\n    },\n    getCentroid: function getCentroid() {\n      var t = new g();\n      if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;else {\n        if (!(this.ptCount > 0)) return null;\n        t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount;\n      }\n      return t;\n    },\n    addShell: function addShell(t) {\n      t.length > 0 && this.setBasePoint(t[0]);\n\n      for (var e = !he.isCCW(t), n = 0; n < t.length - 1; n++) {\n        this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);\n      }\n\n      this.addLineSegments(t);\n    },\n    addTriangle: function addTriangle(t, e, n, i) {\n      var r = i ? 1 : -1;\n      ge.centroid3(t, e, n, this.triangleCent3);\n      var s = ge.area2(t, e, n);\n      this.cg3.x += r * s * this.triangleCent3.x, this.cg3.y += r * s * this.triangleCent3.y, this.areasum2 += r * s;\n    },\n    add: function add() {\n      if (arguments[0] instanceof Tt) {\n        var t = arguments[0];\n        this.addShell(t.getExteriorRing().getCoordinates());\n\n        for (var e = 0; e < t.getNumInteriorRing(); e++) {\n          this.addHole(t.getInteriorRingN(e).getCoordinates());\n        }\n      } else if (arguments[0] instanceof B) {\n        var n = arguments[0];\n        if (n.isEmpty()) return null;\n        if (n instanceof Lt) this.addPoint(n.getCoordinate());else if (n instanceof St) this.addLineSegments(n.getCoordinates());else if (n instanceof Tt) {\n          var i = n;\n          this.add(i);\n        } else if (n instanceof ft) for (var r = n, e = 0; e < r.getNumGeometries(); e++) {\n          this.add(r.getGeometryN(e));\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ge;\n    }\n  }), ge.area2 = function (t, e, n) {\n    return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);\n  }, ge.centroid3 = function (t, e, n, i) {\n    return i.x = t.x + e.x + n.x, i.y = t.y + e.y + n.y, null;\n  }, ge.getCentroid = function (t) {\n    var e = new ge(t);\n    return e.getCentroid();\n  }, de.prototype = new Error(), de.prototype.name = \"EmptyStackException\", pe.prototype = new y(), pe.prototype.add = function (t) {\n    return this.array_.push(t), !0;\n  }, pe.prototype.get = function (t) {\n    if (0 > t || t >= this.size()) throw new IndexOutOfBoundsException();\n    return this.array_[t];\n  }, pe.prototype.push = function (t) {\n    return this.array_.push(t), t;\n  }, pe.prototype.pop = function (t) {\n    if (0 === this.array_.length) throw new de();\n    return this.array_.pop();\n  }, pe.prototype.peek = function () {\n    if (0 === this.array_.length) throw new de();\n    return this.array_[this.array_.length - 1];\n  }, pe.prototype.empty = function () {\n    return 0 === this.array_.length;\n  }, pe.prototype.isEmpty = function () {\n    return this.empty();\n  }, pe.prototype.search = function (t) {\n    return this.array_.indexOf(t);\n  }, pe.prototype.size = function () {\n    return this.array_.length;\n  }, pe.prototype.toArray = function () {\n    for (var t = [], e = 0, n = this.array_.length; n > e; e++) {\n      t.push(this.array_[e]);\n    }\n\n    return t;\n  }, e(ve.prototype, {\n    filter: function filter(t) {\n      this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t));\n    },\n    getCoordinates: function getCoordinates() {\n      var t = new Array(this.list.size()).fill(null);\n      return this.list.toArray(t);\n    },\n    interfaces_: function interfaces_() {\n      return [z];\n    },\n    getClass: function getClass() {\n      return ve;\n    }\n  }), ve.filterCoordinates = function (t) {\n    for (var e = new ve(), n = 0; n < t.length; n++) {\n      e.filter(t[n]);\n    }\n\n    return e.getCoordinates();\n  }, e(me.prototype, {\n    preSort: function preSort(t) {\n      for (var e = null, n = 1; n < t.length; n++) {\n        (t[n].y < t[0].y || t[n].y === t[0].y && t[n].x < t[0].x) && (e = t[0], t[0] = t[n], t[n] = e);\n      }\n\n      return ut.sort(t, 1, t.length, new ye(t[0])), t;\n    },\n    computeOctRing: function computeOctRing(t) {\n      var e = this.computeOctPts(t),\n          n = new N();\n      return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray());\n    },\n    lineOrPolygon: function lineOrPolygon(t) {\n      if (t = this.cleanRing(t), 3 === t.length) return this.geomFactory.createLineString([t[0], t[1]]);\n      var e = this.geomFactory.createLinearRing(t);\n      return this.geomFactory.createPolygon(e, null);\n    },\n    cleanRing: function cleanRing(t) {\n      f.equals(t[0], t[t.length - 1]);\n\n      for (var e = new I(), n = null, i = 0; i <= t.length - 2; i++) {\n        var r = t[i],\n            s = t[i + 1];\n        r.equals(s) || null !== n && this.isBetween(n, r, s) || (e.add(r), n = r);\n      }\n\n      e.add(t[t.length - 1]);\n      var o = new Array(e.size()).fill(null);\n      return e.toArray(o);\n    },\n    isBetween: function isBetween(t, e, n) {\n      if (0 !== he.computeOrientation(t, e, n)) return !1;\n\n      if (t.x !== n.x) {\n        if (t.x <= e.x && e.x <= n.x) return !0;\n        if (n.x <= e.x && e.x <= t.x) return !0;\n      }\n\n      if (t.y !== n.y) {\n        if (t.y <= e.y && e.y <= n.y) return !0;\n        if (n.y <= e.y && e.y <= t.y) return !0;\n      }\n\n      return !1;\n    },\n    reduce: function reduce(t) {\n      var e = this.computeOctRing(t);\n      if (null === e) return t;\n\n      for (var n = new at(), i = 0; i < e.length; i++) {\n        n.add(e[i]);\n      }\n\n      for (var i = 0; i < t.length; i++) {\n        he.isPointInRing(t[i], e) || n.add(t[i]);\n      }\n\n      var r = H.toCoordinateArray(n);\n      return r.length < 3 ? this.padArray3(r) : r;\n    },\n    getConvexHull: function getConvexHull() {\n      if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);\n      if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);\n      if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);\n      var t = this.inputPts;\n      this.inputPts.length > 50 && (t = this.reduce(this.inputPts));\n      var e = this.preSort(t),\n          n = this.grahamScan(e),\n          i = this.toCoordinateArray(n);\n      return this.lineOrPolygon(i);\n    },\n    padArray3: function padArray3(t) {\n      for (var e = new Array(3).fill(null), n = 0; n < e.length; n++) {\n        n < t.length ? e[n] = t[n] : e[n] = t[0];\n      }\n\n      return e;\n    },\n    computeOctPts: function computeOctPts(t) {\n      for (var e = new Array(8).fill(null), n = 0; n < e.length; n++) {\n        e[n] = t[0];\n      }\n\n      for (var i = 1; i < t.length; i++) {\n        t[i].x < e[0].x && (e[0] = t[i]), t[i].x - t[i].y < e[1].x - e[1].y && (e[1] = t[i]), t[i].y > e[2].y && (e[2] = t[i]), t[i].x + t[i].y > e[3].x + e[3].y && (e[3] = t[i]), t[i].x > e[4].x && (e[4] = t[i]), t[i].x - t[i].y > e[5].x - e[5].y && (e[5] = t[i]), t[i].y < e[6].y && (e[6] = t[i]), t[i].x + t[i].y < e[7].x + e[7].y && (e[7] = t[i]);\n      }\n\n      return e;\n    },\n    toCoordinateArray: function toCoordinateArray(t) {\n      for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {\n        var i = t.get(n);\n        e[n] = i;\n      }\n\n      return e;\n    },\n    grahamScan: function grahamScan(t) {\n      var e = null,\n          n = new pe();\n      e = n.push(t[0]), e = n.push(t[1]), e = n.push(t[2]);\n\n      for (var i = 3; i < t.length; i++) {\n        for (e = n.pop(); !n.empty() && he.computeOrientation(n.peek(), e, t[i]) > 0;) {\n          e = n.pop();\n        }\n\n        e = n.push(e), e = n.push(t[i]);\n      }\n\n      return e = n.push(t[0]), n;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return me;\n    }\n  }), me.extractCoordinates = function (t) {\n    var e = new ve();\n    return t.apply(e), e.getCoordinates();\n  }, e(ye.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e;\n      return ye.polarCompare(this.origin, n, i);\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return ye;\n    }\n  }), ye.polarCompare = function (t, e, n) {\n    var i = e.x - t.x,\n        r = e.y - t.y,\n        s = n.x - t.x,\n        o = n.y - t.y,\n        a = he.computeOrientation(t, e, n);\n    if (a === he.COUNTERCLOCKWISE) return 1;\n    if (a === he.CLOCKWISE) return -1;\n    var u = i * i + r * r,\n        l = s * s + o * o;\n    return l > u ? -1 : u > l ? 1 : 0;\n  }, me.RadialComparator = ye, e(xe.prototype, {\n    transformPoint: function transformPoint(t, e) {\n      return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));\n    },\n    transformPolygon: function transformPolygon(t, e) {\n      var n = !0,\n          i = this.transformLinearRing(t.getExteriorRing(), t);\n      null !== i && i instanceof bt && !i.isEmpty() || (n = !1);\n\n      for (var r = new I(), s = 0; s < t.getNumInteriorRing(); s++) {\n        var o = this.transformLinearRing(t.getInteriorRingN(s), t);\n        null === o || o.isEmpty() || (o instanceof bt || (n = !1), r.add(o));\n      }\n\n      if (n) return this.factory.createPolygon(i, r.toArray([]));\n      var a = new I();\n      return null !== i && a.add(i), a.addAll(r), this.factory.buildGeometry(a);\n    },\n    createCoordinateSequence: function createCoordinateSequence(t) {\n      return this.factory.getCoordinateSequenceFactory().create(t);\n    },\n    getInputGeometry: function getInputGeometry() {\n      return this.inputGeom;\n    },\n    transformMultiLineString: function transformMultiLineString(t, e) {\n      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {\n        var r = this.transformLineString(t.getGeometryN(i), t);\n        null !== r && (r.isEmpty() || n.add(r));\n      }\n\n      return this.factory.buildGeometry(n);\n    },\n    transformCoordinates: function transformCoordinates(t, e) {\n      return this.copy(t);\n    },\n    transformLineString: function transformLineString(t, e) {\n      return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));\n    },\n    transformMultiPoint: function transformMultiPoint(t, e) {\n      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {\n        var r = this.transformPoint(t.getGeometryN(i), t);\n        null !== r && (r.isEmpty() || n.add(r));\n      }\n\n      return this.factory.buildGeometry(n);\n    },\n    transformMultiPolygon: function transformMultiPolygon(t, e) {\n      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {\n        var r = this.transformPolygon(t.getGeometryN(i), t);\n        null !== r && (r.isEmpty() || n.add(r));\n      }\n\n      return this.factory.buildGeometry(n);\n    },\n    copy: function copy(t) {\n      return t.copy();\n    },\n    transformGeometryCollection: function transformGeometryCollection(t, e) {\n      for (var n = new I(), i = 0; i < t.getNumGeometries(); i++) {\n        var r = this.transform(t.getGeometryN(i));\n        null !== r && (this.pruneEmptyGeometry && r.isEmpty() || n.add(r));\n      }\n\n      return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(ie.toGeometryArray(n)) : this.factory.buildGeometry(n);\n    },\n    transform: function transform(t) {\n      if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof Lt) return this.transformPoint(t, null);\n      if (t instanceof Pt) return this.transformMultiPoint(t, null);\n      if (t instanceof bt) return this.transformLinearRing(t, null);\n      if (t instanceof St) return this.transformLineString(t, null);\n      if (t instanceof gt) return this.transformMultiLineString(t, null);\n      if (t instanceof Tt) return this.transformPolygon(t, null);\n      if (t instanceof Ot) return this.transformMultiPolygon(t, null);\n      if (t instanceof ft) return this.transformGeometryCollection(t, null);\n      throw new i(\"Unknown Geometry subtype: \" + t.getClass().getName());\n    },\n    transformLinearRing: function transformLinearRing(t, e) {\n      var n = this.transformCoordinates(t.getCoordinateSequence(), t);\n      if (null === n) return this.factory.createLinearRing(null);\n      var i = n.size();\n      return i > 0 && 4 > i && !this.preserveType ? this.factory.createLineString(n) : this.factory.createLinearRing(n);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return xe;\n    }\n  }), e(Ee.prototype, {\n    snapVertices: function snapVertices(t, e) {\n      for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; n > i; i++) {\n        var r = t.get(i),\n            s = this.findSnapForVertex(r, e);\n        null !== s && (t.set(i, new g(s)), 0 === i && this._isClosed && t.set(t.size() - 1, new g(s)));\n      }\n    },\n    findSnapForVertex: function findSnapForVertex(t, e) {\n      for (var n = 0; n < e.length; n++) {\n        if (t.equals2D(e[n])) return null;\n        if (t.distance(e[n]) < this.snapTolerance) return e[n];\n      }\n\n      return null;\n    },\n    snapTo: function snapTo(t) {\n      var e = new N(this.srcPts);\n      this.snapVertices(e, t), this.snapSegments(e, t);\n      var n = e.toCoordinateArray();\n      return n;\n    },\n    snapSegments: function snapSegments(t, e) {\n      if (0 === e.length) return null;\n      var n = e.length;\n      e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);\n\n      for (var i = 0; n > i; i++) {\n        var r = e[i],\n            s = this.findSegmentIndexToSnap(r, t);\n        s >= 0 && t.add(s + 1, new g(r), !1);\n      }\n    },\n    findSegmentIndexToSnap: function findSegmentIndexToSnap(t, e) {\n      for (var n = r.MAX_VALUE, i = -1, s = 0; s < e.size() - 1; s++) {\n        if (this.seg.p0 = e.get(s), this.seg.p1 = e.get(s + 1), this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) {\n          if (this.allowSnappingToSourceVertices) continue;\n          return -1;\n        }\n\n        var o = this.seg.distance(t);\n        o < this.snapTolerance && n > o && (n = o, i = s);\n      }\n\n      return i;\n    },\n    setAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(t) {\n      this.allowSnappingToSourceVertices = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ee;\n    }\n  }), Ee.isClosed = function (t) {\n    return t.length <= 1 ? !1 : t[0].equals2D(t[t.length - 1]);\n  }, e(Ie.prototype, {\n    snapTo: function snapTo(t, e) {\n      var n = this.extractTargetCoordinates(t),\n          i = new Ne(e, n);\n      return i.transform(this.srcGeom);\n    },\n    snapToSelf: function snapToSelf(t, e) {\n      var n = this.extractTargetCoordinates(this.srcGeom),\n          i = new Ne(t, n, !0),\n          r = i.transform(this.srcGeom),\n          s = r;\n      return e && R(s, Rt) && (s = r.buffer(0)), s;\n    },\n    computeSnapTolerance: function computeSnapTolerance(t) {\n      var e = this.computeMinimumSegmentLength(t),\n          n = e / 10;\n      return n;\n    },\n    extractTargetCoordinates: function extractTargetCoordinates(t) {\n      for (var e = new at(), n = t.getCoordinates(), i = 0; i < n.length; i++) {\n        e.add(n[i]);\n      }\n\n      return e.toArray(new Array(0).fill(null));\n    },\n    computeMinimumSegmentLength: function computeMinimumSegmentLength(t) {\n      for (var e = r.MAX_VALUE, n = 0; n < t.length - 1; n++) {\n        var i = t[n].distance(t[n + 1]);\n        e > i && (e = i);\n      }\n\n      return e;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ie;\n    }\n  }), Ie.snap = function (t, e, n) {\n    var i = new Array(2).fill(null),\n        r = new Ie(t);\n    i[0] = r.snapTo(e, n);\n    var s = new Ie(e);\n    return i[1] = s.snapTo(i[0], n), i;\n  }, Ie.computeOverlaySnapTolerance = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = Ie.computeSizeBasedSnapTolerance(t),\n          n = t.getPrecisionModel();\n\n      if (n.getType() === ee.FIXED) {\n        var i = 1 / n.getScale() * 2 / 1.415;\n        i > e && (e = i);\n      }\n\n      return e;\n    }\n\n    if (2 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1];\n      return Math.min(Ie.computeOverlaySnapTolerance(r), Ie.computeOverlaySnapTolerance(s));\n    }\n  }, Ie.computeSizeBasedSnapTolerance = function (t) {\n    var e = t.getEnvelopeInternal(),\n        n = Math.min(e.getHeight(), e.getWidth()),\n        i = n * Ie.SNAP_PRECISION_FACTOR;\n    return i;\n  }, Ie.snapToSelf = function (t, e, n) {\n    var i = new Ie(t);\n    return i.snapToSelf(e, n);\n  }, Ie.SNAP_PRECISION_FACTOR = 1e-9, h(Ne, xe), e(Ne.prototype, {\n    snapLine: function snapLine(t, e) {\n      var n = new Ee(t, this.snapTolerance);\n      return n.setAllowSnappingToSourceVertices(this.isSelfSnap), n.snapTo(e);\n    },\n    transformCoordinates: function transformCoordinates(t, e) {\n      var n = t.toCoordinateArray(),\n          i = this.snapLine(n, this.snapPts);\n      return this.factory.getCoordinateSequenceFactory().create(i);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ne;\n    }\n  }), e(Ce.prototype, {\n    getCommon: function getCommon() {\n      return r.longBitsToDouble(this.commonBits);\n    },\n    add: function add(t) {\n      var e = r.doubleToLongBits(t);\n      if (this.isFirst) return this.commonBits = e, this.commonSignExp = Ce.signExpBits(this.commonBits), this.isFirst = !1, null;\n      var n = Ce.signExpBits(e);\n      return n !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = Ce.numCommonMostSigMantissaBits(this.commonBits, e), void (this.commonBits = Ce.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))));\n    },\n    toString: function toString() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = r.longBitsToDouble(t),\n            n = Long.toBinaryString(t),\n            i = \"0000000000000000000000000000000000000000000000000000000000000000\" + n,\n            s = i.substring(i.length - 64),\n            o = s.substring(0, 1) + \"  \" + s.substring(1, 12) + \"(exp) \" + s.substring(12) + \" [ \" + e + \" ]\";\n        return o;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ce;\n    }\n  }), Ce.getBit = function (t, e) {\n    var n = 1 << e;\n    return 0 !== (t & n) ? 1 : 0;\n  }, Ce.signExpBits = function (t) {\n    return t >> 52;\n  }, Ce.zeroLowerBits = function (t, e) {\n    var n = (1 << e) - 1,\n        i = ~n,\n        r = t & i;\n    return r;\n  }, Ce.numCommonMostSigMantissaBits = function (t, e) {\n    for (var n = 0, i = 52; i >= 0; i--) {\n      if (Ce.getBit(t, i) !== Ce.getBit(e, i)) return n;\n      n++;\n    }\n\n    return 52;\n  }, e(Se.prototype, {\n    addCommonBits: function addCommonBits(t) {\n      var e = new Le(this.commonCoord);\n      t.apply(e), t.geometryChanged();\n    },\n    removeCommonBits: function removeCommonBits(t) {\n      if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return t;\n      var e = new g(this.commonCoord);\n      e.x = -e.x, e.y = -e.y;\n      var n = new Le(e);\n      return t.apply(n), t.geometryChanged(), t;\n    },\n    getCommonCoordinate: function getCommonCoordinate() {\n      return this.commonCoord;\n    },\n    add: function add(t) {\n      t.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Se;\n    }\n  }), e(we.prototype, {\n    filter: function filter(t) {\n      this.commonBitsX.add(t.x), this.commonBitsY.add(t.y);\n    },\n    getCommonCoordinate: function getCommonCoordinate() {\n      return new g(this.commonBitsX.getCommon(), this.commonBitsY.getCommon());\n    },\n    interfaces_: function interfaces_() {\n      return [z];\n    },\n    getClass: function getClass() {\n      return we;\n    }\n  }), e(Le.prototype, {\n    filter: function filter(t, e) {\n      var n = t.getOrdinate(e, 0) + this.trans.x,\n          i = t.getOrdinate(e, 1) + this.trans.y;\n      t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);\n    },\n    isDone: function isDone() {\n      return !1;\n    },\n    isGeometryChanged: function isGeometryChanged() {\n      return !0;\n    },\n    interfaces_: function interfaces_() {\n      return [ct];\n    },\n    getClass: function getClass() {\n      return Le;\n    }\n  }), Se.CommonCoordinateFilter = we, Se.Translater = Le, e(Re.prototype, {\n    next: function next() {\n      if (this.atStart) return this.atStart = !1, Re.isAtomic(this.parent) && this.index++, this.parent;\n\n      if (null !== this.subcollectionIterator) {\n        if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();\n        this.subcollectionIterator = null;\n      }\n\n      if (this.index >= this.max) throw new x();\n      var t = this.parent.getGeometryN(this.index++);\n      return t instanceof ft ? (this.subcollectionIterator = new Re(t), this.subcollectionIterator.next()) : t;\n    },\n    remove: function remove() {\n      throw new UnsupportedOperationException(this.getClass().getName());\n    },\n    hasNext: function hasNext() {\n      if (this.atStart) return !0;\n\n      if (null !== this.subcollectionIterator) {\n        if (this.subcollectionIterator.hasNext()) return !0;\n        this.subcollectionIterator = null;\n      }\n\n      return !(this.index >= this.max);\n    },\n    interfaces_: function interfaces_() {\n      return [p];\n    },\n    getClass: function getClass() {\n      return Re;\n    }\n  }), Re.isAtomic = function (t) {\n    return !(t instanceof ft);\n  }, e(Te.prototype, {\n    locateInternal: function locateInternal() {\n      if (arguments[0] instanceof g && arguments[1] instanceof Tt) {\n        var t = arguments[0],\n            e = arguments[1];\n        if (e.isEmpty()) return L.EXTERIOR;\n        var n = e.getExteriorRing(),\n            i = this.locateInPolygonRing(t, n);\n        if (i === L.EXTERIOR) return L.EXTERIOR;\n        if (i === L.BOUNDARY) return L.BOUNDARY;\n\n        for (var r = 0; r < e.getNumInteriorRing(); r++) {\n          var s = e.getInteriorRingN(r),\n              o = this.locateInPolygonRing(t, s);\n          if (o === L.INTERIOR) return L.EXTERIOR;\n          if (o === L.BOUNDARY) return L.BOUNDARY;\n        }\n\n        return L.INTERIOR;\n      }\n\n      if (arguments[0] instanceof g && arguments[1] instanceof St) {\n        var a = arguments[0],\n            u = arguments[1];\n        if (!u.getEnvelopeInternal().intersects(a)) return L.EXTERIOR;\n        var l = u.getCoordinates();\n        return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? he.isOnLine(a, l) ? L.INTERIOR : L.EXTERIOR : L.BOUNDARY;\n      }\n\n      if (arguments[0] instanceof g && arguments[1] instanceof Lt) {\n        var h = arguments[0],\n            c = arguments[1],\n            f = c.getCoordinate();\n        return f.equals2D(h) ? L.INTERIOR : L.EXTERIOR;\n      }\n    },\n    locateInPolygonRing: function locateInPolygonRing(t, e) {\n      return e.getEnvelopeInternal().intersects(t) ? he.locatePointInRing(t, e.getCoordinates()) : L.EXTERIOR;\n    },\n    intersects: function intersects(t, e) {\n      return this.locate(t, e) !== L.EXTERIOR;\n    },\n    updateLocationInfo: function updateLocationInfo(t) {\n      t === L.INTERIOR && (this.isIn = !0), t === L.BOUNDARY && this.numBoundaries++;\n    },\n    computeLocation: function computeLocation(t, e) {\n      if (e instanceof Lt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof St) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof Tt) this.updateLocationInfo(this.locateInternal(t, e));else if (e instanceof gt) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {\n        var r = n.getGeometryN(i);\n        this.updateLocationInfo(this.locateInternal(t, r));\n      } else if (e instanceof Ot) for (var s = e, i = 0; i < s.getNumGeometries(); i++) {\n        var o = s.getGeometryN(i);\n        this.updateLocationInfo(this.locateInternal(t, o));\n      } else if (e instanceof ft) for (var a = new Re(e); a.hasNext();) {\n        var u = a.next();\n        u !== e && this.computeLocation(t, u);\n      }\n    },\n    locate: function locate(t, e) {\n      return e.isEmpty() ? L.EXTERIOR : e instanceof St ? this.locateInternal(t, e) : e instanceof Tt ? this.locateInternal(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? L.BOUNDARY : this.numBoundaries > 0 || this.isIn ? L.INTERIOR : L.EXTERIOR);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Te;\n    }\n  }), e(Pe.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Pe;\n    }\n  }), Pe.octant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === t && 0 === e) throw new i(\"Cannot compute the octant for point ( \" + t + \", \" + e + \" )\");\n      var n = Math.abs(t),\n          r = Math.abs(e);\n      return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5;\n    }\n\n    if (arguments[0] instanceof g && arguments[1] instanceof g) {\n      var s = arguments[0],\n          o = arguments[1],\n          a = o.x - s.x,\n          u = o.y - s.y;\n      if (0 === a && 0 === u) throw new i(\"Cannot compute the octant for two identical points \" + s);\n      return Pe.octant(a, u);\n    }\n  }, e(be.prototype, {\n    getCoordinates: function getCoordinates() {},\n    size: function size() {},\n    getCoordinate: function getCoordinate(t) {},\n    isClosed: function isClosed() {},\n    setData: function setData(t) {},\n    getData: function getData() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return be;\n    }\n  }), e(Oe.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    size: function size() {\n      return this.pts.length;\n    },\n    getCoordinate: function getCoordinate(t) {\n      return this.pts[t];\n    },\n    isClosed: function isClosed() {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    },\n    getSegmentOctant: function getSegmentOctant(t) {\n      return t === this.pts.length - 1 ? -1 : Pe.octant(this.getCoordinate(t), this.getCoordinate(t + 1));\n    },\n    setData: function setData(t) {\n      this.data = t;\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    toString: function toString() {\n      return se.toLineString(new Gt(this.pts));\n    },\n    interfaces_: function interfaces_() {\n      return [be];\n    },\n    getClass: function getClass() {\n      return Oe;\n    }\n  }), e(_e.prototype, {\n    getBounds: function getBounds() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return _e;\n    }\n  }), e(Me.prototype, {\n    getItem: function getItem() {\n      return this.item;\n    },\n    getBounds: function getBounds() {\n      return this.bounds;\n    },\n    interfaces_: function interfaces_() {\n      return [_e, u];\n    },\n    getClass: function getClass() {\n      return Me;\n    }\n  }), e(De.prototype, {\n    poll: function poll() {\n      if (this.isEmpty()) return null;\n      var t = this.items.get(1);\n      return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t;\n    },\n    size: function size() {\n      return this._size;\n    },\n    reorder: function reorder(t) {\n      for (var e = null, n = this.items.get(t); 2 * t <= this._size && (e = 2 * t, e !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++, this.items.get(e).compareTo(n) < 0); t = e) {\n        this.items.set(t, this.items.get(e));\n      }\n\n      this.items.set(t, n);\n    },\n    clear: function clear() {\n      this._size = 0, this.items.clear();\n    },\n    isEmpty: function isEmpty() {\n      return 0 === this._size;\n    },\n    add: function add(t) {\n      this.items.add(null), this._size += 1;\n      var e = this._size;\n\n      for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2) {\n        this.items.set(e, this.items.get(Math.trunc(e / 2)));\n      }\n\n      this.items.set(e, t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return De;\n    }\n  }), e(Ae.prototype, {\n    visitItem: function visitItem(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ae;\n    }\n  }), e(Fe.prototype, {\n    insert: function insert(t, e) {},\n    remove: function remove(t, e) {},\n    query: function query() {\n      if (1 === arguments.length) {\n        arguments[0];\n      } else if (2 === arguments.length) {\n        arguments[0], arguments[1];\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Fe;\n    }\n  }), e(Ge.prototype, {\n    getLevel: function getLevel() {\n      return this.level;\n    },\n    size: function size() {\n      return this.childBoundables.size();\n    },\n    getChildBoundables: function getChildBoundables() {\n      return this.childBoundables;\n    },\n    addChildBoundable: function addChildBoundable(t) {\n      f.isTrue(null === this.bounds), this.childBoundables.add(t);\n    },\n    isEmpty: function isEmpty() {\n      return this.childBoundables.isEmpty();\n    },\n    getBounds: function getBounds() {\n      return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds;\n    },\n    interfaces_: function interfaces_() {\n      return [_e, u];\n    },\n    getClass: function getClass() {\n      return Ge;\n    }\n  }), Ge.serialVersionUID = 0x5a1e55ec41369800;\n  var ho = {\n    reverseOrder: function reverseOrder() {\n      return {\n        compare: function compare(t, e) {\n          return e.compareTo(t);\n        }\n      };\n    },\n    min: function min(t) {\n      return ho.sort(t), t.get(0);\n    },\n    sort: function sort(t, e) {\n      var n = t.toArray();\n      e ? ut.sort(n, e) : ut.sort(n);\n\n      for (var i = t.iterator(), r = 0, s = n.length; s > r; r++) {\n        i.next(), i.set(n[r]);\n      }\n    },\n    singletonList: function singletonList(t) {\n      var e = new I();\n      return e.add(t), e;\n    }\n  };\n  e(qe.prototype, {\n    expandToQueue: function expandToQueue(t, e) {\n      var n = qe.isComposite(this.boundable1),\n          r = qe.isComposite(this.boundable2);\n      if (n && r) return qe.area(this.boundable1) > qe.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e), null) : (this.expand(this.boundable2, this.boundable1, t, e), null);\n      if (n) return this.expand(this.boundable1, this.boundable2, t, e), null;\n      if (r) return this.expand(this.boundable2, this.boundable1, t, e), null;\n      throw new i(\"neither boundable is composite\");\n    },\n    isLeaves: function isLeaves() {\n      return !(qe.isComposite(this.boundable1) || qe.isComposite(this.boundable2));\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;\n    },\n    expand: function expand(t, e, n, i) {\n      for (var r = t.getChildBoundables(), s = r.iterator(); s.hasNext();) {\n        var o = s.next(),\n            a = new qe(o, e, this.itemDistance);\n        a.getDistance() < i && n.add(a);\n      }\n    },\n    getBoundable: function getBoundable(t) {\n      return 0 === t ? this.boundable1 : this.boundable2;\n    },\n    getDistance: function getDistance() {\n      return this._distance;\n    },\n    distance: function distance() {\n      return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds());\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return qe;\n    }\n  }), qe.area = function (t) {\n    return t.getBounds().getArea();\n  }, qe.isComposite = function (t) {\n    return t instanceof Ge;\n  }, e(Be.prototype, {\n    getNodeCapacity: function getNodeCapacity() {\n      return this.nodeCapacity;\n    },\n    lastNode: function lastNode(t) {\n      return t.get(t.size() - 1);\n    },\n    size: function t() {\n      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));\n\n      if (1 === arguments.length) {\n        for (var e = arguments[0], t = 0, n = e.getChildBoundables().iterator(); n.hasNext();) {\n          var i = n.next();\n          i instanceof Ge ? t += this.size(i) : i instanceof Me && (t += 1);\n        }\n\n        return t;\n      }\n    },\n    removeItem: function removeItem(t, e) {\n      for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {\n        var r = i.next();\n        r instanceof Me && r.getItem() === e && (n = r);\n      }\n\n      return null !== n ? (t.getChildBoundables().remove(n), !0) : !1;\n    },\n    itemsTree: function itemsTree() {\n      if (0 === arguments.length) {\n        this.build();\n        var t = this.itemsTree(this.root);\n        return null === t ? new I() : t;\n      }\n\n      if (1 === arguments.length) {\n        for (var e = arguments[0], n = new I(), i = e.getChildBoundables().iterator(); i.hasNext();) {\n          var r = i.next();\n\n          if (r instanceof Ge) {\n            var s = this.itemsTree(r);\n            null !== s && n.add(s);\n          } else r instanceof Me ? n.add(r.getItem()) : f.shouldNeverReachHere();\n        }\n\n        return n.size() <= 0 ? null : n;\n      }\n    },\n    insert: function insert(t, e) {\n      f.isTrue(!this.built, \"Cannot insert items into an STR packed R-tree after it has been built.\"), this.itemBoundables.add(new Me(t, e));\n    },\n    boundablesAtLevel: function boundablesAtLevel() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = new I();\n        return this.boundablesAtLevel(t, this.root, e), e;\n      }\n\n      if (3 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2];\n        if (f.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;\n\n        for (var s = i.getChildBoundables().iterator(); s.hasNext();) {\n          var o = s.next();\n          o instanceof Ge ? this.boundablesAtLevel(n, o, r) : (f.isTrue(o instanceof Me), -1 === n && r.add(o));\n        }\n\n        return null;\n      }\n    },\n    query: function query() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.build();\n        var e = new I();\n        return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e), e);\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        if (this.build(), this.isEmpty()) return null;\n        this.getIntersectsOp().intersects(this.root.getBounds(), n) && this.query(n, this.root, i);\n      } else if (3 === arguments.length) if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge) for (var r = arguments[0], s = arguments[1], o = arguments[2], a = s.getChildBoundables(), u = 0; u < a.size(); u++) {\n        var l = a.get(u);\n        this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Ge ? this.query(r, l, o) : l instanceof Me ? o.visitItem(l.getItem()) : f.shouldNeverReachHere());\n      } else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge) for (var h = arguments[0], c = arguments[1], g = arguments[2], a = c.getChildBoundables(), u = 0; u < a.size(); u++) {\n        var l = a.get(u);\n        this.getIntersectsOp().intersects(l.getBounds(), h) && (l instanceof Ge ? this.query(h, l, g) : l instanceof Me ? g.add(l.getItem()) : f.shouldNeverReachHere());\n      }\n    },\n    build: function build() {\n      return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, void (this.built = !0));\n    },\n    getRoot: function getRoot() {\n      return this.build(), this.root;\n    },\n    remove: function remove() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.build(), this.getIntersectsOp().intersects(this.root.getBounds(), t) ? this.remove(t, this.root, e) : !1;\n      }\n\n      if (3 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2],\n            s = this.removeItem(i, r);\n        if (s) return !0;\n\n        for (var o = null, a = i.getChildBoundables().iterator(); a.hasNext();) {\n          var u = a.next();\n\n          if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Ge && (s = this.remove(n, u, r))) {\n            o = u;\n            break;\n          }\n        }\n\n        return null !== o && o.getChildBoundables().isEmpty() && i.getChildBoundables().remove(o), s;\n      }\n    },\n    createHigherLevels: function createHigherLevels(t, e) {\n      f.isTrue(!t.isEmpty());\n      var n = this.createParentBoundables(t, e + 1);\n      return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);\n    },\n    depth: function depth() {\n      if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));\n\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext();) {\n          var i = n.next();\n\n          if (i instanceof Ge) {\n            var r = this.depth(i);\n            r > e && (e = r);\n          }\n        }\n\n        return e + 1;\n      }\n    },\n    createParentBoundables: function createParentBoundables(t, e) {\n      f.isTrue(!t.isEmpty());\n      var n = new I();\n      n.add(this.createNode(e));\n      var i = new I(t);\n      ho.sort(i, this.getComparator());\n\n      for (var r = i.iterator(); r.hasNext();) {\n        var s = r.next();\n        this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(s);\n      }\n\n      return n;\n    },\n    isEmpty: function isEmpty() {\n      return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty();\n    },\n    interfaces_: function interfaces_() {\n      return [u];\n    },\n    getClass: function getClass() {\n      return Be;\n    }\n  }), Be.compareDoubles = function (t, e) {\n    return t > e ? 1 : e > t ? -1 : 0;\n  }, Be.IntersectsOp = ze, Be.serialVersionUID = -0x35ef64c82d4c5400, Be.DEFAULT_NODE_CAPACITY = 10, e(Ve.prototype, {\n    distance: function distance(t, e) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ve;\n    }\n  }), h(ke, Be), e(ke.prototype, {\n    createParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(t, e) {\n      f.isTrue(t.length > 0);\n\n      for (var n = new I(), i = 0; i < t.length; i++) {\n        n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));\n      }\n\n      return n;\n    },\n    createNode: function createNode(t) {\n      return new Ye(t);\n    },\n    size: function size() {\n      return 0 === arguments.length ? Be.prototype.size.call(this) : Be.prototype.size.apply(this, arguments);\n    },\n    insert: function insert() {\n      if (2 !== arguments.length) return Be.prototype.insert.apply(this, arguments);\n      var t = arguments[0],\n          e = arguments[1];\n      return t.isNull() ? null : void Be.prototype.insert.call(this, t, e);\n    },\n    getIntersectsOp: function getIntersectsOp() {\n      return ke.intersectsOp;\n    },\n    verticalSlices: function verticalSlices(t, e) {\n      for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), s = 0; e > s; s++) {\n        i[s] = new I();\n\n        for (var o = 0; r.hasNext() && n > o;) {\n          var a = r.next();\n          i[s].add(a), o++;\n        }\n      }\n\n      return i;\n    },\n    query: function query() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return Be.prototype.query.call(this, t);\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        Be.prototype.query.call(this, e, n);\n      } else if (3 === arguments.length) if (R(arguments[2], Ae) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {\n        var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n        Be.prototype.query.call(this, i, r, s);\n      } else if (R(arguments[2], y) && arguments[0] instanceof Object && arguments[1] instanceof Ge) {\n        var o = arguments[0],\n            a = arguments[1],\n            u = arguments[2];\n        Be.prototype.query.call(this, o, a, u);\n      }\n    },\n    getComparator: function getComparator() {\n      return ke.yComparator;\n    },\n    createParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(t, e) {\n      return Be.prototype.createParentBoundables.call(this, t, e);\n    },\n    remove: function remove() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return Be.prototype.remove.call(this, t, e);\n      }\n\n      return Be.prototype.remove.apply(this, arguments);\n    },\n    depth: function depth() {\n      return 0 === arguments.length ? Be.prototype.depth.call(this) : Be.prototype.depth.apply(this, arguments);\n    },\n    createParentBoundables: function createParentBoundables(t, e) {\n      f.isTrue(!t.isEmpty());\n      var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),\n          i = new I(t);\n      ho.sort(i, ke.xComparator);\n      var r = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n))));\n      return this.createParentBoundablesFromVerticalSlices(r, e);\n    },\n    nearestNeighbour: function nearestNeighbour() {\n      if (1 === arguments.length) {\n        if (R(arguments[0], Ve)) {\n          var t = arguments[0],\n              e = new qe(this.getRoot(), this.getRoot(), t);\n          return this.nearestNeighbour(e);\n        }\n\n        if (arguments[0] instanceof qe) {\n          var n = arguments[0];\n          return this.nearestNeighbour(n, r.POSITIVE_INFINITY);\n        }\n      } else if (2 === arguments.length) {\n        if (arguments[0] instanceof ke && R(arguments[1], Ve)) {\n          var i = arguments[0],\n              s = arguments[1],\n              e = new qe(this.getRoot(), i.getRoot(), s);\n          return this.nearestNeighbour(e);\n        }\n\n        if (arguments[0] instanceof qe && \"number\" == typeof arguments[1]) {\n          var o = arguments[0],\n              a = arguments[1],\n              u = a,\n              l = null,\n              h = new De();\n\n          for (h.add(o); !h.isEmpty() && u > 0;) {\n            var c = h.poll(),\n                f = c.getDistance();\n            if (f >= u) break;\n            c.isLeaves() ? (u = f, l = c) : c.expandToQueue(h, u);\n          }\n\n          return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()];\n        }\n      } else if (3 === arguments.length) {\n        var g = arguments[0],\n            d = arguments[1],\n            p = arguments[2],\n            v = new Me(g, d),\n            e = new qe(this.getRoot(), v, p);\n        return this.nearestNeighbour(e)[0];\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [Fe, u];\n    },\n    getClass: function getClass() {\n      return ke;\n    }\n  }), ke.centreX = function (t) {\n    return ke.avg(t.getMinX(), t.getMaxX());\n  }, ke.avg = function (t, e) {\n    return (t + e) / 2;\n  }, ke.centreY = function (t) {\n    return ke.avg(t.getMinY(), t.getMaxY());\n  }, h(Ye, Ge), e(Ye.prototype, {\n    computeBounds: function computeBounds() {\n      for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {\n        var n = e.next();\n        null === t ? t = new C(n.getBounds()) : t.expandToInclude(n.getBounds());\n      }\n\n      return t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ye;\n    }\n  }), ke.STRtreeNode = Ye, ke.serialVersionUID = 0x39920f7d5f261e0, ke.xComparator = {\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    compare: function compare(t, e) {\n      return Be.compareDoubles(ke.centreX(t.getBounds()), ke.centreX(e.getBounds()));\n    }\n  }, ke.yComparator = {\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    compare: function compare(t, e) {\n      return Be.compareDoubles(ke.centreY(t.getBounds()), ke.centreY(e.getBounds()));\n    }\n  }, ke.intersectsOp = {\n    interfaces_: function interfaces_() {\n      return [IntersectsOp];\n    },\n    intersects: function intersects(t, e) {\n      return t.intersects(e);\n    }\n  }, ke.DEFAULT_NODE_CAPACITY = 10, e(Ue.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ue;\n    }\n  }), Ue.relativeSign = function (t, e) {\n    return e > t ? -1 : t > e ? 1 : 0;\n  }, Ue.compare = function (t, e, n) {\n    if (e.equals2D(n)) return 0;\n    var i = Ue.relativeSign(e.x, n.x),\n        r = Ue.relativeSign(e.y, n.y);\n\n    switch (t) {\n      case 0:\n        return Ue.compareValue(i, r);\n\n      case 1:\n        return Ue.compareValue(r, i);\n\n      case 2:\n        return Ue.compareValue(r, -i);\n\n      case 3:\n        return Ue.compareValue(-i, r);\n\n      case 4:\n        return Ue.compareValue(-i, -r);\n\n      case 5:\n        return Ue.compareValue(-r, -i);\n\n      case 6:\n        return Ue.compareValue(-r, i);\n\n      case 7:\n        return Ue.compareValue(i, -r);\n    }\n\n    return f.shouldNeverReachHere(\"invalid octant value\"), 0;\n  }, Ue.compareValue = function (t, e) {\n    return 0 > t ? -1 : t > 0 ? 1 : 0 > e ? -1 : e > 0 ? 1 : 0;\n  }, e(Xe.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this.coord;\n    },\n    print: function print(t) {\n      t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex);\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : Ue.compare(this.segmentOctant, this.coord, e.coord);\n    },\n    isEndPoint: function isEndPoint(t) {\n      return 0 !== this.segmentIndex || this._isInterior ? this.segmentIndex === t : !0;\n    },\n    isInterior: function isInterior() {\n      return this._isInterior;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return Xe;\n    }\n  }), e(He.prototype, {\n    getSplitCoordinates: function getSplitCoordinates() {\n      var t = new N();\n      this.addEndpoints();\n\n      for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n        var i = e.next();\n        this.addEdgeCoordinates(n, i, t), n = i;\n      }\n\n      return t.toCoordinateArray();\n    },\n    addCollapsedNodes: function addCollapsedNodes() {\n      var t = new I();\n      this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);\n\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next().intValue();\n        this.add(this.edge.getCoordinate(n), n);\n      }\n    },\n    print: function print(t) {\n      t.println(\"Intersections:\");\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.print(t);\n      }\n    },\n    findCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(t) {\n      for (var e = 0; e < this.edge.size() - 2; e++) {\n        var n = this.edge.getCoordinate(e),\n            i = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));\n        n.equals2D(i) && t.add(new b(e + 1));\n      }\n    },\n    addEdgeCoordinates: function addEdgeCoordinates(t, e, n) {\n      var i = e.segmentIndex - t.segmentIndex + 2,\n          r = this.edge.getCoordinate(e.segmentIndex),\n          s = e.isInterior() || !e.coord.equals2D(r);\n      s || i--;\n      n.add(new g(t.coord), !1);\n\n      for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) {\n        n.add(this.edge.getCoordinate(o));\n      }\n\n      s && n.add(new g(e.coord));\n    },\n    iterator: function iterator() {\n      return this.nodeMap.values().iterator();\n    },\n    addSplitEdges: function addSplitEdges(t) {\n      this.addEndpoints(), this.addCollapsedNodes();\n\n      for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n        var i = e.next(),\n            r = this.createSplitEdge(n, i);\n        t.add(r), n = i;\n      }\n    },\n    findCollapseIndex: function findCollapseIndex(t, e, n) {\n      if (!t.coord.equals2D(e.coord)) return !1;\n      var i = e.segmentIndex - t.segmentIndex;\n      return e.isInterior() || i--, 1 === i ? (n[0] = t.segmentIndex + 1, !0) : !1;\n    },\n    findCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(t) {\n      for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {\n        var r = n.next(),\n            s = this.findCollapseIndex(i, r, e);\n        s && t.add(new b(e[0])), i = r;\n      }\n    },\n    getEdge: function getEdge() {\n      return this.edge;\n    },\n    addEndpoints: function addEndpoints() {\n      var t = this.edge.size() - 1;\n      this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t);\n    },\n    createSplitEdge: function createSplitEdge(t, e) {\n      var n = e.segmentIndex - t.segmentIndex + 2,\n          i = this.edge.getCoordinate(e.segmentIndex),\n          r = e.isInterior() || !e.coord.equals2D(i);\n      r || n--;\n      var s = new Array(n).fill(null),\n          o = 0;\n      s[o++] = new g(t.coord);\n\n      for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) {\n        s[o++] = this.edge.getCoordinate(a);\n      }\n\n      return r && (s[o] = new g(e.coord)), new Ke(s, this.edge.getData());\n    },\n    add: function add(t, e) {\n      var n = new Xe(this.edge, t, e, this.edge.getSegmentOctant(e)),\n          i = this.nodeMap.get(n);\n      return null !== i ? (f.isTrue(i.coord.equals2D(t), \"Found equal nodes with different coordinates\"), i) : (this.nodeMap.put(n, n), n);\n    },\n    checkSplitEdgesCorrectness: function checkSplitEdgesCorrectness(t) {\n      var e = this.edge.getCoordinates(),\n          n = t.get(0),\n          i = n.getCoordinate(0);\n      if (!i.equals2D(e[0])) throw new l(\"bad split edge start point at \" + i);\n      var r = t.get(t.size() - 1),\n          s = r.getCoordinates(),\n          o = s[s.length - 1];\n      if (!o.equals2D(e[e.length - 1])) throw new l(\"bad split edge end point at \" + o);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return He;\n    }\n  }), e(We.prototype, {\n    next: function next() {\n      return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex > this.currNode.segmentIndex, null);\n    },\n    remove: function remove() {\n      throw new UnsupportedOperationException(this.getClass().getName());\n    },\n    hasNext: function hasNext() {\n      return null !== this.nextNode;\n    },\n    readNextNode: function readNextNode() {\n      this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null;\n    },\n    interfaces_: function interfaces_() {\n      return [p];\n    },\n    getClass: function getClass() {\n      return We;\n    }\n  }), e(je.prototype, {\n    addIntersection: function addIntersection(t, e) {},\n    interfaces_: function interfaces_() {\n      return [be];\n    },\n    getClass: function getClass() {\n      return je;\n    }\n  }), e(Ke.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    size: function size() {\n      return this.pts.length;\n    },\n    getCoordinate: function getCoordinate(t) {\n      return this.pts[t];\n    },\n    isClosed: function isClosed() {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    },\n    getSegmentOctant: function getSegmentOctant(t) {\n      return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));\n    },\n    setData: function setData(t) {\n      this.data = t;\n    },\n    safeOctant: function safeOctant(t, e) {\n      return t.equals2D(e) ? 0 : Pe.octant(t, e);\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    addIntersection: function addIntersection() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        this.addIntersectionNode(t, e);\n      } else if (4 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = (arguments[2], arguments[3]),\n            s = new g(n.getIntersection(r));\n        this.addIntersection(s, i);\n      }\n    },\n    toString: function toString() {\n      return se.toLineString(new Gt(this.pts));\n    },\n    getNodeList: function getNodeList() {\n      return this.nodeList;\n    },\n    addIntersectionNode: function addIntersectionNode(t, e) {\n      var n = e,\n          i = n + 1;\n\n      if (i < this.pts.length) {\n        var r = this.pts[i];\n        t.equals2D(r) && (n = i);\n      }\n\n      var s = this.nodeList.add(t, n);\n      return s;\n    },\n    addIntersections: function addIntersections(t, e, n) {\n      for (var i = 0; i < t.getIntersectionNum(); i++) {\n        this.addIntersection(t, e, n, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [je];\n    },\n    getClass: function getClass() {\n      return Ke;\n    }\n  }), Ke.getNodedSubstrings = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new I();\n      return Ke.getNodedSubstrings(t, e), e;\n    }\n\n    if (2 === arguments.length) for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext();) {\n      var s = r.next();\n      s.getNodeList().addSplitEdges(i);\n    }\n  }, e(Ze.prototype, {\n    overlap: function overlap() {\n      if (2 === arguments.length) {\n        arguments[0], arguments[1];\n      } else if (4 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n        t.getLineSegment(e, this.overlapSeg1), n.getLineSegment(i, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ze;\n    }\n  }), e(Qe.prototype, {\n    getLineSegment: function getLineSegment(t, e) {\n      e.p0 = this.pts[t], e.p1 = this.pts[t + 1];\n    },\n    computeSelect: function computeSelect(t, e, n, i) {\n      var r = this.pts[e],\n          s = this.pts[n];\n      if (i.tempEnv1.init(r, s), n - e === 1) return i.select(this, e), null;\n      if (!t.intersects(i.tempEnv1)) return null;\n      var o = Math.trunc((e + n) / 2);\n      o > e && this.computeSelect(t, e, o, i), n > o && this.computeSelect(t, o, n, i);\n    },\n    getCoordinates: function getCoordinates() {\n      for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, n = this.start; n <= this.end; n++) {\n        t[e++] = this.pts[n];\n      }\n\n      return t;\n    },\n    computeOverlaps: function computeOverlaps(t, e) {\n      this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e);\n    },\n    setId: function setId(t) {\n      this.id = t;\n    },\n    select: function select(t, e) {\n      this.computeSelect(t, this.start, this.end, e);\n    },\n    getEnvelope: function getEnvelope() {\n      if (null === this.env) {\n        var t = this.pts[this.start],\n            e = this.pts[this.end];\n        this.env = new C(t, e);\n      }\n\n      return this.env;\n    },\n    getEndIndex: function getEndIndex() {\n      return this.end;\n    },\n    getStartIndex: function getStartIndex() {\n      return this.start;\n    },\n    getContext: function getContext() {\n      return this.context;\n    },\n    getId: function getId() {\n      return this.id;\n    },\n    computeOverlapsInternal: function computeOverlapsInternal(t, e, n, i, r, s) {\n      var o = this.pts[t],\n          a = this.pts[e],\n          u = n.pts[i],\n          l = n.pts[r];\n      if (e - t === 1 && r - i === 1) return s.overlap(this, t, n, i), null;\n      if (s.tempEnv1.init(o, a), s.tempEnv2.init(u, l), !s.tempEnv1.intersects(s.tempEnv2)) return null;\n      var h = Math.trunc((t + e) / 2),\n          c = Math.trunc((i + r) / 2);\n      h > t && (c > i && this.computeOverlapsInternal(t, h, n, i, c, s), r > c && this.computeOverlapsInternal(t, h, n, c, r, s)), e > h && (c > i && this.computeOverlapsInternal(h, e, n, i, c, s), r > c && this.computeOverlapsInternal(h, e, n, c, r, s));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Qe;\n    }\n  }), e(Je.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Je;\n    }\n  }), Je.isNorthern = function (t) {\n    return t === Je.NE || t === Je.NW;\n  }, Je.isOpposite = function (t, e) {\n    if (t === e) return !1;\n    var n = (t - e + 4) % 4;\n    return 2 === n;\n  }, Je.commonHalfPlane = function (t, e) {\n    if (t === e) return t;\n    var n = (t - e + 4) % 4;\n    if (2 === n) return -1;\n    var i = e > t ? t : e,\n        r = t > e ? t : e;\n    return 0 === i && 3 === r ? 3 : i;\n  }, Je.isInHalfPlane = function (t, e) {\n    return e === Je.SE ? t === Je.SE || t === Je.SW : t === e || t === e + 1;\n  }, Je.quadrant = function () {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n      var t = arguments[0],\n          e = arguments[1];\n      if (0 === t && 0 === e) throw new i(\"Cannot compute the quadrant for point ( \" + t + \", \" + e + \" )\");\n      return t >= 0 ? e >= 0 ? Je.NE : Je.SE : e >= 0 ? Je.NW : Je.SW;\n    }\n\n    if (arguments[0] instanceof g && arguments[1] instanceof g) {\n      var n = arguments[0],\n          r = arguments[1];\n      if (r.x === n.x && r.y === n.y) throw new i(\"Cannot compute the quadrant for two identical points \" + n);\n      return r.x >= n.x ? r.y >= n.y ? Je.NE : Je.SE : r.y >= n.y ? Je.NW : Je.SW;\n    }\n  }, Je.NE = 0, Je.NW = 1, Je.SW = 2, Je.SE = 3, e($e.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return $e;\n    }\n  }), $e.getChainStartIndices = function (t) {\n    var e = 0,\n        n = new I();\n    n.add(new b(e));\n\n    do {\n      var i = $e.findChainEnd(t, e);\n      n.add(new b(i)), e = i;\n    } while (e < t.length - 1);\n\n    var r = $e.toIntArray(n);\n    return r;\n  }, $e.findChainEnd = function (t, e) {\n    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) {\n      n++;\n    }\n\n    if (n >= t.length - 1) return t.length - 1;\n\n    for (var i = Je.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {\n      if (!t[r - 1].equals2D(t[r])) {\n        var s = Je.quadrant(t[r - 1], t[r]);\n        if (s !== i) break;\n      }\n\n      r++;\n    }\n\n    return r - 1;\n  }, $e.getChains = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return $e.getChains(t, null);\n    }\n\n    if (2 === arguments.length) {\n      for (var e = arguments[0], n = arguments[1], i = new I(), r = $e.getChainStartIndices(e), s = 0; s < r.length - 1; s++) {\n        var o = new Qe(e, r[s], r[s + 1], n);\n        i.add(o);\n      }\n\n      return i;\n    }\n  }, $e.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) {\n      e[n] = t.get(n).intValue();\n    }\n\n    return e;\n  }, e(tn.prototype, {\n    computeNodes: function computeNodes(t) {},\n    getNodedSubstrings: function getNodedSubstrings() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return tn;\n    }\n  }), e(en.prototype, {\n    setSegmentIntersector: function setSegmentIntersector(t) {\n      this.segInt = t;\n    },\n    interfaces_: function interfaces_() {\n      return [tn];\n    },\n    getClass: function getClass() {\n      return en;\n    }\n  }), h(nn, en), e(nn.prototype, {\n    getMonotoneChains: function getMonotoneChains() {\n      return this.monoChains;\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      return Ke.getNodedSubstrings(this.nodedSegStrings);\n    },\n    getIndex: function getIndex() {\n      return this.index;\n    },\n    add: function add(t) {\n      for (var e = $e.getChains(t.getCoordinates(), t), n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        i.setId(this.idCounter++), this.index.insert(i.getEnvelope(), i), this.monoChains.add(i);\n      }\n    },\n    computeNodes: function computeNodes(t) {\n      this.nodedSegStrings = t;\n\n      for (var e = t.iterator(); e.hasNext();) {\n        this.add(e.next());\n      }\n\n      this.intersectChains();\n    },\n    intersectChains: function intersectChains() {\n      for (var t = new rn(this.segInt), e = this.monoChains.iterator(); e.hasNext();) {\n        for (var n = e.next(), i = this.index.query(n.getEnvelope()), r = i.iterator(); r.hasNext();) {\n          var s = r.next();\n          if (s.getId() > n.getId() && (n.computeOverlaps(s, t), this.nOverlaps++), this.segInt.isDone()) return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return nn;\n    }\n  }), h(rn, Ze), e(rn.prototype, {\n    overlap: function overlap() {\n      if (4 !== arguments.length) return Ze.prototype.overlap.apply(this, arguments);\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = arguments[3],\n          r = t.getContext(),\n          s = n.getContext();\n      this.si.processIntersections(r, e, s, i);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return rn;\n    }\n  }), nn.SegmentOverlapAction = rn, h(sn, l), e(sn.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return sn;\n    }\n  }), sn.msgWithCoord = function (t, e) {\n    return null !== e ? t + \" [ \" + e + \" ]\" : t;\n  }, e(on.prototype, {\n    processIntersections: function processIntersections(t, e, n, i) {},\n    isDone: function isDone() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return on;\n    }\n  }), e(an.prototype, {\n    getInteriorIntersection: function getInteriorIntersection() {\n      return this.interiorIntersection;\n    },\n    setCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(t) {\n      this.isCheckEndSegmentsOnly = t;\n    },\n    getIntersectionSegments: function getIntersectionSegments() {\n      return this.intSegments;\n    },\n    count: function count() {\n      return this.intersectionCount;\n    },\n    getIntersections: function getIntersections() {\n      return this.intersections;\n    },\n    setFindAllIntersections: function setFindAllIntersections(t) {\n      this.findAllIntersections = t;\n    },\n    setKeepIntersections: function setKeepIntersections(t) {\n      this.keepIntersections = t;\n    },\n    processIntersections: function processIntersections(t, e, n, i) {\n      if (!this.findAllIntersections && this.hasIntersection()) return null;\n      if (t === n && e === i) return null;\n\n      if (this.isCheckEndSegmentsOnly) {\n        var r = this.isEndSegment(t, e) || this.isEndSegment(n, i);\n        if (!r) return null;\n      }\n\n      var s = t.getCoordinates()[e],\n          o = t.getCoordinates()[e + 1],\n          a = n.getCoordinates()[i],\n          u = n.getCoordinates()[i + 1];\n      this.li.computeIntersection(s, o, a, u), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = s, this.intSegments[1] = o, this.intSegments[2] = a, this.intSegments[3] = u, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++);\n    },\n    isEndSegment: function isEndSegment(t, e) {\n      return 0 === e ? !0 : e >= t.size() - 2;\n    },\n    hasIntersection: function hasIntersection() {\n      return null !== this.interiorIntersection;\n    },\n    isDone: function isDone() {\n      return this.findAllIntersections ? !1 : null !== this.interiorIntersection;\n    },\n    interfaces_: function interfaces_() {\n      return [on];\n    },\n    getClass: function getClass() {\n      return an;\n    }\n  }), an.createAllIntersectionsFinder = function (t) {\n    var e = new an(t);\n    return e.setFindAllIntersections(!0), e;\n  }, an.createAnyIntersectionFinder = function (t) {\n    return new an(t);\n  }, an.createIntersectionCounter = function (t) {\n    var e = new an(t);\n    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;\n  }, e(un.prototype, {\n    execute: function execute() {\n      return null !== this.segInt ? null : void this.checkInteriorIntersections();\n    },\n    getIntersections: function getIntersections() {\n      return this.segInt.getIntersections();\n    },\n    isValid: function isValid() {\n      return this.execute(), this._isValid;\n    },\n    setFindAllIntersections: function setFindAllIntersections(t) {\n      this.findAllIntersections = t;\n    },\n    checkInteriorIntersections: function checkInteriorIntersections() {\n      this._isValid = !0, this.segInt = new an(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);\n      var t = new nn();\n      return t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection() ? (this._isValid = !1, null) : void 0;\n    },\n    checkValid: function checkValid() {\n      if (this.execute(), !this._isValid) throw new sn(this.getErrorMessage(), this.segInt.getInteriorIntersection());\n    },\n    getErrorMessage: function getErrorMessage() {\n      if (this._isValid) return \"no intersections found\";\n      var t = this.segInt.getIntersectionSegments();\n      return \"found non-noded intersection between \" + se.toLineString(t[0], t[1]) + \" and \" + se.toLineString(t[2], t[3]);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return un;\n    }\n  }), un.computeIntersections = function (t) {\n    var e = new un(t);\n    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();\n  }, e(ln.prototype, {\n    checkValid: function checkValid() {\n      this.nv.checkValid();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ln;\n    }\n  }), ln.toSegmentStrings = function (t) {\n    for (var e = new I(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e.add(new Oe(i.getCoordinates(), i));\n    }\n\n    return e;\n  }, ln.checkValid = function (t) {\n    var e = new ln(t);\n    e.checkValid();\n  }, e(hn.prototype, {\n    map: function map(t) {\n      for (var e = new I(), n = 0; n < t.getNumGeometries(); n++) {\n        var i = this.mapOp.map(t.getGeometryN(n));\n        i.isEmpty() || e.add(i);\n      }\n\n      return t.getFactory().createGeometryCollection(ie.toGeometryArray(e));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return hn;\n    }\n  }), hn.map = function (t, e) {\n    var n = new hn(e);\n    return n.map(t);\n  }, e(cn.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return cn;\n    }\n  }), cn.opposite = function (t) {\n    return t === cn.LEFT ? cn.RIGHT : t === cn.RIGHT ? cn.LEFT : t;\n  }, cn.ON = 0, cn.LEFT = 1, cn.RIGHT = 2, e(fn.prototype, {\n    setAllLocations: function setAllLocations(t) {\n      for (var e = 0; e < this.location.length; e++) {\n        this.location[e] = t;\n      }\n    },\n    isNull: function isNull() {\n      for (var t = 0; t < this.location.length; t++) {\n        if (this.location[t] !== L.NONE) return !1;\n      }\n\n      return !0;\n    },\n    setAllLocationsIfNull: function setAllLocationsIfNull(t) {\n      for (var e = 0; e < this.location.length; e++) {\n        this.location[e] === L.NONE && (this.location[e] = t);\n      }\n    },\n    isLine: function isLine() {\n      return 1 === this.location.length;\n    },\n    merge: function merge(t) {\n      if (t.location.length > this.location.length) {\n        var e = new Array(3).fill(null);\n        e[cn.ON] = this.location[cn.ON], e[cn.LEFT] = L.NONE, e[cn.RIGHT] = L.NONE, this.location = e;\n      }\n\n      for (var n = 0; n < this.location.length; n++) {\n        this.location[n] === L.NONE && n < t.location.length && (this.location[n] = t.location[n]);\n      }\n    },\n    getLocations: function getLocations() {\n      return this.location;\n    },\n    flip: function flip() {\n      if (this.location.length <= 1) return null;\n      var t = this.location[cn.LEFT];\n      this.location[cn.LEFT] = this.location[cn.RIGHT], this.location[cn.RIGHT] = t;\n    },\n    toString: function toString() {\n      var t = new P();\n      return this.location.length > 1 && t.append(L.toLocationSymbol(this.location[cn.LEFT])), t.append(L.toLocationSymbol(this.location[cn.ON])), this.location.length > 1 && t.append(L.toLocationSymbol(this.location[cn.RIGHT])), t.toString();\n    },\n    setLocations: function setLocations(t, e, n) {\n      this.location[cn.ON] = t, this.location[cn.LEFT] = e, this.location[cn.RIGHT] = n;\n    },\n    get: function get(t) {\n      return t < this.location.length ? this.location[t] : L.NONE;\n    },\n    isArea: function isArea() {\n      return this.location.length > 1;\n    },\n    isAnyNull: function isAnyNull() {\n      for (var t = 0; t < this.location.length; t++) {\n        if (this.location[t] === L.NONE) return !0;\n      }\n\n      return !1;\n    },\n    setLocation: function setLocation() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.setLocation(cn.ON, t);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        this.location[e] = n;\n      }\n    },\n    init: function init(t) {\n      this.location = new Array(t).fill(null), this.setAllLocations(L.NONE);\n    },\n    isEqualOnSide: function isEqualOnSide(t, e) {\n      return this.location[e] === t.location[e];\n    },\n    allPositionsEqual: function allPositionsEqual(t) {\n      for (var e = 0; e < this.location.length; e++) {\n        if (this.location[e] !== t) return !1;\n      }\n\n      return !0;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return fn;\n    }\n  }), e(gn.prototype, {\n    getGeometryCount: function getGeometryCount() {\n      var t = 0;\n      return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;\n    },\n    setAllLocations: function setAllLocations(t, e) {\n      this.elt[t].setAllLocations(e);\n    },\n    isNull: function isNull(t) {\n      return this.elt[t].isNull();\n    },\n    setAllLocationsIfNull: function setAllLocationsIfNull() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        this.elt[e].setAllLocationsIfNull(n);\n      }\n    },\n    isLine: function isLine(t) {\n      return this.elt[t].isLine();\n    },\n    merge: function merge(t) {\n      for (var e = 0; 2 > e; e++) {\n        null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new fn(t.elt[e]) : this.elt[e].merge(t.elt[e]);\n      }\n    },\n    flip: function flip() {\n      this.elt[0].flip(), this.elt[1].flip();\n    },\n    getLocation: function getLocation() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.elt[t].get(cn.ON);\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return this.elt[e].get(n);\n      }\n    },\n    toString: function toString() {\n      var t = new P();\n      return null !== this.elt[0] && (t.append(\"A:\"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(\" B:\"), t.append(this.elt[1].toString())), t.toString();\n    },\n    isArea: function isArea() {\n      if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.elt[t].isArea();\n      }\n    },\n    isAnyNull: function isAnyNull(t) {\n      return this.elt[t].isAnyNull();\n    },\n    setLocation: function setLocation() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        this.elt[t].setLocation(cn.ON, e);\n      } else if (3 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2];\n        this.elt[n].setLocation(i, r);\n      }\n    },\n    isEqualOnSide: function isEqualOnSide(t, e) {\n      return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);\n    },\n    allPositionsEqual: function allPositionsEqual(t, e) {\n      return this.elt[t].allPositionsEqual(e);\n    },\n    toLine: function toLine(t) {\n      this.elt[t].isArea() && (this.elt[t] = new fn(this.elt[t].location[0]));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return gn;\n    }\n  }), gn.toLineLabel = function (t) {\n    for (var e = new gn(L.NONE), n = 0; 2 > n; n++) {\n      e.setLocation(n, t.getLocation(n));\n    }\n\n    return e;\n  }, e(dn.prototype, {\n    computeRing: function computeRing() {\n      if (null !== this.ring) return null;\n\n      for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++) {\n        t[e] = this.pts.get(e);\n      }\n\n      this.ring = this.geometryFactory.createLinearRing(t), this._isHole = he.isCCW(this.ring.getCoordinates());\n    },\n    isIsolated: function isIsolated() {\n      return 1 === this.label.getGeometryCount();\n    },\n    computePoints: function computePoints(t) {\n      this.startDe = t;\n      var e = t,\n          n = !0;\n\n      do {\n        if (null === e) throw new sn(\"Found null DirectedEdge\");\n        if (e.getEdgeRing() === this) throw new sn(\"Directed Edge visited twice during ring-building at \" + e.getCoordinate());\n        this.edges.add(e);\n        var i = e.getLabel();\n        f.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);\n      } while (e !== this.startDe);\n    },\n    getLinearRing: function getLinearRing() {\n      return this.ring;\n    },\n    getCoordinate: function getCoordinate(t) {\n      return this.pts.get(t);\n    },\n    computeMaxNodeDegree: function computeMaxNodeDegree() {\n      this.maxNodeDegree = 0;\n      var t = this.startDe;\n\n      do {\n        var e = t.getNode(),\n            n = e.getEdges().getOutgoingDegree(this);\n        n > this.maxNodeDegree && (this.maxNodeDegree = n), t = this.getNext(t);\n      } while (t !== this.startDe);\n\n      this.maxNodeDegree *= 2;\n    },\n    addPoints: function addPoints(t, e, n) {\n      var i = t.getCoordinates();\n\n      if (e) {\n        var r = 1;\n        n && (r = 0);\n\n        for (var s = r; s < i.length; s++) {\n          this.pts.add(i[s]);\n        }\n      } else {\n        var r = i.length - 2;\n        n && (r = i.length - 1);\n\n        for (var s = r; s >= 0; s--) {\n          this.pts.add(i[s]);\n        }\n      }\n    },\n    isHole: function isHole() {\n      return this._isHole;\n    },\n    setInResult: function setInResult() {\n      var t = this.startDe;\n\n      do {\n        t.getEdge().setInResult(!0), t = t.getNext();\n      } while (t !== this.startDe);\n    },\n    containsPoint: function containsPoint(t) {\n      var e = this.getLinearRing(),\n          n = e.getEnvelopeInternal();\n      if (!n.contains(t)) return !1;\n      if (!he.isPointInRing(t, e.getCoordinates())) return !1;\n\n      for (var i = this.holes.iterator(); i.hasNext();) {\n        var r = i.next();\n        if (r.containsPoint(t)) return !1;\n      }\n\n      return !0;\n    },\n    addHole: function addHole(t) {\n      this.holes.add(t);\n    },\n    isShell: function isShell() {\n      return null === this.shell;\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    getEdges: function getEdges() {\n      return this.edges;\n    },\n    getMaxNodeDegree: function getMaxNodeDegree() {\n      return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree;\n    },\n    getShell: function getShell() {\n      return this.shell;\n    },\n    mergeLabel: function mergeLabel() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.mergeLabel(t, 0), this.mergeLabel(t, 1);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = e.getLocation(n, cn.RIGHT);\n        if (i === L.NONE) return null;\n        if (this.label.getLocation(n) === L.NONE) return this.label.setLocation(n, i), null;\n      }\n    },\n    setShell: function setShell(t) {\n      this.shell = t, null !== t && t.addHole(this);\n    },\n    toPolygon: function toPolygon(t) {\n      for (var e = new Array(this.holes.size()).fill(null), n = 0; n < this.holes.size(); n++) {\n        e[n] = this.holes.get(n).getLinearRing();\n      }\n\n      var i = t.createPolygon(this.getLinearRing(), e);\n      return i;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return dn;\n    }\n  }), h(pn, dn), e(pn.prototype, {\n    setEdgeRing: function setEdgeRing(t, e) {\n      t.setMinEdgeRing(e);\n    },\n    getNext: function getNext(t) {\n      return t.getNextMin();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return pn;\n    }\n  }), h(vn, dn), e(vn.prototype, {\n    buildMinimalRings: function buildMinimalRings() {\n      var t = new I(),\n          e = this.startDe;\n\n      do {\n        if (null === e.getMinEdgeRing()) {\n          var n = new pn(e, this.geometryFactory);\n          t.add(n);\n        }\n\n        e = e.getNext();\n      } while (e !== this.startDe);\n\n      return t;\n    },\n    setEdgeRing: function setEdgeRing(t, e) {\n      t.setEdgeRing(e);\n    },\n    linkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {\n      var t = this.startDe;\n\n      do {\n        var e = t.getNode();\n        e.getEdges().linkMinimalDirectedEdges(this), t = t.getNext();\n      } while (t !== this.startDe);\n    },\n    getNext: function getNext(t) {\n      return t.getNext();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return vn;\n    }\n  }), e(mn.prototype, {\n    setVisited: function setVisited(t) {\n      this._isVisited = t;\n    },\n    setInResult: function setInResult(t) {\n      this._isInResult = t;\n    },\n    isCovered: function isCovered() {\n      return this._isCovered;\n    },\n    isCoveredSet: function isCoveredSet() {\n      return this._isCoveredSet;\n    },\n    setLabel: function setLabel(t) {\n      this.label = t;\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    setCovered: function setCovered(t) {\n      this._isCovered = t, this._isCoveredSet = !0;\n    },\n    updateIM: function updateIM(t) {\n      f.isTrue(this.label.getGeometryCount() >= 2, \"found partial label\"), this.computeIM(t);\n    },\n    isInResult: function isInResult() {\n      return this._isInResult;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return mn;\n    }\n  }), h(yn, mn), e(yn.prototype, {\n    isIncidentEdgeInResult: function isIncidentEdgeInResult() {\n      for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {\n        var e = t.next();\n        if (e.getEdge().isInResult()) return !0;\n      }\n\n      return !1;\n    },\n    isIsolated: function isIsolated() {\n      return 1 === this.label.getGeometryCount();\n    },\n    getCoordinate: function getCoordinate() {\n      return this.coord;\n    },\n    print: function print(t) {\n      t.println(\"node \" + this.coord + \" lbl: \" + this.label);\n    },\n    computeIM: function computeIM(t) {},\n    computeMergedLocation: function computeMergedLocation(t, e) {\n      var n = L.NONE;\n\n      if (n = this.label.getLocation(e), !t.isNull(e)) {\n        var i = t.getLocation(e);\n        n !== L.BOUNDARY && (n = i);\n      }\n\n      return n;\n    },\n    setLabel: function setLabel() {\n      if (2 !== arguments.length) return mn.prototype.setLabel.apply(this, arguments);\n      var t = arguments[0],\n          e = arguments[1];\n      null === this.label ? this.label = new gn(t, e) : this.label.setLocation(t, e);\n    },\n    getEdges: function getEdges() {\n      return this.edges;\n    },\n    mergeLabel: function mergeLabel() {\n      if (arguments[0] instanceof yn) {\n        var t = arguments[0];\n        this.mergeLabel(t.label);\n      } else if (arguments[0] instanceof gn) for (var e = arguments[0], n = 0; 2 > n; n++) {\n        var i = this.computeMergedLocation(e, n),\n            r = this.label.getLocation(n);\n        r === L.NONE && this.label.setLocation(n, i);\n      }\n    },\n    add: function add(t) {\n      this.edges.insert(t), t.setNode(this);\n    },\n    setLabelBoundary: function setLabelBoundary(t) {\n      if (null === this.label) return null;\n      var e = L.NONE;\n      null !== this.label && (e = this.label.getLocation(t));\n      var n = null;\n\n      switch (e) {\n        case L.BOUNDARY:\n          n = L.INTERIOR;\n          break;\n\n        case L.INTERIOR:\n          n = L.BOUNDARY;\n          break;\n\n        default:\n          n = L.BOUNDARY;\n      }\n\n      this.label.setLocation(t, n);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return yn;\n    }\n  }), e(xn.prototype, {\n    find: function find(t) {\n      return this.nodeMap.get(t);\n    },\n    addNode: function addNode() {\n      if (arguments[0] instanceof g) {\n        var t = arguments[0],\n            e = this.nodeMap.get(t);\n        return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;\n      }\n\n      if (arguments[0] instanceof yn) {\n        var n = arguments[0],\n            e = this.nodeMap.get(n.getCoordinate());\n        return null === e ? (this.nodeMap.put(n.getCoordinate(), n), n) : (e.mergeLabel(n), e);\n      }\n    },\n    print: function print(t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.print(t);\n      }\n    },\n    iterator: function iterator() {\n      return this.nodeMap.values().iterator();\n    },\n    values: function values() {\n      return this.nodeMap.values();\n    },\n    getBoundaryNodes: function getBoundaryNodes(t) {\n      for (var e = new I(), n = this.iterator(); n.hasNext();) {\n        var i = n.next();\n        i.getLabel().getLocation(t) === L.BOUNDARY && e.add(i);\n      }\n\n      return e;\n    },\n    add: function add(t) {\n      var e = t.getCoordinate(),\n          n = this.addNode(e);\n      n.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return xn;\n    }\n  }), e(En.prototype, {\n    compareDirection: function compareDirection(t) {\n      return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : he.computeOrientation(t.p0, t.p1, this.p1);\n    },\n    getDy: function getDy() {\n      return this.dy;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.p0;\n    },\n    setNode: function setNode(t) {\n      this.node = t;\n    },\n    print: function print(t) {\n      var e = Math.atan2(this.dy, this.dx),\n          n = this.getClass().getName(),\n          i = n.lastIndexOf(\".\"),\n          r = n.substring(i + 1);\n      t.print(\"  \" + r + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + e + \"   \" + this.label);\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.compareDirection(e);\n    },\n    getDirectedCoordinate: function getDirectedCoordinate() {\n      return this.p1;\n    },\n    getDx: function getDx() {\n      return this.dx;\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    getEdge: function getEdge() {\n      return this.edge;\n    },\n    getQuadrant: function getQuadrant() {\n      return this.quadrant;\n    },\n    getNode: function getNode() {\n      return this.node;\n    },\n    toString: function toString() {\n      var t = Math.atan2(this.dy, this.dx),\n          e = this.getClass().getName(),\n          n = e.lastIndexOf(\".\"),\n          i = e.substring(n + 1);\n      return \"  \" + i + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + t + \"   \" + this.label;\n    },\n    computeLabel: function computeLabel(t) {},\n    init: function init(t, e) {\n      this.p0 = t, this.p1 = e, this.dx = e.x - t.x, this.dy = e.y - t.y, this.quadrant = Je.quadrant(this.dx, this.dy), f.isTrue(!(0 === this.dx && 0 === this.dy), \"EdgeEnd with identical endpoints found\");\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return En;\n    }\n  }), h(In, En), e(In.prototype, {\n    getNextMin: function getNextMin() {\n      return this.nextMin;\n    },\n    getDepth: function getDepth(t) {\n      return this.depth[t];\n    },\n    setVisited: function setVisited(t) {\n      this._isVisited = t;\n    },\n    computeDirectedLabel: function computeDirectedLabel() {\n      this.label = new gn(this.edge.getLabel()), this._isForward || this.label.flip();\n    },\n    getNext: function getNext() {\n      return this.next;\n    },\n    setDepth: function setDepth(t, e) {\n      if (-999 !== this.depth[t] && this.depth[t] !== e) throw new sn(\"assigned depths do not match\", this.getCoordinate());\n      this.depth[t] = e;\n    },\n    isInteriorAreaEdge: function t() {\n      for (var t = !0, e = 0; 2 > e; e++) {\n        this.label.isArea(e) && this.label.getLocation(e, cn.LEFT) === L.INTERIOR && this.label.getLocation(e, cn.RIGHT) === L.INTERIOR || (t = !1);\n      }\n\n      return t;\n    },\n    setNextMin: function setNextMin(t) {\n      this.nextMin = t;\n    },\n    print: function print(t) {\n      En.prototype.print.call(this, t), t.print(\" \" + this.depth[cn.LEFT] + \"/\" + this.depth[cn.RIGHT]), t.print(\" (\" + this.getDepthDelta() + \")\"), this._isInResult && t.print(\" inResult\");\n    },\n    setMinEdgeRing: function setMinEdgeRing(t) {\n      this.minEdgeRing = t;\n    },\n    isLineEdge: function isLineEdge() {\n      var t = this.label.isLine(0) || this.label.isLine(1),\n          e = !this.label.isArea(0) || this.label.allPositionsEqual(0, L.EXTERIOR),\n          n = !this.label.isArea(1) || this.label.allPositionsEqual(1, L.EXTERIOR);\n      return t && e && n;\n    },\n    setEdgeRing: function setEdgeRing(t) {\n      this.edgeRing = t;\n    },\n    getMinEdgeRing: function getMinEdgeRing() {\n      return this.minEdgeRing;\n    },\n    getDepthDelta: function getDepthDelta() {\n      var t = this.edge.getDepthDelta();\n      return this._isForward || (t = -t), t;\n    },\n    setInResult: function setInResult(t) {\n      this._isInResult = t;\n    },\n    getSym: function getSym() {\n      return this.sym;\n    },\n    isForward: function isForward() {\n      return this._isForward;\n    },\n    getEdge: function getEdge() {\n      return this.edge;\n    },\n    printEdge: function printEdge(t) {\n      this.print(t), t.print(\" \"), this._isForward ? this.edge.print(t) : this.edge.printReverse(t);\n    },\n    setSym: function setSym(t) {\n      this.sym = t;\n    },\n    setVisitedEdge: function setVisitedEdge(t) {\n      this.setVisited(t), this.sym.setVisited(t);\n    },\n    setEdgeDepths: function setEdgeDepths(t, e) {\n      var n = this.getEdge().getDepthDelta();\n      this._isForward || (n = -n);\n      var i = 1;\n      t === cn.LEFT && (i = -1);\n      var r = cn.opposite(t),\n          s = n * i,\n          o = e + s;\n      this.setDepth(t, e), this.setDepth(r, o);\n    },\n    getEdgeRing: function getEdgeRing() {\n      return this.edgeRing;\n    },\n    isInResult: function isInResult() {\n      return this._isInResult;\n    },\n    setNext: function setNext(t) {\n      this.next = t;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return In;\n    }\n  }), In.depthFactor = function (t, e) {\n    return t === L.EXTERIOR && e === L.INTERIOR ? 1 : t === L.INTERIOR && e === L.EXTERIOR ? -1 : 0;\n  }, e(Nn.prototype, {\n    createNode: function createNode(t) {\n      return new yn(t, null);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Nn;\n    }\n  }), e(Cn.prototype, {\n    printEdges: function printEdges(t) {\n      t.println(\"Edges:\");\n\n      for (var e = 0; e < this.edges.size(); e++) {\n        t.println(\"edge \" + e + \":\");\n        var n = this.edges.get(e);\n        n.print(t), n.eiList.print(t);\n      }\n    },\n    find: function find(t) {\n      return this.nodes.find(t);\n    },\n    addNode: function addNode() {\n      if (arguments[0] instanceof yn) {\n        var t = arguments[0];\n        return this.nodes.addNode(t);\n      }\n\n      if (arguments[0] instanceof g) {\n        var e = arguments[0];\n        return this.nodes.addNode(e);\n      }\n    },\n    getNodeIterator: function getNodeIterator() {\n      return this.nodes.iterator();\n    },\n    linkResultDirectedEdges: function linkResultDirectedEdges() {\n      for (var t = this.nodes.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().linkResultDirectedEdges();\n      }\n    },\n    debugPrintln: function debugPrintln(t) {\n      A.out.println(t);\n    },\n    isBoundaryNode: function isBoundaryNode(t, e) {\n      var n = this.nodes.find(e);\n      if (null === n) return !1;\n      var i = n.getLabel();\n      return null !== i && i.getLocation(t) === L.BOUNDARY;\n    },\n    linkAllDirectedEdges: function linkAllDirectedEdges() {\n      for (var t = this.nodes.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().linkAllDirectedEdges();\n      }\n    },\n    matchInSameDirection: function matchInSameDirection(t, e, n, i) {\n      return t.equals(n) ? he.computeOrientation(t, e, i) === he.COLLINEAR && Je.quadrant(t, e) === Je.quadrant(n, i) : !1;\n    },\n    getEdgeEnds: function getEdgeEnds() {\n      return this.edgeEndList;\n    },\n    debugPrint: function debugPrint(t) {\n      A.out.print(t);\n    },\n    getEdgeIterator: function getEdgeIterator() {\n      return this.edges.iterator();\n    },\n    findEdgeInSameDirection: function findEdgeInSameDirection(t, e) {\n      for (var n = 0; n < this.edges.size(); n++) {\n        var i = this.edges.get(n),\n            r = i.getCoordinates();\n        if (this.matchInSameDirection(t, e, r[0], r[1])) return i;\n        if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;\n      }\n\n      return null;\n    },\n    insertEdge: function insertEdge(t) {\n      this.edges.add(t);\n    },\n    findEdgeEnd: function findEdgeEnd(t) {\n      for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {\n        var n = e.next();\n        if (n.getEdge() === t) return n;\n      }\n\n      return null;\n    },\n    addEdges: function addEdges(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.edges.add(n);\n        var i = new In(n, !0),\n            r = new In(n, !1);\n        i.setSym(r), r.setSym(i), this.add(i), this.add(r);\n      }\n    },\n    add: function add(t) {\n      this.nodes.add(t), this.edgeEndList.add(t);\n    },\n    getNodes: function getNodes() {\n      return this.nodes.values();\n    },\n    findEdge: function findEdge(t, e) {\n      for (var n = 0; n < this.edges.size(); n++) {\n        var i = this.edges.get(n),\n            r = i.getCoordinates();\n        if (t.equals(r[0]) && e.equals(r[1])) return i;\n      }\n\n      return null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Cn;\n    }\n  }), Cn.linkResultDirectedEdges = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next();\n      n.getEdges().linkResultDirectedEdges();\n    }\n  }, e(Sn.prototype, {\n    sortShellsAndHoles: function sortShellsAndHoles(t, e, n) {\n      for (var i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        r.isHole() ? n.add(r) : e.add(r);\n      }\n    },\n    computePolygons: function computePolygons(t) {\n      for (var e = new I(), n = t.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.toPolygon(this.geometryFactory);\n        e.add(r);\n      }\n\n      return e;\n    },\n    placeFreeHoles: function placeFreeHoles(t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (null === i.getShell()) {\n          var r = this.findEdgeRingContaining(i, t);\n          if (null === r) throw new sn(\"unable to assign hole to a shell\", i.getCoordinate(0));\n          i.setShell(r);\n        }\n      }\n    },\n    buildMinimalEdgeRings: function buildMinimalEdgeRings(t, e, n) {\n      for (var i = new I(), r = t.iterator(); r.hasNext();) {\n        var s = r.next();\n\n        if (s.getMaxNodeDegree() > 2) {\n          s.linkDirectedEdgesForMinimalEdgeRings();\n          var o = s.buildMinimalRings(),\n              a = this.findShell(o);\n          null !== a ? (this.placePolygonHoles(a, o), e.add(a)) : n.addAll(o);\n        } else i.add(s);\n      }\n\n      return i;\n    },\n    containsPoint: function containsPoint(t) {\n      for (var e = this.shellList.iterator(); e.hasNext();) {\n        var n = e.next();\n        if (n.containsPoint(t)) return !0;\n      }\n\n      return !1;\n    },\n    buildMaximalEdgeRings: function buildMaximalEdgeRings(t) {\n      for (var e = new I(), n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {\n          var r = new vn(i, this.geometryFactory);\n          e.add(r), r.setInResult();\n        }\n      }\n\n      return e;\n    },\n    placePolygonHoles: function placePolygonHoles(t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        i.isHole() && i.setShell(t);\n      }\n    },\n    getPolygons: function getPolygons() {\n      var t = this.computePolygons(this.shellList);\n      return t;\n    },\n    findEdgeRingContaining: function findEdgeRingContaining(t, e) {\n      for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, o = null, a = e.iterator(); a.hasNext();) {\n        var u = a.next(),\n            l = u.getLinearRing(),\n            h = l.getEnvelopeInternal();\n        null !== s && (o = s.getLinearRing().getEnvelopeInternal());\n        var c = !1;\n        h.contains(i) && he.isPointInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || o.contains(h)) && (s = u);\n      }\n\n      return s;\n    },\n    findShell: function findShell(t) {\n      for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        r.isHole() || (n = r, e++);\n      }\n\n      return f.isTrue(1 >= e, \"found two shells in MinimalEdgeRing list\"), n;\n    },\n    add: function add() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.add(t.getEdgeEnds(), t.getNodes());\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        Cn.linkResultDirectedEdges(n);\n        var i = this.buildMaximalEdgeRings(e),\n            r = new I(),\n            s = this.buildMinimalEdgeRings(i, this.shellList, r);\n        this.sortShellsAndHoles(s, this.shellList, r), this.placeFreeHoles(this.shellList, r);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Sn;\n    }\n  }), e(wn.prototype, {\n    collectLines: function collectLines(t) {\n      for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {\n        var n = e.next();\n        this.collectLineEdge(n, t, this.lineEdgesList), this.collectBoundaryTouchEdge(n, t, this.lineEdgesList);\n      }\n    },\n    labelIsolatedLine: function labelIsolatedLine(t, e) {\n      var n = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));\n      t.getLabel().setLocation(e, n);\n    },\n    build: function build(t) {\n      return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList;\n    },\n    collectLineEdge: function collectLineEdge(t, e, n) {\n      var i = t.getLabel(),\n          r = t.getEdge();\n      t.isLineEdge() && (t.isVisited() || !ii.isResultOfOp(i, e) || r.isCovered() || (n.add(r), t.setVisitedEdge(!0)));\n    },\n    findCoveredLineEdges: function findCoveredLineEdges() {\n      for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().findCoveredLineEdges();\n      }\n\n      for (var n = this.op.getGraph().getEdgeEnds().iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getEdge();\n\n        if (i.isLineEdge() && !r.isCoveredSet()) {\n          var s = this.op.isCoveredByA(i.getCoordinate());\n          r.setCovered(s);\n        }\n      }\n    },\n    labelIsolatedLines: function labelIsolatedLines(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getLabel();\n        n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1));\n      }\n    },\n    buildLines: function buildLines(t) {\n      for (var e = this.lineEdgesList.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = (n.getLabel(), this.geometryFactory.createLineString(n.getCoordinates()));\n        this.resultLineList.add(i), n.setInResult(!0);\n      }\n    },\n    collectBoundaryTouchEdge: function collectBoundaryTouchEdge(t, e, n) {\n      var i = t.getLabel();\n      return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (f.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (ii.isResultOfOp(i, e) && e === ii.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return wn;\n    }\n  }), e(Ln.prototype, {\n    filterCoveredNodeToPoint: function filterCoveredNodeToPoint(t) {\n      var e = t.getCoordinate();\n\n      if (!this.op.isCoveredByLA(e)) {\n        var n = this.geometryFactory.createPoint(e);\n        this.resultPointList.add(n);\n      }\n    },\n    extractNonCoveredResultNodes: function extractNonCoveredResultNodes(t) {\n      for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {\n        var n = e.next();\n\n        if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== ii.INTERSECTION)) {\n          var i = n.getLabel();\n          ii.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n);\n        }\n      }\n    },\n    build: function build(t) {\n      return this.extractNonCoveredResultNodes(t), this.resultPointList;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ln;\n    }\n  }), e(Rn.prototype, {\n    locate: function locate(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Rn;\n    }\n  }), e(Tn.prototype, {\n    locate: function locate(t) {\n      return Tn.locate(t, this.geom);\n    },\n    interfaces_: function interfaces_() {\n      return [Rn];\n    },\n    getClass: function getClass() {\n      return Tn;\n    }\n  }), Tn.isPointInRing = function (t, e) {\n    return e.getEnvelopeInternal().intersects(t) ? he.isPointInRing(t, e.getCoordinates()) : !1;\n  }, Tn.containsPointInPolygon = function (t, e) {\n    if (e.isEmpty()) return !1;\n    var n = e.getExteriorRing();\n    if (!Tn.isPointInRing(t, n)) return !1;\n\n    for (var i = 0; i < e.getNumInteriorRing(); i++) {\n      var r = e.getInteriorRingN(i);\n      if (Tn.isPointInRing(t, r)) return !1;\n    }\n\n    return !0;\n  }, Tn.containsPoint = function (t, e) {\n    if (e instanceof Tt) return Tn.containsPointInPolygon(t, e);\n    if (e instanceof ft) for (var n = new Re(e); n.hasNext();) {\n      var i = n.next();\n      if (i !== e && Tn.containsPoint(t, i)) return !0;\n    }\n    return !1;\n  }, Tn.locate = function (t, e) {\n    return e.isEmpty() ? L.EXTERIOR : Tn.containsPoint(t, e) ? L.INTERIOR : L.EXTERIOR;\n  }, e(Pn.prototype, {\n    getNextCW: function getNextCW(t) {\n      this.getEdges();\n      var e = this.edgeList.indexOf(t),\n          n = e - 1;\n      return 0 === e && (n = this.edgeList.size() - 1), this.edgeList.get(n);\n    },\n    propagateSideLabels: function propagateSideLabels(t) {\n      for (var e = L.NONE, n = this.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getLabel();\n        r.isArea(t) && r.getLocation(t, cn.LEFT) !== L.NONE && (e = r.getLocation(t, cn.LEFT));\n      }\n\n      if (e === L.NONE) return null;\n\n      for (var s = e, n = this.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getLabel();\n\n        if (r.getLocation(t, cn.ON) === L.NONE && r.setLocation(t, cn.ON, s), r.isArea(t)) {\n          var o = r.getLocation(t, cn.LEFT),\n              a = r.getLocation(t, cn.RIGHT);\n\n          if (a !== L.NONE) {\n            if (a !== s) throw new sn(\"side location conflict\", i.getCoordinate());\n            o === L.NONE && f.shouldNeverReachHere(\"found single null side (at \" + i.getCoordinate() + \")\"), s = o;\n          } else f.isTrue(r.getLocation(t, cn.LEFT) === L.NONE, \"found single null side\"), r.setLocation(t, cn.RIGHT, s), r.setLocation(t, cn.LEFT, s);\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      var t = this.iterator();\n      if (!t.hasNext()) return null;\n      var e = t.next();\n      return e.getCoordinate();\n    },\n    print: function print(t) {\n      A.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.print(t);\n      }\n    },\n    isAreaLabelsConsistent: function isAreaLabelsConsistent(t) {\n      return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);\n    },\n    checkAreaLabelsConsistent: function checkAreaLabelsConsistent(t) {\n      var e = this.getEdges();\n      if (e.size() <= 0) return !0;\n      var n = e.size() - 1,\n          i = e.get(n).getLabel(),\n          r = i.getLocation(t, cn.LEFT);\n      f.isTrue(r !== L.NONE, \"Found unlabelled area edge\");\n\n      for (var s = r, o = this.iterator(); o.hasNext();) {\n        var a = o.next(),\n            u = a.getLabel();\n        f.isTrue(u.isArea(t), \"Found non-area edge\");\n        var l = u.getLocation(t, cn.LEFT),\n            h = u.getLocation(t, cn.RIGHT);\n        if (l === h) return !1;\n        if (h !== s) return !1;\n        s = l;\n      }\n\n      return !0;\n    },\n    findIndex: function findIndex(t) {\n      this.iterator();\n\n      for (var e = 0; e < this.edgeList.size(); e++) {\n        var n = this.edgeList.get(e);\n        if (n === t) return e;\n      }\n\n      return -1;\n    },\n    iterator: function iterator() {\n      return this.getEdges().iterator();\n    },\n    getEdges: function getEdges() {\n      return null === this.edgeList && (this.edgeList = new I(this.edgeMap.values())), this.edgeList;\n    },\n    getLocation: function getLocation(t, e, n) {\n      return this.ptInAreaLocation[t] === L.NONE && (this.ptInAreaLocation[t] = Tn.locate(e, n[t].getGeometry())), this.ptInAreaLocation[t];\n    },\n    toString: function toString() {\n      var t = new P();\n      t.append(\"EdgeEndStar:   \" + this.getCoordinate()), t.append(\"\\n\");\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        t.append(n), t.append(\"\\n\");\n      }\n\n      return t.toString();\n    },\n    computeEdgeEndLabels: function computeEdgeEndLabels(t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.computeLabel(t);\n      }\n    },\n    computeLabelling: function computeLabelling(t) {\n      this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);\n\n      for (var e = [!1, !1], n = this.iterator(); n.hasNext();) {\n        for (var i = n.next(), r = i.getLabel(), s = 0; 2 > s; s++) {\n          r.isLine(s) && r.getLocation(s) === L.BOUNDARY && (e[s] = !0);\n        }\n      }\n\n      for (var n = this.iterator(); n.hasNext();) {\n        for (var i = n.next(), r = i.getLabel(), s = 0; 2 > s; s++) {\n          if (r.isAnyNull(s)) {\n            var o = L.NONE;\n            if (e[s]) o = L.EXTERIOR;else {\n              var a = i.getCoordinate();\n              o = this.getLocation(s, a, t);\n            }\n            r.setAllLocationsIfNull(s, o);\n          }\n        }\n      }\n    },\n    getDegree: function getDegree() {\n      return this.edgeMap.size();\n    },\n    insertEdgeEnd: function insertEdgeEnd(t, e) {\n      this.edgeMap.put(t, e), this.edgeList = null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Pn;\n    }\n  }), h(bn, Pn), e(bn.prototype, {\n    linkResultDirectedEdges: function linkResultDirectedEdges() {\n      this.getResultAreaEdges();\n\n      for (var t = null, e = null, n = this.SCANNING_FOR_INCOMING, i = 0; i < this.resultAreaEdgeList.size(); i++) {\n        var r = this.resultAreaEdgeList.get(i),\n            s = r.getSym();\n        if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {\n          case this.SCANNING_FOR_INCOMING:\n            if (!s.isInResult()) continue;\n            e = s, n = this.LINKING_TO_OUTGOING;\n            break;\n\n          case this.LINKING_TO_OUTGOING:\n            if (!r.isInResult()) continue;\n            e.setNext(r), n = this.SCANNING_FOR_INCOMING;\n        }\n      }\n\n      if (n === this.LINKING_TO_OUTGOING) {\n        if (null === t) throw new sn(\"no outgoing dirEdge found\", this.getCoordinate());\n        f.isTrue(t.isInResult(), \"unable to link last incoming dirEdge\"), e.setNext(t);\n      }\n    },\n    insert: function insert(t) {\n      var e = t;\n      this.insertEdgeEnd(e, e);\n    },\n    getRightmostEdge: function getRightmostEdge() {\n      var t = this.getEdges(),\n          e = t.size();\n      if (1 > e) return null;\n      var n = t.get(0);\n      if (1 === e) return n;\n      var i = t.get(e - 1),\n          r = n.getQuadrant(),\n          s = i.getQuadrant();\n      if (Je.isNorthern(r) && Je.isNorthern(s)) return n;\n      if (!Je.isNorthern(r) && !Je.isNorthern(s)) return i;\n      return 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (f.shouldNeverReachHere(\"found two horizontal edges incident on node\"), null);\n    },\n    print: function print(t) {\n      A.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        t.print(\"out \"), n.print(t), t.println(), t.print(\"in \"), n.getSym().print(t), t.println();\n      }\n    },\n    getResultAreaEdges: function getResultAreaEdges() {\n      if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;\n      this.resultAreaEdgeList = new I();\n\n      for (var t = this.iterator(); t.hasNext();) {\n        var e = t.next();\n        (e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e);\n      }\n\n      return this.resultAreaEdgeList;\n    },\n    updateLabelling: function updateLabelling(t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getLabel();\n        i.setAllLocationsIfNull(0, t.getLocation(0)), i.setAllLocationsIfNull(1, t.getLocation(1));\n      }\n    },\n    linkAllDirectedEdges: function linkAllDirectedEdges() {\n      this.getEdges();\n\n      for (var t = null, e = null, n = this.edgeList.size() - 1; n >= 0; n--) {\n        var i = this.edgeList.get(n),\n            r = i.getSym();\n        null === e && (e = r), null !== t && r.setNext(t), t = i;\n      }\n\n      e.setNext(t);\n    },\n    computeDepths: function computeDepths() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this.findIndex(t),\n            n = (t.getLabel(), t.getDepth(cn.LEFT)),\n            i = t.getDepth(cn.RIGHT),\n            r = this.computeDepths(e + 1, this.edgeList.size(), n),\n            s = this.computeDepths(0, e, r);\n        if (s !== i) throw new sn(\"depth mismatch at \" + t.getCoordinate());\n      } else if (3 === arguments.length) {\n        for (var o = arguments[0], a = arguments[1], u = arguments[2], l = u, h = o; a > h; h++) {\n          var c = this.edgeList.get(h);\n          c.getLabel();\n          c.setEdgeDepths(cn.RIGHT, l), l = c.getDepth(cn.LEFT);\n        }\n\n        return l;\n      }\n    },\n    mergeSymLabels: function mergeSymLabels() {\n      for (var t = this.iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getLabel();\n        n.merge(e.getSym().getLabel());\n      }\n    },\n    linkMinimalDirectedEdges: function linkMinimalDirectedEdges(t) {\n      for (var e = null, n = null, i = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {\n        var s = this.resultAreaEdgeList.get(r),\n            o = s.getSym();\n\n        switch (null === e && s.getEdgeRing() === t && (e = s), i) {\n          case this.SCANNING_FOR_INCOMING:\n            if (o.getEdgeRing() !== t) continue;\n            n = o, i = this.LINKING_TO_OUTGOING;\n            break;\n\n          case this.LINKING_TO_OUTGOING:\n            if (s.getEdgeRing() !== t) continue;\n            n.setNextMin(s), i = this.SCANNING_FOR_INCOMING;\n        }\n      }\n\n      i === this.LINKING_TO_OUTGOING && (f.isTrue(null !== e, \"found null for first outgoing dirEdge\"), f.isTrue(e.getEdgeRing() === t, \"unable to link last incoming dirEdge\"), n.setNextMin(e));\n    },\n    getOutgoingDegree: function getOutgoingDegree() {\n      if (0 === arguments.length) {\n        for (var t = 0, e = this.iterator(); e.hasNext();) {\n          var n = e.next();\n          n.isInResult() && t++;\n        }\n\n        return t;\n      }\n\n      if (1 === arguments.length) {\n        for (var i = arguments[0], t = 0, e = this.iterator(); e.hasNext();) {\n          var n = e.next();\n          n.getEdgeRing() === i && t++;\n        }\n\n        return t;\n      }\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    findCoveredLineEdges: function findCoveredLineEdges() {\n      for (var t = L.NONE, e = this.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getSym();\n\n        if (!n.isLineEdge()) {\n          if (n.isInResult()) {\n            t = L.INTERIOR;\n            break;\n          }\n\n          if (i.isInResult()) {\n            t = L.EXTERIOR;\n            break;\n          }\n        }\n      }\n\n      if (t === L.NONE) return null;\n\n      for (var r = t, e = this.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getSym();\n        n.isLineEdge() ? n.getEdge().setCovered(r === L.INTERIOR) : (n.isInResult() && (r = L.EXTERIOR), i.isInResult() && (r = L.INTERIOR));\n      }\n    },\n    computeLabelling: function computeLabelling(t) {\n      Pn.prototype.computeLabelling.call(this, t), this.label = new gn(L.NONE);\n\n      for (var e = this.iterator(); e.hasNext();) {\n        for (var n = e.next(), i = n.getEdge(), r = i.getLabel(), s = 0; 2 > s; s++) {\n          var o = r.getLocation(s);\n          o !== L.INTERIOR && o !== L.BOUNDARY || this.label.setLocation(s, L.INTERIOR);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return bn;\n    }\n  }), h(On, Nn), e(On.prototype, {\n    createNode: function createNode(t) {\n      return new yn(t, new bn());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return On;\n    }\n  }), e(_n.prototype, {\n    computeIntersections: function computeIntersections(t, e) {\n      this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return _n;\n    }\n  }), e(Mn.prototype, {\n    isDelete: function isDelete() {\n      return this.eventType === Mn.DELETE;\n    },\n    setDeleteEventIndex: function setDeleteEventIndex(t) {\n      this.deleteEventIndex = t;\n    },\n    getObject: function getObject() {\n      return this.obj;\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0;\n    },\n    getInsertEvent: function getInsertEvent() {\n      return this.insertEvent;\n    },\n    isInsert: function isInsert() {\n      return this.eventType === Mn.INSERT;\n    },\n    isSameLabel: function isSameLabel(t) {\n      return null === this.label ? !1 : this.label === t.label;\n    },\n    getDeleteEventIndex: function getDeleteEventIndex() {\n      return this.deleteEventIndex;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return Mn;\n    }\n  }), Mn.INSERT = 1, Mn.DELETE = 2, e(Dn.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Dn;\n    }\n  }), e(An.prototype, {\n    isTrivialIntersection: function isTrivialIntersection(t, e, n, i) {\n      if (t === n && 1 === this.li.getIntersectionNum()) {\n        if (An.isAdjacentSegments(e, i)) return !0;\n\n        if (t.isClosed()) {\n          var r = t.getNumPoints() - 1;\n          if (0 === e && i === r || 0 === i && e === r) return !0;\n        }\n      }\n\n      return !1;\n    },\n    getProperIntersectionPoint: function getProperIntersectionPoint() {\n      return this.properIntersectionPoint;\n    },\n    setIsDoneIfProperInt: function setIsDoneIfProperInt(t) {\n      this.isDoneWhenProperInt = t;\n    },\n    hasProperInteriorIntersection: function hasProperInteriorIntersection() {\n      return this.hasProperInterior;\n    },\n    isBoundaryPointInternal: function isBoundaryPointInternal(t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getCoordinate();\n        if (t.isIntersection(r)) return !0;\n      }\n\n      return !1;\n    },\n    hasProperIntersection: function hasProperIntersection() {\n      return this.hasProper;\n    },\n    hasIntersection: function hasIntersection() {\n      return this._hasIntersection;\n    },\n    isDone: function isDone() {\n      return this._isDone;\n    },\n    isBoundaryPoint: function isBoundaryPoint(t, e) {\n      return null === e ? !1 : this.isBoundaryPointInternal(t, e[0]) ? !0 : !!this.isBoundaryPointInternal(t, e[1]);\n    },\n    setBoundaryNodes: function setBoundaryNodes(t, e) {\n      this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t, this.bdyNodes[1] = e;\n    },\n    addIntersections: function addIntersections(t, e, n, i) {\n      if (t === n && e === i) return null;\n      this.numTests++;\n      var r = t.getCoordinates()[e],\n          s = t.getCoordinates()[e + 1],\n          o = n.getCoordinates()[i],\n          a = n.getCoordinates()[i + 1];\n      this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return An;\n    }\n  }), An.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  }, h(Fn, Dn), e(Fn.prototype, {\n    prepareEvents: function prepareEvents() {\n      ho.sort(this.events);\n\n      for (var t = 0; t < this.events.size(); t++) {\n        var e = this.events.get(t);\n        e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t);\n      }\n    },\n    computeIntersections: function computeIntersections() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        this.nOverlaps = 0, this.prepareEvents();\n\n        for (var e = 0; e < this.events.size(); e++) {\n          var n = this.events.get(e);\n          if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break;\n        }\n      } else if (3 === arguments.length) if (arguments[2] instanceof An && R(arguments[0], y) && R(arguments[1], y)) {\n        var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n        this.addEdges(i, i), this.addEdges(r, r), this.computeIntersections(s);\n      } else if (\"boolean\" == typeof arguments[2] && R(arguments[0], y) && arguments[1] instanceof An) {\n        var o = arguments[0],\n            a = arguments[1],\n            u = arguments[2];\n        u ? this.addEdges(o, null) : this.addEdges(o), this.computeIntersections(a);\n      }\n    },\n    addEdge: function addEdge(t, e) {\n      for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {\n        var s = new _n(n, r),\n            o = new Mn(e, n.getMinX(r), s);\n        this.events.add(o), this.events.add(new Mn(n.getMaxX(r), o));\n      }\n    },\n    processOverlaps: function processOverlaps(t, e, n, i) {\n      for (var r = n.getObject(), s = t; e > s; s++) {\n        var o = this.events.get(s);\n\n        if (o.isInsert()) {\n          var a = o.getObject();\n          n.isSameLabel(o) || (r.computeIntersections(a, i), this.nOverlaps++);\n        }\n      }\n    },\n    addEdges: function addEdges() {\n      if (1 === arguments.length) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.addEdge(n, n);\n      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], e = i.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.addEdge(n, r);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Fn;\n    }\n  }), e(Gn.prototype, {\n    getMin: function getMin() {\n      return this.min;\n    },\n    intersects: function intersects(t, e) {\n      return !(this.min > e || this.max < t);\n    },\n    getMax: function getMax() {\n      return this.max;\n    },\n    toString: function toString() {\n      return se.toLineString(new g(this.min, 0), new g(this.max, 0));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Gn;\n    }\n  }), e(qn.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e,\n          r = (n.min + n.max) / 2,\n          s = (i.min + i.max) / 2;\n      return s > r ? -1 : r > s ? 1 : 0;\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return qn;\n    }\n  }), Gn.NodeComparator = qn, h(Bn, Gn), e(Bn.prototype, {\n    query: function query(t, e, n) {\n      return this.intersects(t, e) ? void n.visitItem(this.item) : null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Bn;\n    }\n  }), h(zn, Gn), e(zn.prototype, {\n    buildExtent: function buildExtent(t, e) {\n      this.min = Math.min(t.min, e.min), this.max = Math.max(t.max, e.max);\n    },\n    query: function query(t, e, n) {\n      return this.intersects(t, e) ? (null !== this.node1 && this.node1.query(t, e, n), void (null !== this.node2 && this.node2.query(t, e, n))) : null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return zn;\n    }\n  }), e(Vn.prototype, {\n    buildTree: function buildTree() {\n      ho.sort(this.leaves, new IntervalRTreeNode.NodeComparator());\n\n      for (var t = this.leaves, e = null, n = new I();;) {\n        if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);\n        e = t, t = n, n = e;\n      }\n    },\n    insert: function insert(t, e, n) {\n      if (null !== this.root) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n      this.leaves.add(new Bn(t, e, n));\n    },\n    query: function query(t, e, n) {\n      this.init(), this.root.query(t, e, n);\n    },\n    buildRoot: function buildRoot() {\n      return null !== this.root ? null : void (this.root = this.buildTree());\n    },\n    printNode: function printNode(t) {\n      A.out.println(se.toLineString(new g(t.min, this.level), new g(t.max, this.level)));\n    },\n    init: function init() {\n      return null !== this.root ? null : void this.buildRoot();\n    },\n    buildLevel: function buildLevel(t, e) {\n      this.level++, e.clear();\n\n      for (var n = 0; n < t.size(); n += 2) {\n        var i = t.get(n),\n            r = n + 1 < t.size() ? t.get(n) : null;\n        if (null === r) e.add(i);else {\n          var s = new zn(t.get(n), t.get(n + 1));\n          e.add(s);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Vn;\n    }\n  }), e(kn.prototype, {\n    filter: function filter(t) {\n      if (this.isForcedToLineString && t instanceof bt) {\n        var e = t.getFactory().createLineString(t.getCoordinateSequence());\n        return this.lines.add(e), null;\n      }\n\n      t instanceof St && this.lines.add(t);\n    },\n    setForceToLineString: function setForceToLineString(t) {\n      this.isForcedToLineString = t;\n    },\n    interfaces_: function interfaces_() {\n      return [q];\n    },\n    getClass: function getClass() {\n      return kn;\n    }\n  }), kn.getGeometry = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t.getFactory().buildGeometry(kn.getLines(t));\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e.getFactory().buildGeometry(kn.getLines(e, n));\n    }\n  }, kn.getLines = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return kn.getLines(t, !1);\n    }\n\n    if (2 === arguments.length) {\n      if (R(arguments[0], v) && R(arguments[1], v)) {\n        for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {\n          var r = i.next();\n          kn.getLines(r, n);\n        }\n\n        return n;\n      }\n\n      if (arguments[0] instanceof B && \"boolean\" == typeof arguments[1]) {\n        var s = arguments[0],\n            o = arguments[1],\n            a = new I();\n        return s.apply(new kn(a, o)), a;\n      }\n\n      if (arguments[0] instanceof B && R(arguments[1], v)) {\n        var u = arguments[0],\n            l = arguments[1];\n        return u instanceof St ? l.add(u) : u.apply(new kn(l)), l;\n      }\n    } else if (3 === arguments.length) {\n      if (\"boolean\" == typeof arguments[2] && R(arguments[0], v) && R(arguments[1], v)) {\n        for (var h = arguments[0], c = arguments[1], f = arguments[2], i = h.iterator(); i.hasNext();) {\n          var r = i.next();\n          kn.getLines(r, c, f);\n        }\n\n        return c;\n      }\n\n      if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof B && R(arguments[1], v)) {\n        var g = arguments[0],\n            d = arguments[1],\n            p = arguments[2];\n        return g.apply(new kn(d, p)), d;\n      }\n    }\n  }, e(Yn.prototype, {\n    visitItem: function visitItem(t) {\n      this.items.add(t);\n    },\n    getItems: function getItems() {\n      return this.items;\n    },\n    interfaces_: function interfaces_() {\n      return [Ae];\n    },\n    getClass: function getClass() {\n      return Yn;\n    }\n  }), e(Un.prototype, {\n    locate: function locate(t) {\n      var e = new le(t),\n          n = new Xn(e);\n      return this.index.query(t.y, t.y, n), e.getLocation();\n    },\n    interfaces_: function interfaces_() {\n      return [Rn];\n    },\n    getClass: function getClass() {\n      return Un;\n    }\n  }), e(Xn.prototype, {\n    visitItem: function visitItem(t) {\n      var e = t;\n      this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));\n    },\n    interfaces_: function interfaces_() {\n      return [Ae];\n    },\n    getClass: function getClass() {\n      return Xn;\n    }\n  }), e(Hn.prototype, {\n    init: function init(t) {\n      for (var e = kn.getLines(t), n = e.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.getCoordinates();\n        this.addLine(r);\n      }\n    },\n    addLine: function addLine(t) {\n      for (var e = 1; e < t.length; e++) {\n        var n = new ce(t[e - 1], t[e]),\n            i = Math.min(n.p0.y, n.p1.y),\n            r = Math.max(n.p0.y, n.p1.y);\n        this.index.insert(i, r, n);\n      }\n    },\n    query: function query() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1],\n            n = new Yn();\n        return this.index.query(t, e, n), n.getItems();\n      }\n\n      if (3 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n        this.index.query(i, r, s);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Hn;\n    }\n  }), Un.SegmentVisitor = Xn, Un.IntervalIndexedGeometry = Hn, e(Wn.prototype, {\n    getSegmentIndex: function getSegmentIndex() {\n      return this.segmentIndex;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.coord;\n    },\n    print: function print(t) {\n      t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex), t.println(\" dist = \" + this.dist);\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.compare(e.segmentIndex, e.dist);\n    },\n    isEndPoint: function isEndPoint(t) {\n      return 0 === this.segmentIndex && 0 === this.dist ? !0 : this.segmentIndex === t;\n    },\n    toString: function toString() {\n      return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n    },\n    getDistance: function getDistance() {\n      return this.dist;\n    },\n    compare: function compare(t, e) {\n      return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return Wn;\n    }\n  }), e(jn.prototype, {\n    print: function print(t) {\n      t.println(\"Intersections:\");\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.print(t);\n      }\n    },\n    iterator: function iterator() {\n      return this.nodeMap.values().iterator();\n    },\n    addSplitEdges: function addSplitEdges(t) {\n      this.addEndpoints();\n\n      for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n        var i = e.next(),\n            r = this.createSplitEdge(n, i);\n        t.add(r), n = i;\n      }\n    },\n    addEndpoints: function addEndpoints() {\n      var t = this.edge.pts.length - 1;\n      this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);\n    },\n    createSplitEdge: function createSplitEdge(t, e) {\n      var n = e.segmentIndex - t.segmentIndex + 2,\n          i = this.edge.pts[e.segmentIndex],\n          r = e.dist > 0 || !e.coord.equals2D(i);\n      r || n--;\n      var s = new Array(n).fill(null),\n          o = 0;\n      s[o++] = new g(t.coord);\n\n      for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) {\n        s[o++] = this.edge.pts[a];\n      }\n\n      return r && (s[o] = e.coord), new Jn(s, new gn(this.edge.label));\n    },\n    add: function add(t, e, n) {\n      var i = new Wn(t, e, n),\n          r = this.nodeMap.get(i);\n      return null !== r ? r : (this.nodeMap.put(i, i), i);\n    },\n    isIntersection: function isIntersection(t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        if (n.coord.equals(t)) return !0;\n      }\n\n      return !1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return jn;\n    }\n  }), e(Kn.prototype, {\n    getChainStartIndices: function getChainStartIndices(t) {\n      var e = 0,\n          n = new I();\n      n.add(new b(e));\n\n      do {\n        var i = this.findChainEnd(t, e);\n        n.add(new b(i)), e = i;\n      } while (e < t.length - 1);\n\n      var r = Kn.toIntArray(n);\n      return r;\n    },\n    findChainEnd: function findChainEnd(t, e) {\n      for (var n = Je.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {\n        var r = Je.quadrant(t[i - 1], t[i]);\n        if (r !== n) break;\n        i++;\n      }\n\n      return i - 1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Kn;\n    }\n  }), Kn.toIntArray = function (t) {\n    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) {\n      e[n] = t.get(n).intValue();\n    }\n\n    return e;\n  }, e(Zn.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    getMaxX: function getMaxX(t) {\n      var e = this.pts[this.startIndex[t]].x,\n          n = this.pts[this.startIndex[t + 1]].x;\n      return e > n ? e : n;\n    },\n    getMinX: function getMinX(t) {\n      var e = this.pts[this.startIndex[t]].x,\n          n = this.pts[this.startIndex[t + 1]].x;\n      return n > e ? e : n;\n    },\n    computeIntersectsForChain: function computeIntersectsForChain() {\n      if (4 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n        this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);\n      } else if (6 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2],\n            a = arguments[3],\n            u = arguments[4],\n            l = arguments[5],\n            h = this.pts[r],\n            c = this.pts[s],\n            f = o.pts[a],\n            g = o.pts[u];\n        if (s - r === 1 && u - a === 1) return l.addIntersections(this.e, r, o.e, a), null;\n        if (this.env1.init(h, c), this.env2.init(f, g), !this.env1.intersects(this.env2)) return null;\n        var d = Math.trunc((r + s) / 2),\n            p = Math.trunc((a + u) / 2);\n        d > r && (p > a && this.computeIntersectsForChain(r, d, o, a, p, l), u > p && this.computeIntersectsForChain(r, d, o, p, u, l)), s > d && (p > a && this.computeIntersectsForChain(d, s, o, a, p, l), u > p && this.computeIntersectsForChain(d, s, o, p, u, l));\n      }\n    },\n    getStartIndexes: function getStartIndexes() {\n      return this.startIndex;\n    },\n    computeIntersects: function computeIntersects(t, e) {\n      for (var n = 0; n < this.startIndex.length - 1; n++) {\n        for (var i = 0; i < t.startIndex.length - 1; i++) {\n          this.computeIntersectsForChain(n, t, i, e);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Zn;\n    }\n  }), e(Qn.prototype, {\n    getDepth: function getDepth(t, e) {\n      return this.depth[t][e];\n    },\n    setDepth: function setDepth(t, e, n) {\n      this.depth[t][e] = n;\n    },\n    isNull: function isNull() {\n      if (0 === arguments.length) {\n        for (var t = 0; 2 > t; t++) {\n          for (var e = 0; 3 > e; e++) {\n            if (this.depth[t][e] !== Qn.NULL_VALUE) return !1;\n          }\n        }\n\n        return !0;\n      }\n\n      if (1 === arguments.length) {\n        var n = arguments[0];\n        return this.depth[n][1] === Qn.NULL_VALUE;\n      }\n\n      if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1];\n        return this.depth[i][r] === Qn.NULL_VALUE;\n      }\n    },\n    normalize: function normalize() {\n      for (var t = 0; 2 > t; t++) {\n        if (!this.isNull(t)) {\n          var e = this.depth[t][1];\n          this.depth[t][2] < e && (e = this.depth[t][2]), 0 > e && (e = 0);\n\n          for (var n = 1; 3 > n; n++) {\n            var i = 0;\n            this.depth[t][n] > e && (i = 1), this.depth[t][n] = i;\n          }\n        }\n      }\n    },\n    getDelta: function getDelta(t) {\n      return this.depth[t][cn.RIGHT] - this.depth[t][cn.LEFT];\n    },\n    getLocation: function getLocation(t, e) {\n      return this.depth[t][e] <= 0 ? L.EXTERIOR : L.INTERIOR;\n    },\n    toString: function toString() {\n      return \"A: \" + this.depth[0][1] + \",\" + this.depth[0][2] + \" B: \" + this.depth[1][1] + \",\" + this.depth[1][2];\n    },\n    add: function add() {\n      if (1 === arguments.length) for (var t = arguments[0], e = 0; 2 > e; e++) {\n        for (var n = 1; 3 > n; n++) {\n          var i = t.getLocation(e, n);\n          i !== L.EXTERIOR && i !== L.INTERIOR || (this.isNull(e, n) ? this.depth[e][n] = Qn.depthAtLocation(i) : this.depth[e][n] += Qn.depthAtLocation(i));\n        }\n      } else if (3 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2];\n        o === L.INTERIOR && this.depth[r][s]++;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Qn;\n    }\n  }), Qn.depthAtLocation = function (t) {\n    return t === L.EXTERIOR ? 0 : t === L.INTERIOR ? 1 : Qn.NULL_VALUE;\n  }, Qn.NULL_VALUE = -1, h(Jn, mn), e(Jn.prototype, {\n    getDepth: function getDepth() {\n      return this.depth;\n    },\n    getCollapsedEdge: function getCollapsedEdge() {\n      var t = new Array(2).fill(null);\n      t[0] = this.pts[0], t[1] = this.pts[1];\n      var e = new Jn(t, gn.toLineLabel(this.label));\n      return e;\n    },\n    isIsolated: function isIsolated() {\n      return this._isIsolated;\n    },\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    setIsolated: function setIsolated(t) {\n      this._isIsolated = t;\n    },\n    setName: function setName(t) {\n      this.name = t;\n    },\n    equals: function equals(t) {\n      if (!(t instanceof Jn)) return !1;\n      var e = t;\n      if (this.pts.length !== e.pts.length) return !1;\n\n      for (var n = !0, i = !0, r = this.pts.length, s = 0; s < this.pts.length; s++) {\n        if (this.pts[s].equals2D(e.pts[s]) || (n = !1), this.pts[s].equals2D(e.pts[--r]) || (i = !1), !n && !i) return !1;\n      }\n\n      return !0;\n    },\n    getCoordinate: function getCoordinate() {\n      if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.pts[t];\n      }\n    },\n    print: function print(t) {\n      t.print(\"edge \" + this.name + \": \"), t.print(\"LINESTRING (\");\n\n      for (var e = 0; e < this.pts.length; e++) {\n        e > 0 && t.print(\",\"), t.print(this.pts[e].x + \" \" + this.pts[e].y);\n      }\n\n      t.print(\")  \" + this.label + \" \" + this.depthDelta);\n    },\n    computeIM: function computeIM(t) {\n      Jn.updateIM(this.label, t);\n    },\n    isCollapsed: function isCollapsed() {\n      return this.label.isArea() ? 3 !== this.pts.length ? !1 : !!this.pts[0].equals(this.pts[2]) : !1;\n    },\n    isClosed: function isClosed() {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    },\n    getMaximumSegmentIndex: function getMaximumSegmentIndex() {\n      return this.pts.length - 1;\n    },\n    getDepthDelta: function getDepthDelta() {\n      return this.depthDelta;\n    },\n    getNumPoints: function getNumPoints() {\n      return this.pts.length;\n    },\n    printReverse: function printReverse(t) {\n      t.print(\"edge \" + this.name + \": \");\n\n      for (var e = this.pts.length - 1; e >= 0; e--) {\n        t.print(this.pts[e] + \" \");\n      }\n\n      t.println(\"\");\n    },\n    getMonotoneChainEdge: function getMonotoneChainEdge() {\n      return null === this.mce && (this.mce = new Zn(this)), this.mce;\n    },\n    getEnvelope: function getEnvelope() {\n      if (null === this.env) {\n        this.env = new C();\n\n        for (var t = 0; t < this.pts.length; t++) {\n          this.env.expandToInclude(this.pts[t]);\n        }\n      }\n\n      return this.env;\n    },\n    addIntersection: function addIntersection(t, e, n, i) {\n      var r = new g(t.getIntersection(i)),\n          s = e,\n          o = t.getEdgeDistance(n, i),\n          a = s + 1;\n\n      if (a < this.pts.length) {\n        var u = this.pts[a];\n        r.equals2D(u) && (s = a, o = 0);\n      }\n\n      this.eiList.add(r, s, o);\n    },\n    toString: function toString() {\n      var t = new P();\n      t.append(\"edge \" + this.name + \": \"), t.append(\"LINESTRING (\");\n\n      for (var e = 0; e < this.pts.length; e++) {\n        e > 0 && t.append(\",\"), t.append(this.pts[e].x + \" \" + this.pts[e].y);\n      }\n\n      return t.append(\")  \" + this.label + \" \" + this.depthDelta), t.toString();\n    },\n    isPointwiseEqual: function isPointwiseEqual(t) {\n      if (this.pts.length !== t.pts.length) return !1;\n\n      for (var e = 0; e < this.pts.length; e++) {\n        if (!this.pts[e].equals2D(t.pts[e])) return !1;\n      }\n\n      return !0;\n    },\n    setDepthDelta: function setDepthDelta(t) {\n      this.depthDelta = t;\n    },\n    getEdgeIntersectionList: function getEdgeIntersectionList() {\n      return this.eiList;\n    },\n    addIntersections: function addIntersections(t, e, n) {\n      for (var i = 0; i < t.getIntersectionNum(); i++) {\n        this.addIntersection(t, e, n, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Jn;\n    }\n  }), Jn.updateIM = function () {\n    if (2 !== arguments.length) return mn.prototype.updateIM.apply(this, arguments);\n    var t = arguments[0],\n        e = arguments[1];\n    e.setAtLeastIfValid(t.getLocation(0, cn.ON), t.getLocation(1, cn.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, cn.LEFT), t.getLocation(1, cn.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, cn.RIGHT), t.getLocation(1, cn.RIGHT), 2));\n  }, h($n, Cn), e($n.prototype, {\n    insertBoundaryPoint: function insertBoundaryPoint(t, e) {\n      var n = this.nodes.addNode(e),\n          i = n.getLabel(),\n          r = 1,\n          s = L.NONE;\n      s = i.getLocation(t, cn.ON), s === L.BOUNDARY && r++;\n      var o = $n.determineBoundary(this.boundaryNodeRule, r);\n      i.setLocation(t, o);\n    },\n    computeSelfNodes: function computeSelfNodes() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this.computeSelfNodes(t, e, !1);\n      }\n\n      if (3 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = arguments[2],\n            s = new An(n, !0, !1);\n        s.setIsDoneIfProperInt(r);\n        var o = this.createEdgeSetIntersector(),\n            a = this.parentGeom instanceof bt || this.parentGeom instanceof Tt || this.parentGeom instanceof Ot,\n            u = i || !a;\n        return o.computeIntersections(this.edges, s, u), this.addSelfIntersectionNodes(this.argIndex), s;\n      }\n    },\n    computeSplitEdges: function computeSplitEdges(t) {\n      for (var e = this.edges.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.eiList.addSplitEdges(t);\n      }\n    },\n    computeEdgeIntersections: function computeEdgeIntersections(t, e, n) {\n      var i = new An(e, n, !0);\n      i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());\n      var r = this.createEdgeSetIntersector();\n      return r.computeIntersections(this.edges, t.edges, i), i;\n    },\n    getGeometry: function getGeometry() {\n      return this.parentGeom;\n    },\n    getBoundaryNodeRule: function getBoundaryNodeRule() {\n      return this.boundaryNodeRule;\n    },\n    hasTooFewPoints: function hasTooFewPoints() {\n      return this._hasTooFewPoints;\n    },\n    addPoint: function addPoint() {\n      if (arguments[0] instanceof Lt) {\n        var t = arguments[0],\n            e = t.getCoordinate();\n        this.insertPoint(this.argIndex, e, L.INTERIOR);\n      } else if (arguments[0] instanceof g) {\n        var n = arguments[0];\n        this.insertPoint(this.argIndex, n, L.INTERIOR);\n      }\n    },\n    addPolygon: function addPolygon(t) {\n      this.addPolygonRing(t.getExteriorRing(), L.EXTERIOR, L.INTERIOR);\n\n      for (var e = 0; e < t.getNumInteriorRing(); e++) {\n        var n = t.getInteriorRingN(e);\n        this.addPolygonRing(n, L.INTERIOR, L.EXTERIOR);\n      }\n    },\n    addEdge: function addEdge(t) {\n      this.insertEdge(t);\n      var e = t.getCoordinates();\n      this.insertPoint(this.argIndex, e[0], L.BOUNDARY), this.insertPoint(this.argIndex, e[e.length - 1], L.BOUNDARY);\n    },\n    addLineString: function addLineString(t) {\n      var e = H.removeRepeatedPoints(t.getCoordinates());\n      if (e.length < 2) return this._hasTooFewPoints = !0, this.invalidPoint = e[0], null;\n      var n = new Jn(e, new gn(this.argIndex, L.INTERIOR));\n      this.lineEdgeMap.put(t, n), this.insertEdge(n), f.isTrue(e.length >= 2, \"found LineString with single point\"), this.insertBoundaryPoint(this.argIndex, e[0]), this.insertBoundaryPoint(this.argIndex, e[e.length - 1]);\n    },\n    getInvalidPoint: function getInvalidPoint() {\n      return this.invalidPoint;\n    },\n    getBoundaryPoints: function getBoundaryPoints() {\n      for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        e[n++] = r.getCoordinate().copy();\n      }\n\n      return e;\n    },\n    getBoundaryNodes: function getBoundaryNodes() {\n      return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes;\n    },\n    addSelfIntersectionNode: function addSelfIntersectionNode(t, e, n) {\n      return this.isBoundaryNode(t, e) ? null : void (n === L.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n));\n    },\n    addPolygonRing: function addPolygonRing(t, e, n) {\n      if (t.isEmpty()) return null;\n      var i = H.removeRepeatedPoints(t.getCoordinates());\n      if (i.length < 4) return this._hasTooFewPoints = !0, this.invalidPoint = i[0], null;\n      var r = e,\n          s = n;\n      he.isCCW(i) && (r = n, s = e);\n      var o = new Jn(i, new gn(this.argIndex, L.BOUNDARY, r, s));\n      this.lineEdgeMap.put(t, o), this.insertEdge(o), this.insertPoint(this.argIndex, i[0], L.BOUNDARY);\n    },\n    insertPoint: function insertPoint(t, e, n) {\n      var i = this.nodes.addNode(e),\n          r = i.getLabel();\n      null === r ? i.label = new gn(t, n) : r.setLocation(t, n);\n    },\n    createEdgeSetIntersector: function createEdgeSetIntersector() {\n      return new Fn();\n    },\n    addSelfIntersectionNodes: function addSelfIntersectionNodes(t) {\n      for (var e = this.edges.iterator(); e.hasNext();) {\n        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext();) {\n          var s = r.next();\n          this.addSelfIntersectionNode(t, s.coord, i);\n        }\n      }\n    },\n    add: function add() {\n      if (1 !== arguments.length) return Cn.prototype.add.apply(this, arguments);\n      var t = arguments[0];\n      if (t.isEmpty()) return null;\n      if (t instanceof Ot && (this.useBoundaryDeterminationRule = !1), t instanceof Tt) this.addPolygon(t);else if (t instanceof St) this.addLineString(t);else if (t instanceof Lt) this.addPoint(t);else if (t instanceof Pt) this.addCollection(t);else if (t instanceof gt) this.addCollection(t);else if (t instanceof Ot) this.addCollection(t);else {\n        if (!(t instanceof ft)) throw new UnsupportedOperationException(t.getClass().getName());\n        this.addCollection(t);\n      }\n    },\n    addCollection: function addCollection(t) {\n      for (var e = 0; e < t.getNumGeometries(); e++) {\n        var n = t.getGeometryN(e);\n        this.add(n);\n      }\n    },\n    locate: function locate(t) {\n      return R(this.parentGeom, Rt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new Un(this.parentGeom)), this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom);\n    },\n    findEdge: function findEdge() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.lineEdgeMap.get(t);\n      }\n\n      return Cn.prototype.findEdge.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return $n;\n    }\n  }), $n.determineBoundary = function (t, e) {\n    return t.isInBoundary(e) ? L.BOUNDARY : L.INTERIOR;\n  }, e(ti.prototype, {\n    getArgGeometry: function getArgGeometry(t) {\n      return this.arg[t].getGeometry();\n    },\n    setComputationPrecision: function setComputationPrecision(t) {\n      this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ti;\n    }\n  }), e(ei.prototype, {\n    compareTo: function compareTo(t) {\n      var e = t,\n          n = ei.compareOriented(this.pts, this._orientation, e.pts, e._orientation);\n      return n;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return ei;\n    }\n  }), ei.orientation = function (t) {\n    return 1 === H.increasingDirection(t);\n  }, ei.compareOriented = function (t, e, n, i) {\n    for (var r = e ? 1 : -1, s = i ? 1 : -1, o = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {\n      var h = t[u].compareTo(n[l]);\n      if (0 !== h) return h;\n      u += r, l += s;\n      var c = u === o,\n          f = l === a;\n      if (c && !f) return -1;\n      if (!c && f) return 1;\n      if (c && f) return 0;\n    }\n  }, e(ni.prototype, {\n    print: function print(t) {\n      t.print(\"MULTILINESTRING ( \");\n\n      for (var e = 0; e < this.edges.size(); e++) {\n        var n = this.edges.get(e);\n        e > 0 && t.print(\",\"), t.print(\"(\");\n\n        for (var i = n.getCoordinates(), r = 0; r < i.length; r++) {\n          r > 0 && t.print(\",\"), t.print(i[r].x + \" \" + i[r].y);\n        }\n\n        t.println(\")\");\n      }\n\n      t.print(\")  \");\n    },\n    addAll: function addAll(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        this.add(e.next());\n      }\n    },\n    findEdgeIndex: function findEdgeIndex(t) {\n      for (var e = 0; e < this.edges.size(); e++) {\n        if (this.edges.get(e).equals(t)) return e;\n      }\n\n      return -1;\n    },\n    iterator: function iterator() {\n      return this.edges.iterator();\n    },\n    getEdges: function getEdges() {\n      return this.edges;\n    },\n    get: function get(t) {\n      return this.edges.get(t);\n    },\n    findEqualEdge: function findEqualEdge(t) {\n      var e = new ei(t.getCoordinates()),\n          n = this.ocaMap.get(e);\n      return n;\n    },\n    add: function add(t) {\n      this.edges.add(t);\n      var e = new ei(t.getCoordinates());\n      this.ocaMap.put(e, t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ni;\n    }\n  }), h(ii, ti), e(ii.prototype, {\n    insertUniqueEdge: function insertUniqueEdge(t) {\n      var e = this.edgeList.findEqualEdge(t);\n\n      if (null !== e) {\n        var n = e.getLabel(),\n            i = t.getLabel();\n        e.isPointwiseEqual(t) || (i = new gn(t.getLabel()), i.flip());\n        var r = e.getDepth();\n        r.isNull() && r.add(n), r.add(i), n.merge(i);\n      } else this.edgeList.add(t);\n    },\n    getGraph: function getGraph() {\n      return this.graph;\n    },\n    cancelDuplicateResultEdges: function cancelDuplicateResultEdges() {\n      for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getSym();\n        e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1));\n      }\n    },\n    isCoveredByLA: function isCoveredByLA(t) {\n      return this.isCovered(t, this.resultLineList) ? !0 : !!this.isCovered(t, this.resultPolyList);\n    },\n    computeGeometry: function computeGeometry(t, e, n, i) {\n      var r = new I();\n      return r.addAll(t), r.addAll(e), r.addAll(n), r.isEmpty() ? ii.createEmptyResult(i, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r);\n    },\n    mergeSymLabels: function mergeSymLabels() {\n      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().mergeSymLabels();\n      }\n    },\n    isCovered: function isCovered(t, e) {\n      for (var n = e.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = this.ptLocator.locate(t, i);\n        if (r !== L.EXTERIOR) return !0;\n      }\n\n      return !1;\n    },\n    replaceCollapsedEdges: function replaceCollapsedEdges() {\n      for (var t = new I(), e = this.edgeList.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()));\n      }\n\n      this.edgeList.addAll(t);\n    },\n    updateNodeLabelling: function updateNodeLabelling() {\n      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getEdges().getLabel();\n        e.getLabel().merge(n);\n      }\n    },\n    getResultGeometry: function getResultGeometry(t) {\n      return this.computeOverlay(t), this.resultGeom;\n    },\n    insertUniqueEdges: function insertUniqueEdges(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.insertUniqueEdge(n);\n      }\n    },\n    computeOverlay: function computeOverlay(t) {\n      this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);\n      var e = new I();\n      this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e);\n      this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), ln.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();\n      var n = new Sn(this.geomFact);\n      n.add(this.graph), this.resultPolyList = n.getPolygons();\n      var i = new wn(this, this.geomFact, this.ptLocator);\n      this.resultLineList = i.build(t);\n      var r = new Ln(this, this.geomFact, this.ptLocator);\n      this.resultPointList = r.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t);\n    },\n    labelIncompleteNode: function labelIncompleteNode(t, e) {\n      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());\n      t.getLabel().setLocation(e, n);\n    },\n    copyPoints: function copyPoints(t) {\n      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {\n        var n = e.next(),\n            i = this.graph.addNode(n.getCoordinate());\n        i.setLabel(t, n.getLabel().getLocation(t));\n      }\n    },\n    findResultAreaEdges: function findResultAreaEdges(t) {\n      for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getLabel();\n        i.isArea() && !n.isInteriorAreaEdge() && ii.isResultOfOp(i.getLocation(0, cn.RIGHT), i.getLocation(1, cn.RIGHT), t) && n.setInResult(!0);\n      }\n    },\n    computeLabelsFromDepths: function computeLabelsFromDepths() {\n      for (var t = this.edgeList.iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getLabel(),\n            i = e.getDepth();\n\n        if (!i.isNull()) {\n          i.normalize();\n\n          for (var r = 0; 2 > r; r++) {\n            n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (f.isTrue(!i.isNull(r, cn.LEFT), \"depth of LEFT side has not been initialized\"), n.setLocation(r, cn.LEFT, i.getLocation(r, cn.LEFT)), f.isTrue(!i.isNull(r, cn.RIGHT), \"depth of RIGHT side has not been initialized\"), n.setLocation(r, cn.RIGHT, i.getLocation(r, cn.RIGHT))));\n          }\n        }\n      }\n    },\n    computeLabelling: function computeLabelling() {\n      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().computeLabelling(this.arg);\n      }\n\n      this.mergeSymLabels(), this.updateNodeLabelling();\n    },\n    labelIncompleteNodes: function labelIncompleteNodes() {\n      for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getLabel();\n        n.isIsolated() && (t++, i.isNull(0) ? this.labelIncompleteNode(n, 0) : this.labelIncompleteNode(n, 1)), n.getEdges().updateLabelling(i);\n      }\n    },\n    isCoveredByA: function isCoveredByA(t) {\n      return !!this.isCovered(t, this.resultPolyList);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ii;\n    }\n  }), ii.overlayOp = function (t, e, n) {\n    var i = new ii(t, e),\n        r = i.getResultGeometry(n);\n    return r;\n  }, ii.intersection = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) return ii.createEmptyResult(ii.INTERSECTION, t, e, t.getFactory());\n\n    if (t.isGeometryCollection()) {\n      var n = e;\n      return hn.map(t, {\n        interfaces_: function interfaces_() {\n          return [MapOp];\n        },\n        map: function map(t) {\n          return t.intersection(n);\n        }\n      });\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.INTERSECTION);\n  }, ii.symDifference = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return ii.createEmptyResult(ii.SYMDIFFERENCE, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.SYMDIFFERENCE);\n  }, ii.resultDimension = function (t, e, n) {\n    var i = e.getDimension(),\n        r = n.getDimension(),\n        s = -1;\n\n    switch (t) {\n      case ii.INTERSECTION:\n        s = Math.min(i, r);\n        break;\n\n      case ii.UNION:\n        s = Math.max(i, r);\n        break;\n\n      case ii.DIFFERENCE:\n        s = i;\n        break;\n\n      case ii.SYMDIFFERENCE:\n        s = Math.max(i, r);\n    }\n\n    return s;\n  }, ii.createEmptyResult = function (t, e, n, i) {\n    var r = null;\n\n    switch (ii.resultDimension(t, e, n)) {\n      case -1:\n        r = i.createGeometryCollection(new Array(0).fill(null));\n        break;\n\n      case 0:\n        r = i.createPoint();\n        break;\n\n      case 1:\n        r = i.createLineString();\n        break;\n\n      case 2:\n        r = i.createPolygon();\n    }\n\n    return r;\n  }, ii.difference = function (t, e) {\n    return t.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.DIFFERENCE));\n  }, ii.isResultOfOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = t.getLocation(0),\n          i = t.getLocation(1);\n      return ii.isResultOfOp(n, i, e);\n    }\n\n    if (3 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2];\n\n      switch (r === L.BOUNDARY && (r = L.INTERIOR), s === L.BOUNDARY && (s = L.INTERIOR), o) {\n        case ii.INTERSECTION:\n          return r === L.INTERIOR && s === L.INTERIOR;\n\n        case ii.UNION:\n          return r === L.INTERIOR || s === L.INTERIOR;\n\n        case ii.DIFFERENCE:\n          return r === L.INTERIOR && s !== L.INTERIOR;\n\n        case ii.SYMDIFFERENCE:\n          return r === L.INTERIOR && s !== L.INTERIOR || r !== L.INTERIOR && s === L.INTERIOR;\n      }\n\n      return !1;\n    }\n  }, ii.INTERSECTION = 1, ii.UNION = 2, ii.DIFFERENCE = 3, ii.SYMDIFFERENCE = 4, e(ri.prototype, {\n    selfSnap: function selfSnap(t) {\n      var e = new Ie(t),\n          n = e.snapTo(t, this.snapTolerance);\n      return n;\n    },\n    removeCommonBits: function removeCommonBits(t) {\n      this.cbr = new Se(), this.cbr.add(t[0]), this.cbr.add(t[1]);\n      var e = new Array(2).fill(null);\n      return e[0] = this.cbr.removeCommonBits(t[0].copy()), e[1] = this.cbr.removeCommonBits(t[1].copy()), e;\n    },\n    prepareResult: function prepareResult(t) {\n      return this.cbr.addCommonBits(t), t;\n    },\n    getResultGeometry: function getResultGeometry(t) {\n      var e = this.snap(this.geom),\n          n = ii.overlayOp(e[0], e[1], t);\n      return this.prepareResult(n);\n    },\n    checkValid: function checkValid(t) {\n      t.isValid() || A.out.println(\"Snapped geometry is invalid\");\n    },\n    computeSnapTolerance: function computeSnapTolerance() {\n      this.snapTolerance = Ie.computeOverlaySnapTolerance(this.geom[0], this.geom[1]);\n    },\n    snap: function snap(t) {\n      var e = this.removeCommonBits(t),\n          n = Ie.snap(e[0], e[1], this.snapTolerance);\n      return n;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ri;\n    }\n  }), ri.overlayOp = function (t, e, n) {\n    var i = new ri(t, e);\n    return i.getResultGeometry(n);\n  }, ri.union = function (t, e) {\n    return ri.overlayOp(t, e, ii.UNION);\n  }, ri.intersection = function (t, e) {\n    return ri.overlayOp(t, e, ii.INTERSECTION);\n  }, ri.symDifference = function (t, e) {\n    return ri.overlayOp(t, e, ii.SYMDIFFERENCE);\n  }, ri.difference = function (t, e) {\n    return ri.overlayOp(t, e, ii.DIFFERENCE);\n  }, e(si.prototype, {\n    getResultGeometry: function getResultGeometry(t) {\n      var e = null,\n          n = !1,\n          i = null;\n\n      try {\n        e = ii.overlayOp(this.geom[0], this.geom[1], t);\n        var r = !0;\n        r && (n = !0);\n      } catch (t) {\n        if (!(t instanceof l)) throw t;\n        i = t;\n      } finally {}\n\n      if (!n) try {\n        e = ri.overlayOp(this.geom[0], this.geom[1], t);\n      } catch (t) {\n        throw t instanceof l ? i : t;\n      } finally {}\n      return e;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return si;\n    }\n  }), si.overlayOp = function (t, e, n) {\n    var i = new si(t, e);\n    return i.getResultGeometry(n);\n  }, si.union = function (t, e) {\n    return si.overlayOp(t, e, ii.UNION);\n  }, si.intersection = function (t, e) {\n    return si.overlayOp(t, e, ii.INTERSECTION);\n  }, si.symDifference = function (t, e) {\n    return si.overlayOp(t, e, ii.SYMDIFFERENCE);\n  }, si.difference = function (t, e) {\n    return si.overlayOp(t, e, ii.DIFFERENCE);\n  }, e(oi.prototype, {\n    addPolygon: function addPolygon(t) {\n      if (t.isEmpty()) return null;\n      var e = null,\n          n = 0,\n          i = this.horizontalBisector(t);\n      if (0 === i.getLength()) n = 0, e = i.getCoordinate();else {\n        var r = si.overlayOp(i, t, ii.INTERSECTION),\n            s = this.widestGeometry(r);\n        n = s.getEnvelopeInternal().getWidth(), e = oi.centre(s.getEnvelopeInternal());\n      }\n      (null === this.interiorPoint || n > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = n);\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      return this.interiorPoint;\n    },\n    widestGeometry: function t() {\n      if (arguments[0] instanceof ft) {\n        var e = arguments[0];\n        if (e.isEmpty()) return e;\n\n        for (var t = e.getGeometryN(0), n = 1; n < e.getNumGeometries(); n++) {\n          e.getGeometryN(n).getEnvelopeInternal().getWidth() > t.getEnvelopeInternal().getWidth() && (t = e.getGeometryN(n));\n        }\n\n        return t;\n      }\n\n      if (arguments[0] instanceof B) {\n        var i = arguments[0];\n        return i instanceof ft ? this.widestGeometry(i) : i;\n      }\n    },\n    horizontalBisector: function horizontalBisector(t) {\n      var e = t.getEnvelopeInternal(),\n          n = ai.getBisectorY(t);\n      return this.factory.createLineString([new g(e.getMinX(), n), new g(e.getMaxX(), n)]);\n    },\n    add: function add(t) {\n      if (t instanceof Tt) this.addPolygon(t);else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {\n        this.add(e.getGeometryN(n));\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return oi;\n    }\n  }), oi.centre = function (t) {\n    return new g(oi.avg(t.getMinX(), t.getMaxX()), oi.avg(t.getMinY(), t.getMaxY()));\n  }, oi.avg = function (t, e) {\n    return (t + e) / 2;\n  }, e(ai.prototype, {\n    updateInterval: function updateInterval(t) {\n      t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t);\n    },\n    getBisectorY: function getBisectorY() {\n      this.process(this.poly.getExteriorRing());\n\n      for (var t = 0; t < this.poly.getNumInteriorRing(); t++) {\n        this.process(this.poly.getInteriorRingN(t));\n      }\n\n      var e = oi.avg(this.hiY, this.loY);\n      return e;\n    },\n    process: function process(t) {\n      for (var e = t.getCoordinateSequence(), n = 0; n < e.size(); n++) {\n        var i = e.getY(n);\n        this.updateInterval(i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ai;\n    }\n  }), ai.getBisectorY = function (t) {\n    var e = new ai(t);\n    return e.getBisectorY();\n  }, oi.SafeBisectorFinder = ai, e(ui.prototype, {\n    addEndpoints: function addEndpoints() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        if (t instanceof St) this.addEndpoints(t.getCoordinates());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {\n          this.addEndpoints(e.getGeometryN(n));\n        }\n      } else if (arguments[0] instanceof Array) {\n        var i = arguments[0];\n        this.add(i[0]), this.add(i[i.length - 1]);\n      }\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      return this.interiorPoint;\n    },\n    addInterior: function addInterior() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        if (t instanceof St) this.addInterior(t.getCoordinates());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {\n          this.addInterior(e.getGeometryN(n));\n        }\n      } else if (arguments[0] instanceof Array) for (var i = arguments[0], n = 1; n < i.length - 1; n++) {\n        this.add(i[n]);\n      }\n    },\n    add: function add(t) {\n      var e = t.distance(this.centroid);\n      e < this.minDistance && (this.interiorPoint = new g(t), this.minDistance = e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ui;\n    }\n  }), e(li.prototype, {\n    getInteriorPoint: function getInteriorPoint() {\n      return this.interiorPoint;\n    },\n    add: function add() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        if (t instanceof Lt) this.add(t.getCoordinate());else if (t instanceof ft) for (var e = t, n = 0; n < e.getNumGeometries(); n++) {\n          this.add(e.getGeometryN(n));\n        }\n      } else if (arguments[0] instanceof g) {\n        var i = arguments[0],\n            r = i.distance(this.centroid);\n        r < this.minDistance && (this.interiorPoint = new g(i), this.minDistance = r);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return li;\n    }\n  }), e(hi.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return hi;\n    }\n  }), hi.toDegrees = function (t) {\n    return 180 * t / Math.PI;\n  }, hi.normalize = function (t) {\n    for (; t > Math.PI;) {\n      t -= hi.PI_TIMES_2;\n    }\n\n    for (; t <= -Math.PI;) {\n      t += hi.PI_TIMES_2;\n    }\n\n    return t;\n  }, hi.angle = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Math.atan2(t.y, t.x);\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1],\n          i = n.x - e.x,\n          r = n.y - e.y;\n      return Math.atan2(r, i);\n    }\n  }, hi.isAcute = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y,\n        s = n.x - e.x,\n        o = n.y - e.y,\n        a = i * s + r * o;\n    return a > 0;\n  }, hi.isObtuse = function (t, e, n) {\n    var i = t.x - e.x,\n        r = t.y - e.y,\n        s = n.x - e.x,\n        o = n.y - e.y,\n        a = i * s + r * o;\n    return 0 > a;\n  }, hi.interiorAngle = function (t, e, n) {\n    var i = hi.angle(e, t),\n        r = hi.angle(e, n);\n    return Math.abs(r - i);\n  }, hi.normalizePositive = function (t) {\n    if (0 > t) {\n      for (; 0 > t;) {\n        t += hi.PI_TIMES_2;\n      }\n\n      t >= hi.PI_TIMES_2 && (t = 0);\n    } else {\n      for (; t >= hi.PI_TIMES_2;) {\n        t -= hi.PI_TIMES_2;\n      }\n\n      0 > t && (t = 0);\n    }\n\n    return t;\n  }, hi.angleBetween = function (t, e, n) {\n    var i = hi.angle(e, t),\n        r = hi.angle(e, n);\n    return hi.diff(i, r);\n  }, hi.diff = function (t, e) {\n    var n = null;\n    return n = e > t ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n;\n  }, hi.toRadians = function (t) {\n    return t * Math.PI / 180;\n  }, hi.getTurn = function (t, e) {\n    var n = Math.sin(e - t);\n    return n > 0 ? hi.COUNTERCLOCKWISE : 0 > n ? hi.CLOCKWISE : hi.NONE;\n  }, hi.angleBetweenOriented = function (t, e, n) {\n    var i = hi.angle(e, t),\n        r = hi.angle(e, n),\n        s = r - i;\n    return s <= -Math.PI ? s + hi.PI_TIMES_2 : s > Math.PI ? s - hi.PI_TIMES_2 : s;\n  }, hi.PI_TIMES_2 = 2 * Math.PI, hi.PI_OVER_2 = Math.PI / 2, hi.PI_OVER_4 = Math.PI / 4, hi.COUNTERCLOCKWISE = he.COUNTERCLOCKWISE, hi.CLOCKWISE = he.CLOCKWISE, hi.NONE = he.COLLINEAR, e(ci.prototype, {\n    area: function area() {\n      return ci.area(this.p0, this.p1, this.p2);\n    },\n    signedArea: function signedArea() {\n      return ci.signedArea(this.p0, this.p1, this.p2);\n    },\n    interpolateZ: function interpolateZ(t) {\n      if (null === t) throw new i(\"Supplied point is null.\");\n      return ci.interpolateZ(t, this.p0, this.p1, this.p2);\n    },\n    longestSideLength: function longestSideLength() {\n      return ci.longestSideLength(this.p0, this.p1, this.p2);\n    },\n    isAcute: function isAcute() {\n      return ci.isAcute(this.p0, this.p1, this.p2);\n    },\n    circumcentre: function circumcentre() {\n      return ci.circumcentre(this.p0, this.p1, this.p2);\n    },\n    area3D: function area3D() {\n      return ci.area3D(this.p0, this.p1, this.p2);\n    },\n    centroid: function centroid() {\n      return ci.centroid(this.p0, this.p1, this.p2);\n    },\n    inCentre: function inCentre() {\n      return ci.inCentre(this.p0, this.p1, this.p2);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ci;\n    }\n  }), ci.area = function (t, e, n) {\n    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);\n  }, ci.signedArea = function (t, e, n) {\n    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;\n  }, ci.det = function (t, e, n, i) {\n    return t * i - e * n;\n  }, ci.interpolateZ = function (t, e, n, i) {\n    var r = e.x,\n        s = e.y,\n        o = n.x - r,\n        a = i.x - r,\n        u = n.y - s,\n        l = i.y - s,\n        h = o * l - a * u,\n        c = t.x - r,\n        f = t.y - s,\n        g = (l * c - a * f) / h,\n        d = (-u * c + o * f) / h,\n        p = e.z + g * (n.z - e.z) + d * (i.z - e.z);\n    return p;\n  }, ci.longestSideLength = function (t, e, n) {\n    var i = t.distance(e),\n        r = e.distance(n),\n        s = n.distance(t),\n        o = i;\n    return r > o && (o = r), s > o && (o = s), o;\n  }, ci.isAcute = function (t, e, n) {\n    return hi.isAcute(t, e, n) && hi.isAcute(e, n, t) ? !!hi.isAcute(n, t, e) : !1;\n  }, ci.circumcentre = function (t, e, n) {\n    var i = n.x,\n        r = n.y,\n        s = t.x - i,\n        o = t.y - r,\n        a = e.x - i,\n        u = e.y - r,\n        l = 2 * ci.det(s, o, a, u),\n        h = ci.det(o, s * s + o * o, u, a * a + u * u),\n        c = ci.det(s, s * s + o * o, a, a * a + u * u),\n        f = i - h / l,\n        d = r + c / l;\n    return new g(f, d);\n  }, ci.perpendicularBisector = function (t, e) {\n    var n = e.x - t.x,\n        i = e.y - t.y,\n        r = new F(t.x + n / 2, t.y + i / 2, 1),\n        s = new F(t.x - i + n / 2, t.y + n + i / 2, 1);\n    return new F(r, s);\n  }, ci.angleBisector = function (t, e, n) {\n    var i = e.distance(t),\n        r = e.distance(n),\n        s = i / (i + r),\n        o = n.x - t.x,\n        a = n.y - t.y,\n        u = new g(t.x + s * o, t.y + s * a);\n    return u;\n  }, ci.area3D = function (t, e, n) {\n    var i = e.x - t.x,\n        r = e.y - t.y,\n        s = e.z - t.z,\n        o = n.x - t.x,\n        a = n.y - t.y,\n        u = n.z - t.z,\n        l = r * u - s * a,\n        h = s * o - i * u,\n        c = i * a - r * o,\n        f = l * l + h * h + c * c,\n        g = Math.sqrt(f) / 2;\n    return g;\n  }, ci.centroid = function (t, e, n) {\n    var i = (t.x + e.x + n.x) / 3,\n        r = (t.y + e.y + n.y) / 3;\n    return new g(i, r);\n  }, ci.inCentre = function (t, e, n) {\n    var i = e.distance(n),\n        r = t.distance(n),\n        s = t.distance(e),\n        o = i + r + s,\n        a = (i * t.x + r * e.x + s * n.x) / o,\n        u = (i * t.y + r * e.y + s * n.y) / o;\n    return new g(a, u);\n  }, e(fi.prototype, {\n    getRadius: function getRadius() {\n      return this.compute(), this.radius;\n    },\n    getDiameter: function getDiameter() {\n      switch (this.compute(), this.extremalPts.length) {\n        case 0:\n          return this.input.getFactory().createLineString();\n\n        case 1:\n          return this.input.getFactory().createPoint(this.centre);\n      }\n\n      var t = this.extremalPts[0],\n          e = this.extremalPts[1];\n      return this.input.getFactory().createLineString([t, e]);\n    },\n    getExtremalPoints: function getExtremalPoints() {\n      return this.compute(), this.extremalPts;\n    },\n    computeCirclePoints: function computeCirclePoints() {\n      if (this.input.isEmpty()) return this.extremalPts = new Array(0).fill(null), null;\n\n      if (1 === this.input.getNumPoints()) {\n        var t = this.input.getCoordinates();\n        return this.extremalPts = [new g(t[0])], null;\n      }\n\n      var e = this.input.convexHull(),\n          n = e.getCoordinates(),\n          t = n;\n      if (n[0].equals2D(n[n.length - 1]) && (t = new Array(n.length - 1).fill(null), H.copyDeep(n, 0, t, 0, n.length - 1)), t.length <= 2) return this.extremalPts = H.copyDeep(t), null;\n\n      for (var i = fi.lowestPoint(t), r = fi.pointWitMinAngleWithX(t, i), s = 0; s < t.length; s++) {\n        var o = fi.pointWithMinAngleWithSegment(t, i, r);\n        if (hi.isObtuse(i, o, r)) return this.extremalPts = [new g(i), new g(r)], null;\n        if (hi.isObtuse(o, i, r)) i = o;else {\n          if (!hi.isObtuse(o, r, i)) return this.extremalPts = [new g(i), new g(r), new g(o)], null;\n          r = o;\n        }\n      }\n\n      f.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n    },\n    compute: function compute() {\n      return null !== this.extremalPts ? null : (this.computeCirclePoints(), this.computeCentre(), void (null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))));\n    },\n    getFarthestPoints: function getFarthestPoints() {\n      switch (this.compute(), this.extremalPts.length) {\n        case 0:\n          return this.input.getFactory().createLineString();\n\n        case 1:\n          return this.input.getFactory().createPoint(this.centre);\n      }\n\n      var t = this.extremalPts[0],\n          e = this.extremalPts[this.extremalPts.length - 1];\n      return this.input.getFactory().createLineString([t, e]);\n    },\n    getCircle: function getCircle() {\n      if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon();\n      var t = this.input.getFactory().createPoint(this.centre);\n      return 0 === this.radius ? t : t.buffer(this.radius);\n    },\n    getCentre: function getCentre() {\n      return this.compute(), this.centre;\n    },\n    computeCentre: function computeCentre() {\n      switch (this.extremalPts.length) {\n        case 0:\n          this.centre = null;\n          break;\n\n        case 1:\n          this.centre = this.extremalPts[0];\n          break;\n\n        case 2:\n          this.centre = new g((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);\n          break;\n\n        case 3:\n          this.centre = ci.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2]);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return fi;\n    }\n  }), fi.pointWitMinAngleWithX = function (t, e) {\n    for (var n = r.MAX_VALUE, i = null, s = 0; s < t.length; s++) {\n      var o = t[s];\n\n      if (o !== e) {\n        var a = o.x - e.x,\n            u = o.y - e.y;\n        0 > u && (u = -u);\n        var l = Math.sqrt(a * a + u * u),\n            h = u / l;\n        n > h && (n = h, i = o);\n      }\n    }\n\n    return i;\n  }, fi.lowestPoint = function (t) {\n    for (var e = t[0], n = 1; n < t.length; n++) {\n      t[n].y < e.y && (e = t[n]);\n    }\n\n    return e;\n  }, fi.pointWithMinAngleWithSegment = function (t, e, n) {\n    for (var i = r.MAX_VALUE, s = null, o = 0; o < t.length; o++) {\n      var a = t[o];\n\n      if (a !== e && a !== n) {\n        var u = hi.angleBetween(e, a, n);\n        i > u && (i = u, s = a);\n      }\n    }\n\n    return s;\n  }, e(gi.prototype, {\n    getWidthCoordinate: function getWidthCoordinate() {\n      return this.computeMinimumDiameter(), this.minWidthPt;\n    },\n    getSupportingSegment: function getSupportingSegment() {\n      return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1]);\n    },\n    getDiameter: function getDiameter() {\n      if (this.computeMinimumDiameter(), null === this.minWidthPt) return this.inputGeom.getFactory().createLineString(null);\n      var t = this.minBaseSeg.project(this.minWidthPt);\n      return this.inputGeom.getFactory().createLineString([t, this.minWidthPt]);\n    },\n    computeWidthConvex: function computeWidthConvex(t) {\n      t instanceof Tt ? this.convexHullPts = t.getExteriorRing().getCoordinates() : this.convexHullPts = t.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts);\n    },\n    computeConvexRingMinDiameter: function computeConvexRingMinDiameter(t) {\n      this.minWidth = r.MAX_VALUE;\n\n      for (var e = 1, n = new ce(), i = 0; i < t.length - 1; i++) {\n        n.p0 = t[i], n.p1 = t[i + 1], e = this.findMaxPerpDistance(t, n, e);\n      }\n    },\n    computeMinimumDiameter: function computeMinimumDiameter() {\n      if (null !== this.minWidthPt) return null;\n      if (this.isConvex) this.computeWidthConvex(this.inputGeom);else {\n        var t = new me(this.inputGeom).getConvexHull();\n        this.computeWidthConvex(t);\n      }\n    },\n    getLength: function getLength() {\n      return this.computeMinimumDiameter(), this.minWidth;\n    },\n    findMaxPerpDistance: function findMaxPerpDistance(t, e, n) {\n      for (var i = e.distancePerpendicular(t[n]), r = i, s = n, o = s; r >= i;) {\n        i = r, s = o, o = gi.nextIndex(t, s), r = e.distancePerpendicular(t[o]);\n      }\n\n      return i < this.minWidth && (this.minPtIndex = s, this.minWidth = i, this.minWidthPt = t[this.minPtIndex], this.minBaseSeg = new ce(e)), s;\n    },\n    getMinimumRectangle: function getMinimumRectangle() {\n      if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());\n\n      for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, n = r.MAX_VALUE, i = -r.MAX_VALUE, s = r.MAX_VALUE, o = -r.MAX_VALUE, a = 0; a < this.convexHullPts.length; a++) {\n        var u = gi.computeC(t, e, this.convexHullPts[a]);\n        u > i && (i = u), n > u && (n = u);\n        var l = gi.computeC(-e, t, this.convexHullPts[a]);\n        l > o && (o = l), s > l && (s = l);\n      }\n\n      var h = gi.computeSegmentForLine(-t, -e, o),\n          c = gi.computeSegmentForLine(-t, -e, s),\n          f = gi.computeSegmentForLine(-e, t, i),\n          g = gi.computeSegmentForLine(-e, t, n),\n          d = f.lineIntersection(h),\n          p = g.lineIntersection(h),\n          v = g.lineIntersection(c),\n          m = f.lineIntersection(c),\n          y = this.inputGeom.getFactory().createLinearRing([d, p, v, m, d]);\n      return this.inputGeom.getFactory().createPolygon(y, null);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return gi;\n    }\n  }), gi.nextIndex = function (t, e) {\n    return e++, e >= t.length && (e = 0), e;\n  }, gi.computeC = function (t, e, n) {\n    return t * n.y - e * n.x;\n  }, gi.getMinimumDiameter = function (t) {\n    return new gi(t).getDiameter();\n  }, gi.getMinimumRectangle = function (t) {\n    return new gi(t).getMinimumRectangle();\n  }, gi.computeSegmentForLine = function (t, e, n) {\n    var i = null,\n        r = null;\n    return Math.abs(e) > Math.abs(t) ? (i = new g(0, n / e), r = new g(1, n / e - t / e)) : (i = new g(n / t, 0), r = new g(n / t - e / t, 1)), new ce(i, r);\n  };\n  var co = Object.freeze({\n    Centroid: ge,\n    CGAlgorithms: he,\n    ConvexHull: me,\n    InteriorPointArea: oi,\n    InteriorPointLine: ui,\n    InteriorPointPoint: li,\n    RobustLineIntersector: ae,\n    MinimumBoundingCircle: fi,\n    MinimumDiameter: gi\n  });\n  e(di.prototype, {\n    getResultGeometry: function getResultGeometry() {\n      return new pi(this.distanceTolerance).transform(this.inputGeom);\n    },\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      if (0 >= t) throw new i(\"Tolerance must be positive\");\n      this.distanceTolerance = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return di;\n    }\n  }), di.densifyPoints = function (t, e, n) {\n    for (var i = new ce(), r = new N(), s = 0; s < t.length - 1; s++) {\n      i.p0 = t[s], i.p1 = t[s + 1], r.add(i.p0, !1);\n      var o = i.getLength(),\n          a = Math.trunc(o / e) + 1;\n      if (a > 1) for (var u = o / a, l = 1; a > l; l++) {\n        var h = l * u / o,\n            c = i.pointAlong(h);\n        n.makePrecise(c), r.add(c, !1);\n      }\n    }\n\n    return r.add(t[t.length - 1], !1), r.toCoordinateArray();\n  }, di.densify = function (t, e) {\n    var n = new di(t);\n    return n.setDistanceTolerance(e), n.getResultGeometry();\n  }, h(pi, xe), e(pi.prototype, {\n    transformMultiPolygon: function transformMultiPolygon(t, e) {\n      var n = xe.prototype.transformMultiPolygon.call(this, t, e);\n      return this.createValidArea(n);\n    },\n    transformPolygon: function transformPolygon(t, e) {\n      var n = xe.prototype.transformPolygon.call(this, t, e);\n      return e instanceof Ot ? n : this.createValidArea(n);\n    },\n    transformCoordinates: function transformCoordinates(t, e) {\n      var n = t.toCoordinateArray(),\n          i = di.densifyPoints(n, this.distanceTolerance, e.getPrecisionModel());\n      return e instanceof St && 1 === i.length && (i = new Array(0).fill(null)), this.factory.getCoordinateSequenceFactory().create(i);\n    },\n    createValidArea: function createValidArea(t) {\n      return t.buffer(0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return pi;\n    }\n  }), di.DensifyTransformer = pi;\n  var fo = Object.freeze({\n    Densifier: di\n  });\n  e(vi.prototype, {\n    find: function find(t) {\n      var e = this;\n\n      do {\n        if (null === e) return null;\n        if (e.dest().equals2D(t)) return e;\n        e = e.oNext();\n      } while (e !== this);\n\n      return null;\n    },\n    dest: function dest() {\n      return this._sym._orig;\n    },\n    oNext: function oNext() {\n      return this._sym._next;\n    },\n    insert: function insert(t) {\n      if (this.oNext() === this) return this.insertAfter(t), null;\n      var e = this.compareTo(t),\n          n = this;\n\n      do {\n        var i = n.oNext(),\n            r = i.compareTo(t);\n        if (r !== e || i === this) return n.insertAfter(t), null;\n        n = i;\n      } while (n !== this);\n\n      f.shouldNeverReachHere();\n    },\n    insertAfter: function insertAfter(t) {\n      f.equals(this._orig, t.orig());\n      var e = this.oNext();\n      this._sym.setNext(t), t.sym().setNext(e);\n    },\n    degree: function t() {\n      var t = 0,\n          e = this;\n\n      do {\n        t++, e = e.oNext();\n      } while (e !== this);\n\n      return t;\n    },\n    equals: function equals() {\n      if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        return this._orig.equals2D(t) && this._sym._orig.equals(e);\n      }\n    },\n    deltaY: function deltaY() {\n      return this._sym._orig.y - this._orig.y;\n    },\n    sym: function sym() {\n      return this._sym;\n    },\n    prev: function prev() {\n      return this._sym.next()._sym;\n    },\n    compareAngularDirection: function compareAngularDirection(t) {\n      var e = this.deltaX(),\n          n = this.deltaY(),\n          i = t.deltaX(),\n          r = t.deltaY();\n      if (e === i && n === r) return 0;\n      var s = Je.quadrant(e, n),\n          o = Je.quadrant(i, r);\n      return s > o ? 1 : o > s ? -1 : he.computeOrientation(t._orig, t.dest(), this.dest());\n    },\n    prevNode: function prevNode() {\n      for (var t = this; 2 === t.degree();) {\n        if (t = t.prev(), t === this) return null;\n      }\n\n      return t;\n    },\n    compareTo: function compareTo(t) {\n      var e = t,\n          n = this.compareAngularDirection(e);\n      return n;\n    },\n    next: function next() {\n      return this._next;\n    },\n    setSym: function setSym(t) {\n      this._sym = t;\n    },\n    orig: function orig() {\n      return this._orig;\n    },\n    toString: function toString() {\n      return \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n    },\n    setNext: function setNext(t) {\n      this._next = t;\n    },\n    init: function init(t) {\n      this.setSym(t), t.setSym(this), this.setNext(t), t.setNext(this);\n    },\n    deltaX: function deltaX() {\n      return this._sym._orig.x - this._orig.x;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return vi;\n    }\n  }), vi.init = function (t, e) {\n    if (null !== t._sym || null !== e._sym || null !== t._next || null !== e._next) throw new IllegalStateException(\"Edges are already initialized\");\n    return t.init(e), t;\n  }, vi.create = function (t, e) {\n    var n = new vi(t),\n        i = new vi(e);\n    return n.init(i), n;\n  }, h(mi, vi), e(mi.prototype, {\n    mark: function mark() {\n      this._isMarked = !0;\n    },\n    setMark: function setMark(t) {\n      this._isMarked = t;\n    },\n    isMarked: function isMarked() {\n      return this._isMarked;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return mi;\n    }\n  }), mi.setMarkBoth = function (t, e) {\n    t.setMark(e), t.sym().setMark(e);\n  }, mi.isMarked = function (t) {\n    return t.isMarked();\n  }, mi.setMark = function (t, e) {\n    t.setMark(e);\n  }, mi.markBoth = function (t) {\n    t.mark(), t.sym().mark();\n  }, mi.mark = function (t) {\n    t.mark();\n  }, e(yi.prototype, {\n    insert: function insert(t, e, n) {\n      var i = this.create(t, e);\n      null !== n ? n.insert(i) : this.vertexMap.put(t, i);\n      var r = this.vertexMap.get(e);\n      return null !== r ? r.insert(i.sym()) : this.vertexMap.put(e, i.sym()), i;\n    },\n    create: function create(t, e) {\n      var n = this.createEdge(t),\n          i = this.createEdge(e);\n      return vi.init(n, i), n;\n    },\n    createEdge: function createEdge(t) {\n      return new vi(t);\n    },\n    addEdge: function addEdge(t, e) {\n      if (!yi.isValidEdge(t, e)) return null;\n      var n = this.vertexMap.get(t),\n          i = null;\n      if (null !== n && (i = n.find(e)), null !== i) return i;\n      var r = this.insert(t, e, n);\n      return r;\n    },\n    getVertexEdges: function getVertexEdges() {\n      return this.vertexMap.values();\n    },\n    findEdge: function findEdge(t, e) {\n      var n = this.vertexMap.get(t);\n      return null === n ? null : n.find(e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return yi;\n    }\n  }), yi.isValidEdge = function (t, e) {\n    var n = e.compareTo(t);\n    return 0 !== n;\n  }, h(xi, mi), e(xi.prototype, {\n    setStart: function setStart() {\n      this._isStart = !0;\n    },\n    isStart: function isStart() {\n      return this._isStart;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return xi;\n    }\n  }), h(Ei, yi), e(Ei.prototype, {\n    createEdge: function createEdge(t) {\n      return new xi(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ei;\n    }\n  }), e(Ii.prototype, {\n    addLine: function addLine(t) {\n      this.lines.add(this.factory.createLineString(t.toCoordinateArray()));\n    },\n    updateRingStartEdge: function updateRingStartEdge(t) {\n      return t.isStart() || (t = t.sym(), t.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = t, null) : void (t.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t)) : null;\n    },\n    getResult: function getResult() {\n      return null === this.result && this.computeResult(), this.result;\n    },\n    process: function process(t) {\n      var e = t.prevNode();\n      null === e && (e = t), this.stackEdges(e), this.buildLines();\n    },\n    buildRing: function buildRing(t) {\n      var e = new N(),\n          n = t;\n\n      for (e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {\n        var i = n.next();\n        if (i === t) break;\n        e.add(i.orig().copy(), !1), n = i;\n      }\n\n      e.add(n.dest().copy(), !1), this.addLine(e);\n    },\n    buildLine: function buildLine(t) {\n      var e = new N(),\n          n = t;\n\n      for (this.ringStartEdge = null, mi.markBoth(n), e.add(n.orig().copy(), !1); 2 === n.sym().degree();) {\n        this.updateRingStartEdge(n);\n        var i = n.next();\n        if (i === t) return this.buildRing(this.ringStartEdge), null;\n        e.add(i.orig().copy(), !1), n = i, mi.markBoth(n);\n      }\n\n      e.add(n.dest().copy(), !1), this.stackEdges(n.sym()), this.addLine(e);\n    },\n    stackEdges: function stackEdges(t) {\n      var e = t;\n\n      do {\n        mi.isMarked(e) || this.nodeEdgeStack.add(e), e = e.oNext();\n      } while (e !== t);\n    },\n    computeResult: function computeResult() {\n      for (var t = this.graph.getVertexEdges(), e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        mi.isMarked(n) || this.process(n);\n      }\n\n      this.result = this.factory.buildGeometry(this.lines);\n    },\n    buildLines: function buildLines() {\n      for (; !this.nodeEdgeStack.empty();) {\n        var t = this.nodeEdgeStack.pop();\n        mi.isMarked(t) || this.buildLine(t);\n      }\n    },\n    add: function add() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        t.apply({\n          interfaces_: function interfaces_() {\n            return [q];\n          },\n          filter: function filter(t) {\n            t instanceof St && this.add(t);\n          }\n        });\n      } else if (R(arguments[0], v)) for (var e = arguments[0], n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        this.add(i);\n      } else if (arguments[0] instanceof St) {\n        var r = arguments[0];\n        null === this.factory && (this.factory = r.getFactory());\n\n        for (var s = r.getCoordinateSequence(), o = !1, n = 1; n < s.size(); n++) {\n          var a = this.graph.addEdge(s.getCoordinate(n - 1), s.getCoordinate(n));\n          null !== a && (o || (a.setStart(), o = !0));\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ii;\n    }\n  }), Ii.dissolve = function (t) {\n    var e = new Ii();\n    return e.add(t), e.getResult();\n  };\n  var go = Object.freeze({\n    LineDissolver: Ii\n  });\n  e(Ni.prototype, {\n    hasChildren: function hasChildren() {\n      for (var t = 0; 4 > t; t++) {\n        if (null !== this.subnode[t]) return !0;\n      }\n\n      return !1;\n    },\n    isPrunable: function isPrunable() {\n      return !(this.hasChildren() || this.hasItems());\n    },\n    addAllItems: function addAllItems(t) {\n      t.addAll(this.items);\n\n      for (var e = 0; 4 > e; e++) {\n        null !== this.subnode[e] && this.subnode[e].addAllItems(t);\n      }\n\n      return t;\n    },\n    getNodeCount: function getNodeCount() {\n      for (var t = 0, e = 0; 4 > e; e++) {\n        null !== this.subnode[e] && (t += this.subnode[e].size());\n      }\n\n      return t + 1;\n    },\n    size: function size() {\n      for (var t = 0, e = 0; 4 > e; e++) {\n        null !== this.subnode[e] && (t += this.subnode[e].size());\n      }\n\n      return t + this.items.size();\n    },\n    addAllItemsFromOverlapping: function addAllItemsFromOverlapping(t, e) {\n      if (!this.isSearchMatch(t)) return null;\n      e.addAll(this.items);\n\n      for (var n = 0; 4 > n; n++) {\n        null !== this.subnode[n] && this.subnode[n].addAllItemsFromOverlapping(t, e);\n      }\n    },\n    visitItems: function visitItems(t, e) {\n      for (var n = this.items.iterator(); n.hasNext();) {\n        e.visitItem(n.next());\n      }\n    },\n    hasItems: function hasItems() {\n      return !this.items.isEmpty();\n    },\n    remove: function remove(t, e) {\n      if (!this.isSearchMatch(t)) return !1;\n\n      for (var n = !1, i = 0; 4 > i; i++) {\n        if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {\n          this.subnode[i].isPrunable() && (this.subnode[i] = null);\n          break;\n        }\n      }\n\n      return n ? n : n = this.items.remove(e);\n    },\n    visit: function visit(t, e) {\n      if (!this.isSearchMatch(t)) return null;\n      this.visitItems(t, e);\n\n      for (var n = 0; 4 > n; n++) {\n        null !== this.subnode[n] && this.subnode[n].visit(t, e);\n      }\n    },\n    getItems: function getItems() {\n      return this.items;\n    },\n    depth: function depth() {\n      for (var t = 0, e = 0; 4 > e; e++) {\n        if (null !== this.subnode[e]) {\n          var n = this.subnode[e].depth();\n          n > t && (t = n);\n        }\n      }\n\n      return t + 1;\n    },\n    isEmpty: function t() {\n      var t = !0;\n      this.items.isEmpty() || (t = !1);\n\n      for (var e = 0; 4 > e; e++) {\n        null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));\n      }\n\n      return t;\n    },\n    add: function add(t) {\n      this.items.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [u];\n    },\n    getClass: function getClass() {\n      return Ni;\n    }\n  }), Ni.getSubnodeIndex = function (t, e, n) {\n    var i = -1;\n    return t.getMinX() >= e && (t.getMinY() >= n && (i = 3), t.getMaxY() <= n && (i = 1)), t.getMaxX() <= e && (t.getMinY() >= n && (i = 2), t.getMaxY() <= n && (i = 0)), i;\n  }, Ci.exponent = function (t) {\n    return Si(64, t) - 1023;\n  }, Ci.powerOf2 = function (t) {\n    return Math.pow(2, t);\n  }, e(wi.prototype, {\n    getLevel: function getLevel() {\n      return this.level;\n    },\n    computeKey: function computeKey() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n\n        for (this.level = wi.computeQuadLevel(t), this.env = new C(), this.computeKey(this.level, t); !this.env.contains(t);) {\n          this.level += 1, this.computeKey(this.level, t);\n        }\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = Ci.powerOf2(e);\n        this.pt.x = Math.floor(n.getMinX() / i) * i, this.pt.y = Math.floor(n.getMinY() / i) * i, this.env.init(this.pt.x, this.pt.x + i, this.pt.y, this.pt.y + i);\n      }\n    },\n    getEnvelope: function getEnvelope() {\n      return this.env;\n    },\n    getCentre: function getCentre() {\n      return new g((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2);\n    },\n    getPoint: function getPoint() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return wi;\n    }\n  }), wi.computeQuadLevel = function (t) {\n    var e = t.getWidth(),\n        n = t.getHeight(),\n        i = e > n ? e : n,\n        r = Ci.exponent(i) + 1;\n    return r;\n  }, h(Li, Ni), e(Li.prototype, {\n    find: function find(t) {\n      var e = Ni.getSubnodeIndex(t, this.centrex, this.centrey);\n      if (-1 === e) return this;\n\n      if (null !== this.subnode[e]) {\n        var n = this.subnode[e];\n        return n.find(t);\n      }\n\n      return this;\n    },\n    isSearchMatch: function isSearchMatch(t) {\n      return this.env.intersects(t);\n    },\n    getSubnode: function getSubnode(t) {\n      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];\n    },\n    getEnvelope: function getEnvelope() {\n      return this.env;\n    },\n    getNode: function getNode(t) {\n      var e = Ni.getSubnodeIndex(t, this.centrex, this.centrey);\n\n      if (-1 !== e) {\n        var n = this.getSubnode(e);\n        return n.getNode(t);\n      }\n\n      return this;\n    },\n    createSubnode: function createSubnode(t) {\n      var e = 0,\n          n = 0,\n          i = 0,\n          r = 0;\n\n      switch (t) {\n        case 0:\n          e = this.env.getMinX(), n = this.centrex, i = this.env.getMinY(), r = this.centrey;\n          break;\n\n        case 1:\n          e = this.centrex, n = this.env.getMaxX(), i = this.env.getMinY(), r = this.centrey;\n          break;\n\n        case 2:\n          e = this.env.getMinX(), n = this.centrex, i = this.centrey, r = this.env.getMaxY();\n          break;\n\n        case 3:\n          e = this.centrex, n = this.env.getMaxX(), i = this.centrey, r = this.env.getMaxY();\n      }\n\n      var s = new C(e, n, i, r),\n          o = new Li(s, this.level - 1);\n      return o;\n    },\n    insertNode: function insertNode(t) {\n      f.isTrue(null === this.env || this.env.contains(t.env));\n      var e = Ni.getSubnodeIndex(t.env, this.centrex, this.centrey);\n      if (t.level === this.level - 1) this.subnode[e] = t;else {\n        var n = this.createSubnode(e);\n        n.insertNode(t), this.subnode[e] = n;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Li;\n    }\n  }), Li.createNode = function (t) {\n    var e = new wi(t),\n        n = new Li(e.getEnvelope(), e.getLevel());\n    return n;\n  }, Li.createExpanded = function (t, e) {\n    var n = new C(e);\n    null !== t && n.expandToInclude(t.env);\n    var i = Li.createNode(n);\n    return null !== t && i.insertNode(t), i;\n  }, e(Ri.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ri;\n    }\n  }), Ri.isZeroWidth = function (t, e) {\n    var n = e - t;\n    if (0 === n) return !0;\n    var i = Math.max(Math.abs(t), Math.abs(e)),\n        r = n / i,\n        s = Ci.exponent(r);\n    return s <= Ri.MIN_BINARY_EXPONENT;\n  }, Ri.MIN_BINARY_EXPONENT = -50, h(Ti, Ni), e(Ti.prototype, {\n    insert: function insert(t, e) {\n      var n = Ni.getSubnodeIndex(t, Ti.origin.x, Ti.origin.y);\n      if (-1 === n) return this.add(e), null;\n      var i = this.subnode[n];\n\n      if (null === i || !i.getEnvelope().contains(t)) {\n        var r = Li.createExpanded(i, t);\n        this.subnode[n] = r;\n      }\n\n      this.insertContained(this.subnode[n], t, e);\n    },\n    isSearchMatch: function isSearchMatch(t) {\n      return !0;\n    },\n    insertContained: function insertContained(t, e, n) {\n      f.isTrue(t.getEnvelope().contains(e));\n      var i = Ri.isZeroWidth(e.getMinX(), e.getMaxX()),\n          r = Ri.isZeroWidth(e.getMinY(), e.getMaxY()),\n          s = null;\n      s = i || r ? t.find(e) : t.getNode(e), s.add(n);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ti;\n    }\n  }), Ti.origin = new g(0, 0), e(Pi.prototype, {\n    size: function size() {\n      return null !== this.root ? this.root.size() : 0;\n    },\n    insert: function insert(t, e) {\n      this.collectStats(t);\n      var n = Pi.ensureExtent(t, this.minExtent);\n      this.root.insert(n, e);\n    },\n    query: function query() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = new Yn();\n        return this.query(t, e), e.getItems();\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        this.root.visit(n, i);\n      }\n    },\n    queryAll: function queryAll() {\n      var t = new I();\n      return this.root.addAllItems(t), t;\n    },\n    remove: function remove(t, e) {\n      var n = Pi.ensureExtent(t, this.minExtent);\n      return this.root.remove(n, e);\n    },\n    collectStats: function collectStats(t) {\n      var e = t.getWidth();\n      e < this.minExtent && e > 0 && (this.minExtent = e);\n      var n = t.getHeight();\n      n < this.minExtent && n > 0 && (this.minExtent = n);\n    },\n    depth: function depth() {\n      return null !== this.root ? this.root.depth() : 0;\n    },\n    isEmpty: function isEmpty() {\n      return null === this.root;\n    },\n    interfaces_: function interfaces_() {\n      return [Fe, u];\n    },\n    getClass: function getClass() {\n      return Pi;\n    }\n  }), Pi.ensureExtent = function (t, e) {\n    var n = t.getMinX(),\n        i = t.getMaxX(),\n        r = t.getMinY(),\n        s = t.getMaxY();\n    return n !== i && r !== s ? t : (n === i && (n -= e / 2, i = n + e / 2), r === s && (r -= e / 2, s = r + e / 2), new C(n, i, r, s));\n  }, Pi.serialVersionUID = -0x678b60c967a25400;\n  var po = Object.freeze({\n    Quadtree: Pi\n  }),\n      vo = Object.freeze({\n    STRtree: ke\n  }),\n      mo = Object.freeze({\n    quadtree: po,\n    strtree: vo\n  }),\n      yo = [\"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\"];\n  e(bi.prototype, {\n    read: function read(t) {\n      var e = void 0;\n      e = \"string\" == typeof t ? JSON.parse(t) : t;\n      var n = e.type;\n      if (!xo[n]) throw new Error(\"Unknown GeoJSON type: \" + e.type);\n      return -1 !== yo.indexOf(n) ? xo[n].apply(this, [e.coordinates]) : \"GeometryCollection\" === n ? xo[n].apply(this, [e.geometries]) : xo[n].apply(this, [e]);\n    },\n    write: function write(t) {\n      var e = t.getGeometryType();\n      if (!Eo[e]) throw new Error(\"Geometry is not supported\");\n      return Eo[e].apply(this, [t]);\n    }\n  });\n  var xo = {\n    Feature: function Feature(t) {\n      var e = {};\n\n      for (var n in t) {\n        e[n] = t[n];\n      }\n\n      if (t.geometry) {\n        var i = t.geometry.type;\n        if (!xo[i]) throw new Error(\"Unknown GeoJSON type: \" + t.type);\n        e.geometry = this.read(t.geometry);\n      }\n\n      return t.bbox && (e.bbox = xo.bbox.apply(this, [t.bbox])), e;\n    },\n    FeatureCollection: function FeatureCollection(t) {\n      var e = {};\n\n      if (t.features) {\n        e.features = [];\n\n        for (var n = 0; n < t.features.length; ++n) {\n          e.features.push(this.read(t.features[n]));\n        }\n      }\n\n      return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e;\n    },\n    coordinates: function t(e) {\n      for (var t = [], n = 0; n < e.length; ++n) {\n        var i = e[n];\n        t.push(new g(i[0], i[1]));\n      }\n\n      return t;\n    },\n    bbox: function bbox(t) {\n      return this.geometryFactory.createLinearRing([new g(t[0], t[1]), new g(t[2], t[1]), new g(t[2], t[3]), new g(t[0], t[3]), new g(t[0], t[1])]);\n    },\n    Point: function Point(t) {\n      var e = new g(t[0], t[1]);\n      return this.geometryFactory.createPoint(e);\n    },\n    MultiPoint: function MultiPoint(t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        e.push(xo.Point.apply(this, [t[n]]));\n      }\n\n      return this.geometryFactory.createMultiPoint(e);\n    },\n    LineString: function LineString(t) {\n      var e = xo.coordinates.apply(this, [t]);\n      return this.geometryFactory.createLineString(e);\n    },\n    MultiLineString: function MultiLineString(t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        e.push(xo.LineString.apply(this, [t[n]]));\n      }\n\n      return this.geometryFactory.createMultiLineString(e);\n    },\n    Polygon: function Polygon(t) {\n      for (var e = xo.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {\n        var s = t[r],\n            o = xo.coordinates.apply(this, [s]),\n            a = this.geometryFactory.createLinearRing(o);\n        i.push(a);\n      }\n\n      return this.geometryFactory.createPolygon(n, i);\n    },\n    MultiPolygon: function MultiPolygon(t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        var i = t[n];\n        e.push(xo.Polygon.apply(this, [i]));\n      }\n\n      return this.geometryFactory.createMultiPolygon(e);\n    },\n    GeometryCollection: function GeometryCollection(t) {\n      for (var e = [], n = 0; n < t.length; ++n) {\n        var i = t[n];\n        e.push(this.read(i));\n      }\n\n      return this.geometryFactory.createGeometryCollection(e);\n    }\n  },\n      Eo = {\n    coordinate: function coordinate(t) {\n      return [t.x, t.y];\n    },\n    Point: function Point(t) {\n      var e = Eo.coordinate.apply(this, [t.getCoordinate()]);\n      return {\n        type: \"Point\",\n        coordinates: e\n      };\n    },\n    MultiPoint: function MultiPoint(t) {\n      for (var e = [], n = 0; n < t.geometries.length; ++n) {\n        var i = t.geometries[n],\n            r = Eo.Point.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiPoint\",\n        coordinates: e\n      };\n    },\n    LineString: function LineString(t) {\n      for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {\n        var r = n[i];\n        e.push(Eo.coordinate.apply(this, [r]));\n      }\n\n      return {\n        type: \"LineString\",\n        coordinates: e\n      };\n    },\n    MultiLineString: function MultiLineString(t) {\n      for (var e = [], n = 0; n < t.geometries.length; ++n) {\n        var i = t.geometries[n],\n            r = Eo.LineString.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiLineString\",\n        coordinates: e\n      };\n    },\n    Polygon: function Polygon(t) {\n      var e = [],\n          n = Eo.LineString.apply(this, [t.shell]);\n      e.push(n.coordinates);\n\n      for (var i = 0; i < t.holes.length; ++i) {\n        var r = t.holes[i],\n            s = Eo.LineString.apply(this, [r]);\n        e.push(s.coordinates);\n      }\n\n      return {\n        type: \"Polygon\",\n        coordinates: e\n      };\n    },\n    MultiPolygon: function MultiPolygon(t) {\n      for (var e = [], n = 0; n < t.geometries.length; ++n) {\n        var i = t.geometries[n],\n            r = Eo.Polygon.apply(this, [i]);\n        e.push(r.coordinates);\n      }\n\n      return {\n        type: \"MultiPolygon\",\n        coordinates: e\n      };\n    },\n    GeometryCollection: function GeometryCollection(t) {\n      for (var e = [], n = 0; n < t.geometries.length; ++n) {\n        var i = t.geometries[n],\n            r = i.getGeometryType();\n        e.push(Eo[r].apply(this, [i]));\n      }\n\n      return {\n        type: \"GeometryCollection\",\n        geometries: e\n      };\n    }\n  };\n  e(Oi.prototype, {\n    read: function read(t) {\n      var e = this.parser.read(t);\n      return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e;\n    },\n    reducePrecision: function reducePrecision(t) {\n      var e, n;\n      if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (e = 0, n = t.points.length; n > e; e++) {\n        this.precisionModel.makePrecise(t.points[e]);\n      } else if (t.geometries) for (e = 0, n = t.geometries.length; n > e; e++) {\n        this.reducePrecision(t.geometries[e]);\n      }\n    }\n  }), e(_i.prototype, {\n    write: function write(t) {\n      return this.parser.write(t);\n    }\n  }), e(Mi.prototype, {\n    read: function read(t) {\n      var e = this.parser.read(t);\n      return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e;\n    },\n    reducePrecision: function reducePrecision(t) {\n      if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);else if (t.points) for (var e = 0, n = t.points.coordinates.length; n > e; e++) {\n        this.precisionModel.makePrecise(t.points.coordinates[e]);\n      } else if (t.geometries) for (var i = 0, r = t.geometries.length; r > i; i++) {\n        this.reducePrecision(t.geometries[i]);\n      }\n    }\n  }), e(Ai.prototype, {\n    read: function read(t) {\n      return t instanceof ol.geom.Point ? this.convertFromPoint(t) : t instanceof ol.geom.LineString ? this.convertFromLineString(t) : t instanceof ol.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof ol.geom.Polygon ? this.convertFromPolygon(t) : t instanceof ol.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof ol.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof ol.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof ol.geom.GeometryCollection ? this.convertFromCollection(t) : void 0;\n    },\n    convertFromPoint: function convertFromPoint(t) {\n      var e = t.getCoordinates();\n      return this.geometryFactory.createPoint(new g(e[0], e[1]));\n    },\n    convertFromLineString: function convertFromLineString(t) {\n      return this.geometryFactory.createLineString(t.getCoordinates().map(function (t) {\n        return new g(t[0], t[1]);\n      }));\n    },\n    convertFromLinearRing: function convertFromLinearRing(t) {\n      return this.geometryFactory.createLinearRing(t.getCoordinates().map(function (t) {\n        return new g(t[0], t[1]);\n      }));\n    },\n    convertFromPolygon: function convertFromPolygon(t) {\n      for (var e = t.getLinearRings(), n = null, i = [], r = 0; r < e.length; r++) {\n        var s = this.convertFromLinearRing(e[r]);\n        0 === r ? n = s : i.push(s);\n      }\n\n      return this.geometryFactory.createPolygon(n, i);\n    },\n    convertFromMultiPoint: function convertFromMultiPoint(t) {\n      var e = t.getPoints().map(function (t) {\n        return this.convertFromPoint(t);\n      }, this);\n      return this.geometryFactory.createMultiPoint(e);\n    },\n    convertFromMultiLineString: function convertFromMultiLineString(t) {\n      var e = t.getLineStrings().map(function (t) {\n        return this.convertFromLineString(t);\n      }, this);\n      return this.geometryFactory.createMultiLineString(e);\n    },\n    convertFromMultiPolygon: function convertFromMultiPolygon(t) {\n      var e = t.getPolygons().map(function (t) {\n        return this.convertFromPolygon(t);\n      }, this);\n      return this.geometryFactory.createMultiPolygon(e);\n    },\n    convertFromCollection: function convertFromCollection(t) {\n      var e = t.getGeometries().map(function (t) {\n        return this.read(t);\n      }, this);\n      return this.geometryFactory.createGeometryCollection(e);\n    },\n    write: function write(t) {\n      return \"Point\" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : \"LineString\" === t.getGeometryType() ? this.convertToLineString(t) : \"LinearRing\" === t.getGeometryType() ? this.convertToLinearRing(t) : \"Polygon\" === t.getGeometryType() ? this.convertToPolygon(t) : \"MultiPoint\" === t.getGeometryType() ? this.convertToMultiPoint(t) : \"MultiLineString\" === t.getGeometryType() ? this.convertToMultiLineString(t) : \"MultiPolygon\" === t.getGeometryType() ? this.convertToMultiPolygon(t) : \"GeometryCollection\" === t.getGeometryType() ? this.convertToCollection(t) : void 0;\n    },\n    convertToPoint: function convertToPoint(t) {\n      return new ol.geom.Point([t.x, t.y]);\n    },\n    convertToLineString: function convertToLineString(t) {\n      var e = t.points.coordinates.map(Di);\n      return new ol.geom.LineString(e);\n    },\n    convertToLinearRing: function convertToLinearRing(t) {\n      var e = t.points.coordinates.map(Di);\n      return new ol.geom.LinearRing(e);\n    },\n    convertToPolygon: function convertToPolygon(t) {\n      for (var e = [t.shell.points.coordinates.map(Di)], n = 0; n < t.holes.length; n++) {\n        e.push(t.holes[n].points.coordinates.map(Di));\n      }\n\n      return new ol.geom.Polygon(e);\n    },\n    convertToMultiPoint: function convertToMultiPoint(t) {\n      return new ol.geom.MultiPoint(t.getCoordinates().map(Di));\n    },\n    convertToMultiLineString: function convertToMultiLineString(t) {\n      for (var e = [], n = 0; n < t.geometries.length; n++) {\n        e.push(this.convertToLineString(t.geometries[n]).getCoordinates());\n      }\n\n      return new ol.geom.MultiLineString(e);\n    },\n    convertToMultiPolygon: function convertToMultiPolygon(t) {\n      for (var e = [], n = 0; n < t.geometries.length; n++) {\n        e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());\n      }\n\n      return new ol.geom.MultiPolygon(e);\n    },\n    convertToCollection: function convertToCollection(t) {\n      for (var e = [], n = 0; n < t.geometries.length; n++) {\n        var i = t.geometries[n];\n        e.push(this.write(i));\n      }\n\n      return new ol.geom.GeometryCollection(e);\n    }\n  });\n  var Io = Object.freeze({\n    GeoJSONReader: Oi,\n    GeoJSONWriter: _i,\n    OL3Parser: Ai,\n    WKTReader: Mi,\n    WKTWriter: se\n  });\n  e(Fi.prototype, {\n    rescale: function rescale() {\n      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.rescale(n.getCoordinates());\n      } else if (arguments[0] instanceof Array) {\n        var i = arguments[0],\n            r = null,\n            s = null;\n        2 === i.length && (r = new g(i[0]), s = new g(i[1]));\n\n        for (var e = 0; e < i.length; e++) {\n          i[e].x = i[e].x / this.scaleFactor + this.offsetX, i[e].y = i[e].y / this.scaleFactor + this.offsetY;\n        }\n\n        2 === i.length && i[0].equals2D(i[1]) && A.out.println(i);\n      }\n    },\n    scale: function scale() {\n      if (R(arguments[0], v)) {\n        for (var t = arguments[0], e = new I(), n = t.iterator(); n.hasNext();) {\n          var i = n.next();\n          e.add(new Ke(this.scale(i.getCoordinates()), i.getData()));\n        }\n\n        return e;\n      }\n\n      if (arguments[0] instanceof Array) {\n        for (var r = arguments[0], s = new Array(r.length).fill(null), n = 0; n < r.length; n++) {\n          s[n] = new g(Math.round((r[n].x - this.offsetX) * this.scaleFactor), Math.round((r[n].y - this.offsetY) * this.scaleFactor), r[n].z);\n        }\n\n        var o = H.removeRepeatedPoints(s);\n        return o;\n      }\n    },\n    isIntegerPrecision: function isIntegerPrecision() {\n      return 1 === this.scaleFactor;\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      var t = this.noder.getNodedSubstrings();\n      return this.isScaled && this.rescale(t), t;\n    },\n    computeNodes: function computeNodes(t) {\n      var e = t;\n      this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e);\n    },\n    interfaces_: function interfaces_() {\n      return [tn];\n    },\n    getClass: function getClass() {\n      return Fi;\n    }\n  });\n  var No = Object.freeze({\n    MCIndexNoder: nn,\n    ScaledNoder: Fi,\n    SegmentString: be\n  });\n  e(Gi.prototype, {\n    isSimpleMultiPoint: function isSimpleMultiPoint(t) {\n      if (t.isEmpty()) return !0;\n\n      for (var e = new at(), n = 0; n < t.getNumGeometries(); n++) {\n        var i = t.getGeometryN(n),\n            r = i.getCoordinate();\n        if (e.contains(r)) return this.nonSimpleLocation = r, !1;\n        e.add(r);\n      }\n\n      return !0;\n    },\n    isSimplePolygonal: function isSimplePolygonal(t) {\n      for (var e = kn.getLines(t), n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        if (!this.isSimpleLinearGeometry(i)) return !1;\n      }\n\n      return !0;\n    },\n    hasClosedEndpointIntersection: function hasClosedEndpointIntersection(t) {\n      for (var e = new rt(), n = t.getEdgeIterator(); n.hasNext();) {\n        var i = n.next(),\n            r = (i.getMaximumSegmentIndex(), i.isClosed()),\n            s = i.getCoordinate(0);\n        this.addEndpoint(e, s, r);\n        var o = i.getCoordinate(i.getNumPoints() - 1);\n        this.addEndpoint(e, o, r);\n      }\n\n      for (var n = e.values().iterator(); n.hasNext();) {\n        var a = n.next();\n        if (a.isClosed && 2 !== a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0;\n      }\n\n      return !1;\n    },\n    getNonSimpleLocation: function getNonSimpleLocation() {\n      return this.nonSimpleLocation;\n    },\n    isSimpleLinearGeometry: function isSimpleLinearGeometry(t) {\n      if (t.isEmpty()) return !0;\n      var e = new $n(0, t),\n          n = new ae(),\n          i = e.computeSelfNodes(n, !0);\n      return i.hasIntersection() ? i.hasProperIntersection() ? (this.nonSimpleLocation = i.getProperIntersectionPoint(), !1) : this.hasNonEndpointIntersection(e) ? !1 : !this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e) : !0;\n    },\n    hasNonEndpointIntersection: function hasNonEndpointIntersection(t) {\n      for (var e = t.getEdgeIterator(); e.hasNext();) {\n        for (var n = e.next(), i = n.getMaximumSegmentIndex(), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {\n          var s = r.next();\n          if (!s.isEndPoint(i)) return this.nonSimpleLocation = s.getCoordinate(), !0;\n        }\n      }\n\n      return !1;\n    },\n    addEndpoint: function addEndpoint(t, e, n) {\n      var i = t.get(e);\n      null === i && (i = new qi(e), t.put(e, i)), i.addEndpoint(n);\n    },\n    computeSimple: function computeSimple(t) {\n      return this.nonSimpleLocation = null, t.isEmpty() ? !0 : t instanceof St ? this.isSimpleLinearGeometry(t) : t instanceof gt ? this.isSimpleLinearGeometry(t) : t instanceof Pt ? this.isSimpleMultiPoint(t) : R(t, Rt) ? this.isSimplePolygonal(t) : t instanceof ft ? this.isSimpleGeometryCollection(t) : !0;\n    },\n    isSimple: function isSimple() {\n      return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom);\n    },\n    isSimpleGeometryCollection: function isSimpleGeometryCollection(t) {\n      for (var e = 0; e < t.getNumGeometries(); e++) {\n        var n = t.getGeometryN(e);\n        if (!this.computeSimple(n)) return !1;\n      }\n\n      return !0;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Gi;\n    }\n  }), e(qi.prototype, {\n    addEndpoint: function addEndpoint(t) {\n      this.degree++, this.isClosed |= t;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return qi;\n    }\n  }), Gi.EndpointInfo = qi, e(Bi.prototype, {\n    getEndCapStyle: function getEndCapStyle() {\n      return this.endCapStyle;\n    },\n    isSingleSided: function isSingleSided() {\n      return this._isSingleSided;\n    },\n    setQuadrantSegments: function setQuadrantSegments(t) {\n      this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = Bi.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Bi.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), 0 >= t && (this.quadrantSegments = 1), this.joinStyle !== Bi.JOIN_ROUND && (this.quadrantSegments = Bi.DEFAULT_QUADRANT_SEGMENTS);\n    },\n    getJoinStyle: function getJoinStyle() {\n      return this.joinStyle;\n    },\n    setJoinStyle: function setJoinStyle(t) {\n      this.joinStyle = t;\n    },\n    setSimplifyFactor: function setSimplifyFactor(t) {\n      this.simplifyFactor = 0 > t ? 0 : t;\n    },\n    getSimplifyFactor: function getSimplifyFactor() {\n      return this.simplifyFactor;\n    },\n    getQuadrantSegments: function getQuadrantSegments() {\n      return this.quadrantSegments;\n    },\n    setEndCapStyle: function setEndCapStyle(t) {\n      this.endCapStyle = t;\n    },\n    getMitreLimit: function getMitreLimit() {\n      return this.mitreLimit;\n    },\n    setMitreLimit: function setMitreLimit(t) {\n      this.mitreLimit = t;\n    },\n    setSingleSided: function setSingleSided(t) {\n      this._isSingleSided = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Bi;\n    }\n  }), Bi.bufferDistanceError = function (t) {\n    var e = Math.PI / 2 / t;\n    return 1 - Math.cos(e / 2);\n  }, Bi.CAP_ROUND = 1, Bi.CAP_FLAT = 2, Bi.CAP_SQUARE = 3, Bi.JOIN_ROUND = 1, Bi.JOIN_MITRE = 2, Bi.JOIN_BEVEL = 3, Bi.DEFAULT_QUADRANT_SEGMENTS = 8, Bi.DEFAULT_MITRE_LIMIT = 5, Bi.DEFAULT_SIMPLIFY_FACTOR = .01, e(zi.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this.minCoord;\n    },\n    getRightmostSide: function getRightmostSide(t, e) {\n      var n = this.getRightmostSideOfSegment(t, e);\n      return 0 > n && (n = this.getRightmostSideOfSegment(t, e - 1)), 0 > n && (this.minCoord = null, this.checkForRightmostCoordinate(t)), n;\n    },\n    findRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {\n      var t = this.minDe.getEdge().getCoordinates();\n      f.isTrue(this.minIndex > 0 && this.minIndex < t.length, \"rightmost point expected to be interior vertex of edge\");\n      var e = t[this.minIndex - 1],\n          n = t[this.minIndex + 1],\n          i = he.computeOrientation(this.minCoord, n, e),\n          r = !1;\n      e.y < this.minCoord.y && n.y < this.minCoord.y && i === he.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && n.y > this.minCoord.y && i === he.CLOCKWISE && (r = !0), r && (this.minIndex = this.minIndex - 1);\n    },\n    getRightmostSideOfSegment: function getRightmostSideOfSegment(t, e) {\n      var n = t.getEdge(),\n          i = n.getCoordinates();\n      if (0 > e || e + 1 >= i.length) return -1;\n      if (i[e].y === i[e + 1].y) return -1;\n      var r = cn.LEFT;\n      return i[e].y < i[e + 1].y && (r = cn.RIGHT), r;\n    },\n    getEdge: function getEdge() {\n      return this.orientedDe;\n    },\n    checkForRightmostCoordinate: function checkForRightmostCoordinate(t) {\n      for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) {\n        (null === this.minCoord || e[n].x > this.minCoord.x) && (this.minDe = t, this.minIndex = n, this.minCoord = e[n]);\n      }\n    },\n    findRightmostEdgeAtNode: function findRightmostEdgeAtNode() {\n      var t = this.minDe.getNode(),\n          e = t.getEdges();\n      this.minDe = e.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1);\n    },\n    findEdge: function findEdge(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.isForward() && this.checkForRightmostCoordinate(n);\n      }\n\n      f.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), \"inconsistency in rightmost processing\"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe;\n      var i = this.getRightmostSide(this.minDe, this.minIndex);\n      i === cn.LEFT && (this.orientedDe = this.minDe.getSym());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return zi;\n    }\n  }), Vi.prototype.addLast = function (t) {\n    this.array_.push(t);\n  }, Vi.prototype.removeFirst = function () {\n    return this.array_.shift();\n  }, Vi.prototype.isEmpty = function () {\n    return 0 === this.array_.length;\n  }, e(ki.prototype, {\n    clearVisitedEdges: function clearVisitedEdges() {\n      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.setVisited(!1);\n      }\n    },\n    getRightmostCoordinate: function getRightmostCoordinate() {\n      return this.rightMostCoord;\n    },\n    computeNodeDepth: function computeNodeDepth(t) {\n      for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (i.isVisited() || i.getSym().isVisited()) {\n          e = i;\n          break;\n        }\n      }\n\n      if (null === e) throw new sn(\"unable to find edge to compute depths at \" + t.getCoordinate());\n      t.getEdges().computeDepths(e);\n\n      for (var n = t.getEdges().iterator(); n.hasNext();) {\n        var i = n.next();\n        i.setVisited(!0), this.copySymDepths(i);\n      }\n    },\n    computeDepth: function computeDepth(t) {\n      this.clearVisitedEdges();\n      var e = this.finder.getEdge();\n      e.getNode(), e.getLabel();\n      e.setEdgeDepths(cn.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);\n    },\n    create: function create(t) {\n      this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate();\n    },\n    findResultEdges: function findResultEdges() {\n      for (var t = this.dirEdgeList.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getDepth(cn.RIGHT) >= 1 && e.getDepth(cn.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);\n      }\n    },\n    computeDepths: function computeDepths(t) {\n      var e = new J(),\n          n = new Vi(),\n          i = t.getNode();\n\n      for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {\n        var r = n.removeFirst();\n        e.add(r), this.computeNodeDepth(r);\n\n        for (var s = r.getEdges().iterator(); s.hasNext();) {\n          var o = s.next(),\n              a = o.getSym();\n\n          if (!a.isVisited()) {\n            var u = a.getNode();\n            e.contains(u) || (n.addLast(u), e.add(u));\n          }\n        }\n      }\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0;\n    },\n    getEnvelope: function getEnvelope() {\n      if (null === this.env) {\n        for (var t = new C(), e = this.dirEdgeList.iterator(); e.hasNext();) {\n          for (var n = e.next(), i = n.getEdge().getCoordinates(), r = 0; r < i.length - 1; r++) {\n            t.expandToInclude(i[r]);\n          }\n        }\n\n        this.env = t;\n      }\n\n      return this.env;\n    },\n    addReachable: function addReachable(t) {\n      var e = new pe();\n\n      for (e.add(t); !e.empty();) {\n        var n = e.pop();\n        this.add(n, e);\n      }\n    },\n    copySymDepths: function copySymDepths(t) {\n      var e = t.getSym();\n      e.setDepth(cn.LEFT, t.getDepth(cn.RIGHT)), e.setDepth(cn.RIGHT, t.getDepth(cn.LEFT));\n    },\n    add: function add(t, e) {\n      t.setVisited(!0), this.nodes.add(t);\n\n      for (var n = t.getEdges().iterator(); n.hasNext();) {\n        var i = n.next();\n        this.dirEdgeList.add(i);\n        var r = i.getSym(),\n            s = r.getNode();\n        s.isVisited() || e.push(s);\n      }\n    },\n    getNodes: function getNodes() {\n      return this.nodes;\n    },\n    getDirectedEdges: function getDirectedEdges() {\n      return this.dirEdgeList;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return ki;\n    }\n  }), e(Yi.prototype, {\n    isDeletable: function isDeletable(t, e, n, i) {\n      var r = this.inputLine[t],\n          s = this.inputLine[e],\n          o = this.inputLine[n];\n      return this.isConcave(r, s, o) && this.isShallow(r, s, o, i) ? this.isShallowSampled(r, s, t, n, i) : !1;\n    },\n    deleteShallowConcavities: function deleteShallowConcavities() {\n      for (var t = 1, e = (this.inputLine.length - 1, this.findNextNonDeletedIndex(t)), n = this.findNextNonDeletedIndex(e), i = !1; n < this.inputLine.length;) {\n        var r = !1;\n        this.isDeletable(t, e, n, this.distanceTol) && (this.isDeleted[e] = Yi.DELETE, r = !0, i = !0), t = r ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e);\n      }\n\n      return i;\n    },\n    isShallowConcavity: function isShallowConcavity(t, e, n, i) {\n      var r = he.computeOrientation(t, e, n),\n          s = r === this.angleOrientation;\n      if (!s) return !1;\n      var o = he.distancePointLine(e, t, n);\n      return i > o;\n    },\n    isShallowSampled: function isShallowSampled(t, e, n, i, r) {\n      var s = Math.trunc((i - n) / Yi.NUM_PTS_TO_CHECK);\n      0 >= s && (s = 1);\n\n      for (var o = n; i > o; o += s) {\n        if (!this.isShallow(t, e, this.inputLine[o], r)) return !1;\n      }\n\n      return !0;\n    },\n    isConcave: function t(e, n, i) {\n      var r = he.computeOrientation(e, n, i),\n          t = r === this.angleOrientation;\n      return t;\n    },\n    simplify: function simplify(t) {\n      this.distanceTol = Math.abs(t), 0 > t && (this.angleOrientation = he.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);\n      var e = !1;\n\n      do {\n        e = this.deleteShallowConcavities();\n      } while (e);\n\n      return this.collapseLine();\n    },\n    findNextNonDeletedIndex: function findNextNonDeletedIndex(t) {\n      for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === Yi.DELETE;) {\n        e++;\n      }\n\n      return e;\n    },\n    isShallow: function isShallow(t, e, n, i) {\n      var r = he.distancePointLine(e, t, n);\n      return i > r;\n    },\n    collapseLine: function collapseLine() {\n      for (var t = new N(), e = 0; e < this.inputLine.length; e++) {\n        this.isDeleted[e] !== Yi.DELETE && t.add(this.inputLine[e]);\n      }\n\n      return t.toCoordinateArray();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Yi;\n    }\n  }), Yi.simplify = function (t, e) {\n    var n = new Yi(t);\n    return n.simplify(e);\n  }, Yi.INIT = 0, Yi.DELETE = 1, Yi.KEEP = 1, Yi.NUM_PTS_TO_CHECK = 10, e(Ui.prototype, {\n    getCoordinates: function getCoordinates() {\n      var t = this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);\n      return t;\n    },\n    setPrecisionModel: function setPrecisionModel(t) {\n      this.precisionModel = t;\n    },\n    addPt: function addPt(t) {\n      var e = new g(t);\n      return this.precisionModel.makePrecise(e), this.isRedundant(e) ? null : void this.ptList.add(e);\n    },\n    reverse: function reverse() {},\n    addPts: function addPts(t, e) {\n      if (e) for (var n = 0; n < t.length; n++) {\n        this.addPt(t[n]);\n      } else for (var n = t.length - 1; n >= 0; n--) {\n        this.addPt(t[n]);\n      }\n    },\n    isRedundant: function isRedundant(t) {\n      if (this.ptList.size() < 1) return !1;\n      var e = this.ptList.get(this.ptList.size() - 1),\n          n = t.distance(e);\n      return n < this.minimimVertexDistance;\n    },\n    toString: function toString() {\n      var t = new ie(),\n          e = t.createLineString(this.getCoordinates());\n      return e.toString();\n    },\n    closeRing: function closeRing() {\n      if (this.ptList.size() < 1) return null;\n      var t = new g(this.ptList.get(0)),\n          e = this.ptList.get(this.ptList.size() - 1),\n          n = null;\n      return this.ptList.size() >= 2 && (n = this.ptList.get(this.ptList.size() - 2)), t.equals(e) ? null : void this.ptList.add(t);\n    },\n    setMinimumVertexDistance: function setMinimumVertexDistance(t) {\n      this.minimimVertexDistance = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ui;\n    }\n  }), Ui.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), e(Xi.prototype, {\n    addNextSegment: function addNextSegment(t, e) {\n      if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;\n      var n = he.computeOrientation(this.s0, this.s1, this.s2),\n          i = n === he.CLOCKWISE && this.side === cn.LEFT || n === he.COUNTERCLOCKWISE && this.side === cn.RIGHT;\n      0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);\n    },\n    addLineEndCap: function addLineEndCap(t, e) {\n      var n = new ce(t, e),\n          i = new ce();\n      this.computeOffsetSegment(n, cn.LEFT, this.distance, i);\n      var r = new ce();\n      this.computeOffsetSegment(n, cn.RIGHT, this.distance, r);\n      var s = e.x - t.x,\n          o = e.y - t.y,\n          a = Math.atan2(o, s);\n\n      switch (this.bufParams.getEndCapStyle()) {\n        case Bi.CAP_ROUND:\n          this.segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, he.CLOCKWISE, this.distance), this.segList.addPt(r.p1);\n          break;\n\n        case Bi.CAP_FLAT:\n          this.segList.addPt(i.p1), this.segList.addPt(r.p1);\n          break;\n\n        case Bi.CAP_SQUARE:\n          var u = new g();\n          u.x = Math.abs(this.distance) * Math.cos(a), u.y = Math.abs(this.distance) * Math.sin(a);\n          var l = new g(i.p1.x + u.x, i.p1.y + u.y),\n              h = new g(r.p1.x + u.x, r.p1.y + u.y);\n          this.segList.addPt(l), this.segList.addPt(h);\n      }\n    },\n    getCoordinates: function getCoordinates() {\n      var t = this.segList.getCoordinates();\n      return t;\n    },\n    addMitreJoin: function addMitreJoin(t, e, n, i) {\n      var r = !0,\n          s = null;\n\n      try {\n        s = F.intersection(e.p0, e.p1, n.p0, n.p1);\n        var o = 0 >= i ? 1 : s.distance(t) / Math.abs(i);\n        o > this.bufParams.getMitreLimit() && (r = !1);\n      } catch (t) {\n        if (!(t instanceof w)) throw t;\n        s = new g(0, 0), r = !1;\n      } finally {}\n\n      r ? this.segList.addPt(s) : this.addLimitedMitreJoin(e, n, i, this.bufParams.getMitreLimit());\n    },\n    addFilletCorner: function addFilletCorner(t, e, n, i, r) {\n      var s = e.x - t.x,\n          o = e.y - t.y,\n          a = Math.atan2(o, s),\n          u = n.x - t.x,\n          l = n.y - t.y,\n          h = Math.atan2(l, u);\n      i === he.CLOCKWISE ? h >= a && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFilletArc(t, a, h, i, r), this.segList.addPt(n);\n    },\n    addOutsideTurn: function addOutsideTurn(t, e) {\n      return this.offset0.p1.distance(this.offset1.p0) < this.distance * Xi.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1), null) : void (this.bufParams.getJoinStyle() === Bi.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Bi.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0)));\n    },\n    createSquare: function createSquare(t) {\n      this.segList.addPt(new g(t.x + this.distance, t.y + this.distance)), this.segList.addPt(new g(t.x + this.distance, t.y - this.distance)), this.segList.addPt(new g(t.x - this.distance, t.y - this.distance)), this.segList.addPt(new g(t.x - this.distance, t.y + this.distance)), this.segList.closeRing();\n    },\n    addSegments: function addSegments(t, e) {\n      this.segList.addPts(t, e);\n    },\n    addFirstSegment: function addFirstSegment() {\n      this.segList.addPt(this.offset1.p0);\n    },\n    addLastSegment: function addLastSegment() {\n      this.segList.addPt(this.offset1.p1);\n    },\n    initSideSegments: function initSideSegments(t, e, n) {\n      this.s1 = t, this.s2 = e, this.side = n, this.seg1.setCoordinates(t, e), this.computeOffsetSegment(this.seg1, n, this.distance, this.offset1);\n    },\n    addLimitedMitreJoin: function addLimitedMitreJoin(t, e, n, i) {\n      var r = this.seg0.p1,\n          s = hi.angle(r, this.seg0.p0),\n          o = (hi.angle(r, this.seg1.p1), hi.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1)),\n          a = o / 2,\n          u = hi.normalize(s + a),\n          l = hi.normalize(u + Math.PI),\n          h = i * n,\n          c = h * Math.abs(Math.sin(a)),\n          f = n - c,\n          d = r.x + h * Math.cos(l),\n          p = r.y + h * Math.sin(l),\n          v = new g(d, p),\n          m = new ce(r, v),\n          y = m.pointAlongOffset(1, f),\n          x = m.pointAlongOffset(1, -f);\n      this.side === cn.LEFT ? (this.segList.addPt(y), this.segList.addPt(x)) : (this.segList.addPt(x), this.segList.addPt(y));\n    },\n    computeOffsetSegment: function computeOffsetSegment(t, e, n, i) {\n      var r = e === cn.LEFT ? 1 : -1,\n          s = t.p1.x - t.p0.x,\n          o = t.p1.y - t.p0.y,\n          a = Math.sqrt(s * s + o * o),\n          u = r * n * s / a,\n          l = r * n * o / a;\n      i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;\n    },\n    addFilletArc: function addFilletArc(t, e, n, i, r) {\n      var s = i === he.CLOCKWISE ? -1 : 1,\n          o = Math.abs(e - n),\n          a = Math.trunc(o / this.filletAngleQuantum + .5);\n      if (1 > a) return null;\n      var u = null,\n          l = null;\n      u = 0, l = o / a;\n\n      for (var h = u, c = new g(); o > h;) {\n        var f = e + s * h;\n        c.x = t.x + r * Math.cos(f), c.y = t.y + r * Math.sin(f), this.segList.addPt(c), h += l;\n      }\n    },\n    addInsideTurn: function addInsideTurn(t, e) {\n      if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);else {\n        if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {\n          var n = new g((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));\n          this.segList.addPt(n);\n          var i = new g((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));\n          this.segList.addPt(i);\n        } else this.segList.addPt(this.s1);\n\n        this.segList.addPt(this.offset1.p0);\n      }\n    },\n    createCircle: function createCircle(t) {\n      var e = new g(t.x + this.distance, t.y);\n      this.segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing();\n    },\n    addBevelJoin: function addBevelJoin(t, e) {\n      this.segList.addPt(t.p1), this.segList.addPt(e.p0);\n    },\n    init: function init(t) {\n      this.distance = t, this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new Ui(), this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t * Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n    },\n    addCollinear: function addCollinear(t) {\n      this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);\n      var e = this.li.getIntersectionNum();\n      e >= 2 && (this.bufParams.getJoinStyle() === Bi.JOIN_BEVEL || this.bufParams.getJoinStyle() === Bi.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, he.CLOCKWISE, this.distance));\n    },\n    closeRing: function closeRing() {\n      this.segList.closeRing();\n    },\n    hasNarrowConcaveAngle: function hasNarrowConcaveAngle() {\n      return this._hasNarrowConcaveAngle;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Xi;\n    }\n  }), Xi.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Xi.MAX_CLOSING_SEG_LEN_FACTOR = 80, e(Hi.prototype, {\n    getOffsetCurve: function getOffsetCurve(t, e) {\n      if (this.distance = e, 0 === e) return null;\n      var n = 0 > e,\n          i = Math.abs(e),\n          r = this.getSegGen(i);\n      t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);\n      var s = r.getCoordinates();\n      return n && H.reverse(s), s;\n    },\n    computeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(t, e, n) {\n      var i = this.simplifyTolerance(this.distance);\n\n      if (e) {\n        n.addSegments(t, !0);\n        var r = Yi.simplify(t, -i),\n            s = r.length - 1;\n        n.initSideSegments(r[s], r[s - 1], cn.LEFT), n.addFirstSegment();\n\n        for (var o = s - 2; o >= 0; o--) {\n          n.addNextSegment(r[o], !0);\n        }\n      } else {\n        n.addSegments(t, !1);\n        var a = Yi.simplify(t, i),\n            u = a.length - 1;\n        n.initSideSegments(a[0], a[1], cn.LEFT), n.addFirstSegment();\n\n        for (var o = 2; u >= o; o++) {\n          n.addNextSegment(a[o], !0);\n        }\n      }\n\n      n.addLastSegment(), n.closeRing();\n    },\n    computeRingBufferCurve: function computeRingBufferCurve(t, e, n) {\n      var i = this.simplifyTolerance(this.distance);\n      e === cn.RIGHT && (i = -i);\n      var r = Yi.simplify(t, i),\n          s = r.length - 1;\n      n.initSideSegments(r[s - 1], r[0], e);\n\n      for (var o = 1; s >= o; o++) {\n        var a = 1 !== o;\n        n.addNextSegment(r[o], a);\n      }\n\n      n.closeRing();\n    },\n    computeLineBufferCurve: function computeLineBufferCurve(t, e) {\n      var n = this.simplifyTolerance(this.distance),\n          i = Yi.simplify(t, n),\n          r = i.length - 1;\n      e.initSideSegments(i[0], i[1], cn.LEFT);\n\n      for (var s = 2; r >= s; s++) {\n        e.addNextSegment(i[s], !0);\n      }\n\n      e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);\n      var o = Yi.simplify(t, -n),\n          a = o.length - 1;\n      e.initSideSegments(o[a], o[a - 1], cn.LEFT);\n\n      for (var s = a - 2; s >= 0; s--) {\n        e.addNextSegment(o[s], !0);\n      }\n\n      e.addLastSegment(), e.addLineEndCap(o[1], o[0]), e.closeRing();\n    },\n    computePointCurve: function computePointCurve(t, e) {\n      switch (this.bufParams.getEndCapStyle()) {\n        case Bi.CAP_ROUND:\n          e.createCircle(t);\n          break;\n\n        case Bi.CAP_SQUARE:\n          e.createSquare(t);\n      }\n    },\n    getLineCurve: function getLineCurve(t, e) {\n      if (this.distance = e, 0 > e && !this.bufParams.isSingleSided()) return null;\n      if (0 === e) return null;\n      var n = Math.abs(e),\n          i = this.getSegGen(n);\n      if (t.length <= 1) this.computePointCurve(t[0], i);else if (this.bufParams.isSingleSided()) {\n        var r = 0 > e;\n        this.computeSingleSidedBufferCurve(t, r, i);\n      } else this.computeLineBufferCurve(t, i);\n      var s = i.getCoordinates();\n      return s;\n    },\n    getBufferParameters: function getBufferParameters() {\n      return this.bufParams;\n    },\n    simplifyTolerance: function simplifyTolerance(t) {\n      return t * this.bufParams.getSimplifyFactor();\n    },\n    getRingCurve: function getRingCurve(t, e, n) {\n      if (this.distance = n, t.length <= 2) return this.getLineCurve(t, n);\n      if (0 === n) return Hi.copyCoordinates(t);\n      var i = this.getSegGen(n);\n      return this.computeRingBufferCurve(t, e, i), i.getCoordinates();\n    },\n    computeOffsetCurve: function computeOffsetCurve(t, e, n) {\n      var i = this.simplifyTolerance(this.distance);\n\n      if (e) {\n        var r = Yi.simplify(t, -i),\n            s = r.length - 1;\n        n.initSideSegments(r[s], r[s - 1], cn.LEFT), n.addFirstSegment();\n\n        for (var o = s - 2; o >= 0; o--) {\n          n.addNextSegment(r[o], !0);\n        }\n      } else {\n        var a = Yi.simplify(t, i),\n            u = a.length - 1;\n        n.initSideSegments(a[0], a[1], cn.LEFT), n.addFirstSegment();\n\n        for (var o = 2; u >= o; o++) {\n          n.addNextSegment(a[o], !0);\n        }\n      }\n\n      n.addLastSegment();\n    },\n    getSegGen: function getSegGen(t) {\n      return new Xi(this.precisionModel, this.bufParams, t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Hi;\n    }\n  }), Hi.copyCoordinates = function (t) {\n    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) {\n      e[n] = new g(t[n]);\n    }\n\n    return e;\n  }, e(Wi.prototype, {\n    findStabbedSegments: function findStabbedSegments() {\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = new I(), n = this.subgraphs.iterator(); n.hasNext();) {\n          var i = n.next(),\n              r = i.getEnvelope();\n          t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);\n        }\n\n        return e;\n      }\n\n      if (3 === arguments.length) if (R(arguments[2], y) && arguments[0] instanceof g && arguments[1] instanceof In) for (var s = arguments[0], o = arguments[1], a = arguments[2], u = o.getEdge().getCoordinates(), n = 0; n < u.length - 1; n++) {\n        this.seg.p0 = u[n], this.seg.p1 = u[n + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();\n        var l = Math.max(this.seg.p0.x, this.seg.p1.x);\n\n        if (!(l < s.x || this.seg.isHorizontal() || s.y < this.seg.p0.y || s.y > this.seg.p1.y || he.computeOrientation(this.seg.p0, this.seg.p1, s) === he.RIGHT)) {\n          var h = o.getDepth(cn.LEFT);\n          this.seg.p0.equals(u[n]) || (h = o.getDepth(cn.RIGHT));\n          var c = new ji(this.seg, h);\n          a.add(c);\n        }\n      } else if (R(arguments[2], y) && arguments[0] instanceof g && R(arguments[1], y)) for (var f = arguments[0], d = arguments[1], p = arguments[2], n = d.iterator(); n.hasNext();) {\n        var v = n.next();\n        v.isForward() && this.findStabbedSegments(f, v, p);\n      }\n    },\n    getDepth: function getDepth(t) {\n      var e = this.findStabbedSegments(t);\n      if (0 === e.size()) return 0;\n      var n = ho.min(e);\n      return n.leftDepth;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Wi;\n    }\n  }), e(ji.prototype, {\n    compareTo: function compareTo(t) {\n      var e = t;\n      if (this.upwardSeg.minX() >= e.upwardSeg.maxX()) return 1;\n      if (this.upwardSeg.maxX() <= e.upwardSeg.minX()) return -1;\n      var n = this.upwardSeg.orientationIndex(e.upwardSeg);\n      return 0 !== n ? n : (n = -1 * e.upwardSeg.orientationIndex(this.upwardSeg), 0 !== n ? n : this.upwardSeg.compareTo(e.upwardSeg));\n    },\n    compareX: function compareX(t, e) {\n      var n = t.p0.compareTo(e.p0);\n      return 0 !== n ? n : t.p1.compareTo(e.p1);\n    },\n    toString: function toString() {\n      return this.upwardSeg.toString();\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return ji;\n    }\n  }), Wi.DepthSegment = ji, e(Ki.prototype, {\n    addPoint: function addPoint(t) {\n      if (this.distance <= 0) return null;\n      var e = t.getCoordinates(),\n          n = this.curveBuilder.getLineCurve(e, this.distance);\n      this.addCurve(n, L.EXTERIOR, L.INTERIOR);\n    },\n    addPolygon: function addPolygon(t) {\n      var e = this.distance,\n          n = cn.LEFT;\n      this.distance < 0 && (e = -this.distance, n = cn.RIGHT);\n      var i = t.getExteriorRing(),\n          r = H.removeRepeatedPoints(i.getCoordinates());\n      if (this.distance < 0 && this.isErodedCompletely(i, this.distance)) return null;\n      if (this.distance <= 0 && r.length < 3) return null;\n      this.addPolygonRing(r, e, n, L.EXTERIOR, L.INTERIOR);\n\n      for (var s = 0; s < t.getNumInteriorRing(); s++) {\n        var o = t.getInteriorRingN(s),\n            a = H.removeRepeatedPoints(o.getCoordinates());\n        this.distance > 0 && this.isErodedCompletely(o, -this.distance) || this.addPolygonRing(a, e, cn.opposite(n), L.INTERIOR, L.EXTERIOR);\n      }\n    },\n    isTriangleErodedCompletely: function isTriangleErodedCompletely(t, e) {\n      var n = new ci(t[0], t[1], t[2]),\n          i = n.inCentre(),\n          r = he.distancePointLine(i, n.p0, n.p1);\n      return r < Math.abs(e);\n    },\n    addLineString: function addLineString(t) {\n      if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;\n      var e = H.removeRepeatedPoints(t.getCoordinates()),\n          n = this.curveBuilder.getLineCurve(e, this.distance);\n      this.addCurve(n, L.EXTERIOR, L.INTERIOR);\n    },\n    addCurve: function addCurve(t, e, n) {\n      if (null === t || t.length < 2) return null;\n      var i = new Ke(t, new gn(0, L.BOUNDARY, e, n));\n      this.curveList.add(i);\n    },\n    getCurves: function getCurves() {\n      return this.add(this.inputGeom), this.curveList;\n    },\n    addPolygonRing: function addPolygonRing(t, e, n, i, r) {\n      if (0 === e && t.length < bt.MINIMUM_VALID_SIZE) return null;\n      var s = i,\n          o = r;\n      t.length >= bt.MINIMUM_VALID_SIZE && he.isCCW(t) && (s = r, o = i, n = cn.opposite(n));\n      var a = this.curveBuilder.getRingCurve(t, n, e);\n      this.addCurve(a, s, o);\n    },\n    add: function add(t) {\n      if (t.isEmpty()) return null;\n      if (t instanceof Tt) this.addPolygon(t);else if (t instanceof St) this.addLineString(t);else if (t instanceof Lt) this.addPoint(t);else if (t instanceof Pt) this.addCollection(t);else if (t instanceof gt) this.addCollection(t);else if (t instanceof Ot) this.addCollection(t);else {\n        if (!(t instanceof ft)) throw new UnsupportedOperationException(t.getClass().getName());\n        this.addCollection(t);\n      }\n    },\n    isErodedCompletely: function isErodedCompletely(t, e) {\n      var n = t.getCoordinates();\n      if (n.length < 4) return 0 > e;\n      if (4 === n.length) return this.isTriangleErodedCompletely(n, e);\n      var i = t.getEnvelopeInternal(),\n          r = Math.min(i.getHeight(), i.getWidth());\n      return 0 > e && 2 * Math.abs(e) > r;\n    },\n    addCollection: function addCollection(t) {\n      for (var e = 0; e < t.getNumGeometries(); e++) {\n        var n = t.getGeometryN(e);\n        this.add(n);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ki;\n    }\n  }), e(Zi.prototype, {\n    isTrivialIntersection: function isTrivialIntersection(t, e, n, i) {\n      if (t === n && 1 === this.li.getIntersectionNum()) {\n        if (Zi.isAdjacentSegments(e, i)) return !0;\n\n        if (t.isClosed()) {\n          var r = t.size() - 1;\n          if (0 === e && i === r || 0 === i && e === r) return !0;\n        }\n      }\n\n      return !1;\n    },\n    getProperIntersectionPoint: function getProperIntersectionPoint() {\n      return this.properIntersectionPoint;\n    },\n    hasProperInteriorIntersection: function hasProperInteriorIntersection() {\n      return this.hasProperInterior;\n    },\n    getLineIntersector: function getLineIntersector() {\n      return this.li;\n    },\n    hasProperIntersection: function hasProperIntersection() {\n      return this.hasProper;\n    },\n    processIntersections: function processIntersections(t, e, n, i) {\n      if (t === n && e === i) return null;\n      this.numTests++;\n      var r = t.getCoordinates()[e],\n          s = t.getCoordinates()[e + 1],\n          o = n.getCoordinates()[i],\n          a = n.getCoordinates()[i + 1];\n      this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)));\n    },\n    hasIntersection: function hasIntersection() {\n      return this._hasIntersection;\n    },\n    isDone: function isDone() {\n      return !1;\n    },\n    hasInteriorIntersection: function hasInteriorIntersection() {\n      return this.hasInterior;\n    },\n    interfaces_: function interfaces_() {\n      return [on];\n    },\n    getClass: function getClass() {\n      return Zi;\n    }\n  }), Zi.isAdjacentSegments = function (t, e) {\n    return 1 === Math.abs(t - e);\n  }, e(Qi.prototype, {\n    setWorkingPrecisionModel: function setWorkingPrecisionModel(t) {\n      this.workingPrecisionModel = t;\n    },\n    insertUniqueEdge: function insertUniqueEdge(t) {\n      var e = this.edgeList.findEqualEdge(t);\n\n      if (null !== e) {\n        var n = e.getLabel(),\n            i = t.getLabel();\n        e.isPointwiseEqual(t) || (i = new gn(t.getLabel()), i.flip()), n.merge(i);\n        var r = Qi.depthDelta(i),\n            s = e.getDepthDelta(),\n            o = s + r;\n        e.setDepthDelta(o);\n      } else this.edgeList.add(t), t.setDepthDelta(Qi.depthDelta(t.getLabel()));\n    },\n    buildSubgraphs: function buildSubgraphs(t, e) {\n      for (var n = new I(), i = t.iterator(); i.hasNext();) {\n        var r = i.next(),\n            s = r.getRightmostCoordinate(),\n            o = new Wi(n),\n            a = o.getDepth(s);\n        r.computeDepth(a), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());\n      }\n    },\n    createSubgraphs: function createSubgraphs(t) {\n      for (var e = new I(), n = t.getNodes().iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (!i.isVisited()) {\n          var r = new ki();\n          r.create(i), e.add(r);\n        }\n      }\n\n      return ho.sort(e, ho.reverseOrder()), e;\n    },\n    createEmptyResultGeometry: function createEmptyResultGeometry() {\n      var t = this.geomFact.createPolygon();\n      return t;\n    },\n    getNoder: function getNoder(t) {\n      if (null !== this.workingNoder) return this.workingNoder;\n      var e = new nn(),\n          n = new ae();\n      return n.setPrecisionModel(t), e.setSegmentIntersector(new Zi(n)), e;\n    },\n    buffer: function buffer(t, e) {\n      var n = this.workingPrecisionModel;\n      null === n && (n = t.getPrecisionModel()), this.geomFact = t.getFactory();\n      var i = new Hi(n, this.bufParams),\n          r = new Ki(t, e, i),\n          s = r.getCurves();\n      if (s.size() <= 0) return this.createEmptyResultGeometry();\n      this.computeNodedEdges(s, n), this.graph = new Cn(new On()), this.graph.addEdges(this.edgeList.getEdges());\n      var o = this.createSubgraphs(this.graph),\n          a = new Sn(this.geomFact);\n      this.buildSubgraphs(o, a);\n      var u = a.getPolygons();\n      if (u.size() <= 0) return this.createEmptyResultGeometry();\n      var l = this.geomFact.buildGeometry(u);\n      return l;\n    },\n    computeNodedEdges: function computeNodedEdges(t, e) {\n      var n = this.getNoder(e);\n      n.computeNodes(t);\n\n      for (var i = n.getNodedSubstrings(), r = i.iterator(); r.hasNext();) {\n        var s = r.next(),\n            o = s.getCoordinates();\n\n        if (2 !== o.length || !o[0].equals2D(o[1])) {\n          var a = s.getData(),\n              u = new Jn(s.getCoordinates(), new gn(a));\n          this.insertUniqueEdge(u);\n        }\n      }\n    },\n    setNoder: function setNoder(t) {\n      this.workingNoder = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Qi;\n    }\n  }), Qi.depthDelta = function (t) {\n    var e = t.getLocation(0, cn.LEFT),\n        n = t.getLocation(0, cn.RIGHT);\n    return e === L.INTERIOR && n === L.EXTERIOR ? 1 : e === L.EXTERIOR && n === L.INTERIOR ? -1 : 0;\n  }, Qi.convertSegStrings = function (t) {\n    for (var e = new ie(), n = new I(); t.hasNext();) {\n      var i = t.next(),\n          r = e.createLineString(i.getCoordinates());\n      n.add(r);\n    }\n\n    return e.buildGeometry(n);\n  }, e(Ji.prototype, {\n    checkEndPtVertexIntersections: function checkEndPtVertexIntersections() {\n      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getCoordinates();\n        this.checkEndPtVertexIntersections(n[0], this.segStrings), this.checkEndPtVertexIntersections(n[n.length - 1], this.segStrings);\n      } else if (2 === arguments.length) for (var i = arguments[0], r = arguments[1], t = r.iterator(); t.hasNext();) {\n        for (var e = t.next(), n = e.getCoordinates(), s = 1; s < n.length - 1; s++) {\n          if (n[s].equals(i)) throw new l(\"found endpt/interior pt intersection at index \" + s + \" :pt \" + i);\n        }\n      }\n    },\n    checkInteriorIntersections: function checkInteriorIntersections() {\n      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {\n        for (var e = t.next(), n = this.segStrings.iterator(); n.hasNext();) {\n          var i = n.next();\n          this.checkInteriorIntersections(e, i);\n        }\n      } else if (2 === arguments.length) for (var r = arguments[0], s = arguments[1], o = r.getCoordinates(), a = s.getCoordinates(), u = 0; u < o.length - 1; u++) {\n        for (var h = 0; h < a.length - 1; h++) {\n          this.checkInteriorIntersections(r, u, s, h);\n        }\n      } else if (4 === arguments.length) {\n        var c = arguments[0],\n            f = arguments[1],\n            g = arguments[2],\n            d = arguments[3];\n        if (c === g && f === d) return null;\n        var p = c.getCoordinates()[f],\n            v = c.getCoordinates()[f + 1],\n            m = g.getCoordinates()[d],\n            y = g.getCoordinates()[d + 1];\n        if (this.li.computeIntersection(p, v, m, y), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p, v) || this.hasInteriorIntersection(this.li, m, y))) throw new l(\"found non-noded intersection at \" + p + \"-\" + v + \" and \" + m + \"-\" + y);\n      }\n    },\n    checkValid: function checkValid() {\n      this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();\n    },\n    checkCollapses: function checkCollapses() {\n      if (0 === arguments.length) for (var t = this.segStrings.iterator(); t.hasNext();) {\n        var e = t.next();\n        this.checkCollapses(e);\n      } else if (1 === arguments.length) for (var n = arguments[0], i = n.getCoordinates(), t = 0; t < i.length - 2; t++) {\n        this.checkCollapse(i[t], i[t + 1], i[t + 2]);\n      }\n    },\n    hasInteriorIntersection: function hasInteriorIntersection(t, e, n) {\n      for (var i = 0; i < t.getIntersectionNum(); i++) {\n        var r = t.getIntersection(i);\n        if (!r.equals(e) && !r.equals(n)) return !0;\n      }\n\n      return !1;\n    },\n    checkCollapse: function checkCollapse(t, e, n) {\n      if (t.equals(n)) throw new l(\"found non-noded collapse at \" + Ji.fact.createLineString([t, e, n]));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ji;\n    }\n  }), Ji.fact = new ie(), e($i.prototype, {\n    intersectsScaled: function intersectsScaled(t, e) {\n      var n = Math.min(t.x, e.x),\n          i = Math.max(t.x, e.x),\n          r = Math.min(t.y, e.y),\n          s = Math.max(t.y, e.y),\n          o = this.maxx < n || this.minx > i || this.maxy < r || this.miny > s;\n      if (o) return !1;\n      var a = this.intersectsToleranceSquare(t, e);\n      return f.isTrue(!(o && a), \"Found bad envelope test\"), a;\n    },\n    initCorners: function initCorners(t) {\n      var e = .5;\n      this.minx = t.x - e, this.maxx = t.x + e, this.miny = t.y - e, this.maxy = t.y + e, this.corner[0] = new g(this.maxx, this.maxy), this.corner[1] = new g(this.minx, this.maxy), this.corner[2] = new g(this.minx, this.miny), this.corner[3] = new g(this.maxx, this.miny);\n    },\n    intersects: function intersects(t, e) {\n      return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled));\n    },\n    scale: function scale(t) {\n      return Math.round(t * this.scaleFactor);\n    },\n    getCoordinate: function getCoordinate() {\n      return this.originalPt;\n    },\n    copyScaled: function copyScaled(t, e) {\n      e.x = this.scale(t.x), e.y = this.scale(t.y);\n    },\n    getSafeEnvelope: function getSafeEnvelope() {\n      if (null === this.safeEnv) {\n        var t = $i.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;\n        this.safeEnv = new C(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t);\n      }\n\n      return this.safeEnv;\n    },\n    intersectsPixelClosure: function intersectsPixelClosure(t, e) {\n      return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), this.li.hasIntersection() ? !0 : (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), this.li.hasIntersection() ? !0 : (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), this.li.hasIntersection() ? !0 : (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.hasIntersection())));\n    },\n    intersectsToleranceSquare: function intersectsToleranceSquare(t, e) {\n      var n = !1,\n          i = !1;\n      return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), this.li.isProper() ? !0 : (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), this.li.isProper() ? !0 : (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), this.li.isProper() ? !0 : (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), this.li.isProper() ? !0 : n && i ? !0 : t.equals(this.pt) ? !0 : !!e.equals(this.pt))));\n    },\n    addSnappedNode: function addSnappedNode(t, e) {\n      var n = t.getCoordinate(e),\n          i = t.getCoordinate(e + 1);\n      return this.intersects(n, i) ? (t.addIntersection(this.getCoordinate(), e), !0) : !1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return $i;\n    }\n  }), $i.SAFE_ENV_EXPANSION_FACTOR = .75, e(tr.prototype, {\n    select: function select() {\n      if (1 === arguments.length) {\n        arguments[0];\n      } else if (2 === arguments.length) {\n        var t = arguments[0],\n            e = arguments[1];\n        t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return tr;\n    }\n  }), e(er.prototype, {\n    snap: function snap() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.snap(t, null, -1);\n      }\n\n      if (3 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = arguments[2],\n            r = e.getSafeEnvelope(),\n            s = new nr(e, n, i);\n        return this.index.query(r, {\n          interfaces_: function interfaces_() {\n            return [Ae];\n          },\n          visitItem: function visitItem(t) {\n            var e = t;\n            e.select(r, s);\n          }\n        }), s.isNodeAdded();\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return er;\n    }\n  }), h(nr, tr), e(nr.prototype, {\n    isNodeAdded: function isNodeAdded() {\n      return this._isNodeAdded;\n    },\n    select: function select() {\n      if (2 !== arguments.length) return tr.prototype.select.apply(this, arguments);\n      var t = arguments[0],\n          e = arguments[1],\n          n = t.getContext();\n      return null !== this.parentEdge && n === this.parentEdge && e === this.hotPixelVertexIndex ? null : void (this._isNodeAdded = this.hotPixel.addSnappedNode(n, e));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return nr;\n    }\n  }), er.HotPixelSnapAction = nr, e(ir.prototype, {\n    processIntersections: function processIntersections(t, e, n, i) {\n      if (t === n && e === i) return null;\n      var r = t.getCoordinates()[e],\n          s = t.getCoordinates()[e + 1],\n          o = n.getCoordinates()[i],\n          a = n.getCoordinates()[i + 1];\n\n      if (this.li.computeIntersection(r, s, o, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {\n        for (var u = 0; u < this.li.getIntersectionNum(); u++) {\n          this.interiorIntersections.add(this.li.getIntersection(u));\n        }\n\n        t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1);\n      }\n    },\n    isDone: function isDone() {\n      return !1;\n    },\n    getInteriorIntersections: function getInteriorIntersections() {\n      return this.interiorIntersections;\n    },\n    interfaces_: function interfaces_() {\n      return [on];\n    },\n    getClass: function getClass() {\n      return ir;\n    }\n  }), e(rr.prototype, {\n    checkCorrectness: function checkCorrectness(t) {\n      var e = Ke.getNodedSubstrings(t),\n          n = new Ji(e);\n\n      try {\n        n.checkValid();\n      } catch (t) {\n        if (!(t instanceof S)) throw t;\n        t.printStackTrace();\n      } finally {}\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      return Ke.getNodedSubstrings(this.nodedSegStrings);\n    },\n    snapRound: function snapRound(t, e) {\n      var n = this.findInteriorIntersections(t, e);\n      this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);\n    },\n    findInteriorIntersections: function findInteriorIntersections(t, e) {\n      var n = new ir(e);\n      return this.noder.setSegmentIntersector(n), this.noder.computeNodes(t), n.getInteriorIntersections();\n    },\n    computeVertexSnaps: function computeVertexSnaps() {\n      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.computeVertexSnaps(n);\n      } else if (arguments[0] instanceof Ke) for (var i = arguments[0], r = i.getCoordinates(), s = 0; s < r.length; s++) {\n        var o = new $i(r[s], this.scaleFactor, this.li),\n            a = this.pointSnapper.snap(o, i, s);\n        a && i.addIntersection(r[s], s);\n      }\n    },\n    computeNodes: function computeNodes(t) {\n      this.nodedSegStrings = t, this.noder = new nn(), this.pointSnapper = new er(this.noder.getIndex()), this.snapRound(t, this.li);\n    },\n    computeIntersectionSnaps: function computeIntersectionSnaps(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = new $i(n, this.scaleFactor, this.li);\n        this.pointSnapper.snap(i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [tn];\n    },\n    getClass: function getClass() {\n      return rr;\n    }\n  }), e(sr.prototype, {\n    bufferFixedPrecision: function bufferFixedPrecision(t) {\n      var e = new Fi(new rr(new ee(1)), t.getScale()),\n          n = new Qi(this.bufParams);\n      n.setWorkingPrecisionModel(t), n.setNoder(e), this.resultGeometry = n.buffer(this.argGeom, this.distance);\n    },\n    bufferReducedPrecision: function bufferReducedPrecision() {\n      if (0 === arguments.length) {\n        for (var t = sr.MAX_PRECISION_DIGITS; t >= 0; t--) {\n          try {\n            this.bufferReducedPrecision(t);\n          } catch (t) {\n            if (!(t instanceof sn)) throw t;\n            this.saveException = t;\n          } finally {}\n\n          if (null !== this.resultGeometry) return null;\n        }\n\n        throw this.saveException;\n      }\n\n      if (1 === arguments.length) {\n        var e = arguments[0],\n            n = sr.precisionScaleFactor(this.argGeom, this.distance, e),\n            i = new ee(n);\n        this.bufferFixedPrecision(i);\n      }\n    },\n    computeGeometry: function computeGeometry() {\n      if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;\n      var t = this.argGeom.getFactory().getPrecisionModel();\n      t.getType() === ee.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();\n    },\n    setQuadrantSegments: function setQuadrantSegments(t) {\n      this.bufParams.setQuadrantSegments(t);\n    },\n    bufferOriginalPrecision: function bufferOriginalPrecision() {\n      try {\n        var t = new Qi(this.bufParams);\n        this.resultGeometry = t.buffer(this.argGeom, this.distance);\n      } catch (t) {\n        if (!(t instanceof l)) throw t;\n        this.saveException = t;\n      } finally {}\n    },\n    getResultGeometry: function getResultGeometry(t) {\n      return this.distance = t, this.computeGeometry(), this.resultGeometry;\n    },\n    setEndCapStyle: function setEndCapStyle(t) {\n      this.bufParams.setEndCapStyle(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return sr;\n    }\n  }), sr.bufferOp = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = new sr(t),\n          i = n.getResultGeometry(e);\n      return i;\n    }\n\n    if (3 === arguments.length) {\n      if (Number.isInteger(arguments[2]) && arguments[0] instanceof B && \"number\" == typeof arguments[1]) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2],\n            a = new sr(r);\n        a.setQuadrantSegments(o);\n        var i = a.getResultGeometry(s);\n        return i;\n      }\n\n      if (arguments[2] instanceof Bi && arguments[0] instanceof B && \"number\" == typeof arguments[1]) {\n        var u = arguments[0],\n            l = arguments[1],\n            h = arguments[2],\n            a = new sr(u, h),\n            i = a.getResultGeometry(l);\n        return i;\n      }\n    } else if (4 === arguments.length) {\n      var c = arguments[0],\n          f = arguments[1],\n          g = arguments[2],\n          d = arguments[3],\n          a = new sr(c);\n      a.setQuadrantSegments(g), a.setEndCapStyle(d);\n      var i = a.getResultGeometry(f);\n      return i;\n    }\n  }, sr.precisionScaleFactor = function (t, e, n) {\n    var i = t.getEnvelopeInternal(),\n        r = T.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())),\n        s = e > 0 ? e : 0,\n        o = r + 2 * s,\n        a = Math.trunc(Math.log(o) / Math.log(10) + 1),\n        u = n - a,\n        l = Math.pow(10, u);\n    return l;\n  }, sr.CAP_ROUND = Bi.CAP_ROUND, sr.CAP_BUTT = Bi.CAP_FLAT, sr.CAP_FLAT = Bi.CAP_FLAT, sr.CAP_SQUARE = Bi.CAP_SQUARE, sr.MAX_PRECISION_DIGITS = 12;\n  var Co = Object.freeze({\n    BufferOp: sr,\n    BufferParameters: Bi\n  });\n  e(or.prototype, {\n    filter: function filter(t) {\n      t instanceof Tt && this.comps.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [ht];\n    },\n    getClass: function getClass() {\n      return or;\n    }\n  }), or.getPolygons = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return or.getPolygons(t, new I());\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e instanceof Tt ? n.add(e) : e instanceof ft && e.apply(new or(n)), n;\n    }\n  }, e(ar.prototype, {\n    isInsideArea: function isInsideArea() {\n      return this.segIndex === ar.INSIDE_AREA;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    getGeometryComponent: function getGeometryComponent() {\n      return this.component;\n    },\n    getSegmentIndex: function getSegmentIndex() {\n      return this.segIndex;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ar;\n    }\n  }), ar.INSIDE_AREA = -1, e(ur.prototype, {\n    filter: function filter(t) {\n      t instanceof Lt && this.pts.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [ht];\n    },\n    getClass: function getClass() {\n      return ur;\n    }\n  }), ur.getPoints = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return t instanceof Lt ? ho.singletonList(t) : ur.getPoints(t, new I());\n    }\n\n    if (2 === arguments.length) {\n      var e = arguments[0],\n          n = arguments[1];\n      return e instanceof Lt ? n.add(e) : e instanceof ft && e.apply(new ur(n)), n;\n    }\n  }, e(lr.prototype, {\n    filter: function filter(t) {\n      (t instanceof Lt || t instanceof St || t instanceof Tt) && this.locations.add(new ar(t, 0, t.getCoordinate()));\n    },\n    interfaces_: function interfaces_() {\n      return [ht];\n    },\n    getClass: function getClass() {\n      return lr;\n    }\n  }), lr.getLocations = function (t) {\n    var e = new I();\n    return t.apply(new lr(e)), e;\n  }, e(hr.prototype, {\n    computeContainmentDistance: function computeContainmentDistance() {\n      if (0 === arguments.length) {\n        var t = new Array(2).fill(null);\n        if (this.computeContainmentDistance(0, t), this.minDistance <= this.terminateDistance) return null;\n        this.computeContainmentDistance(1, t);\n      } else if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = 1 - e,\n            r = or.getPolygons(this.geom[e]);\n\n        if (r.size() > 0) {\n          var s = lr.getLocations(this.geom[i]);\n          if (this.computeContainmentDistance(s, r, n), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[i] = n[0], this.minDistanceLocation[e] = n[1], null;\n        }\n      } else if (3 === arguments.length) if (arguments[2] instanceof Array && R(arguments[0], y) && R(arguments[1], y)) {\n        for (var o = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < o.size(); l++) {\n          for (var h = o.get(l), c = 0; c < a.size(); c++) {\n            if (this.computeContainmentDistance(h, a.get(c), u), this.minDistance <= this.terminateDistance) return null;\n          }\n        }\n      } else if (arguments[2] instanceof Array && arguments[0] instanceof ar && arguments[1] instanceof Tt) {\n        var f = arguments[0],\n            g = arguments[1],\n            d = arguments[2],\n            p = f.getCoordinate();\n        if (L.EXTERIOR !== this.ptLocator.locate(p, g)) return this.minDistance = 0, d[0] = f, d[1] = new ar(g, p), null;\n      }\n    },\n    computeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(t, e, n) {\n      for (var i = 0; i < t.size(); i++) {\n        for (var r = t.get(i), s = 0; s < e.size(); s++) {\n          var o = e.get(s);\n          if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;\n        }\n      }\n    },\n    computeFacetDistance: function computeFacetDistance() {\n      var t = new Array(2).fill(null),\n          e = kn.getLines(this.geom[0]),\n          n = kn.getLines(this.geom[1]),\n          i = ur.getPoints(this.geom[0]),\n          r = ur.getPoints(this.geom[1]);\n      return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, r, t), void this.updateMinDistance(t, !1))));\n    },\n    nearestLocations: function nearestLocations() {\n      return this.computeMinDistance(), this.minDistanceLocation;\n    },\n    updateMinDistance: function updateMinDistance(t, e) {\n      return null === t[0] ? null : void (e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1]));\n    },\n    nearestPoints: function nearestPoints() {\n      this.computeMinDistance();\n      var t = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];\n      return t;\n    },\n    computeMinDistance: function computeMinDistance() {\n      if (0 === arguments.length) {\n        if (null !== this.minDistanceLocation) return null;\n        if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance) return null;\n        this.computeFacetDistance();\n      } else if (3 === arguments.length) if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof Lt) {\n        var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n        if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance) return null;\n\n        for (var i = t.getCoordinates(), r = e.getCoordinate(), s = 0; s < i.length - 1; s++) {\n          var o = he.distancePointLine(r, i[s], i[s + 1]);\n\n          if (o < this.minDistance) {\n            this.minDistance = o;\n            var a = new ce(i[s], i[s + 1]),\n                u = a.closestPoint(r);\n            n[0] = new ar(t, s, u), n[1] = new ar(e, 0, r);\n          }\n\n          if (this.minDistance <= this.terminateDistance) return null;\n        }\n      } else if (arguments[2] instanceof Array && arguments[0] instanceof St && arguments[1] instanceof St) {\n        var l = arguments[0],\n            h = arguments[1],\n            c = arguments[2];\n        if (l.getEnvelopeInternal().distance(h.getEnvelopeInternal()) > this.minDistance) return null;\n\n        for (var i = l.getCoordinates(), f = h.getCoordinates(), s = 0; s < i.length - 1; s++) {\n          for (var g = 0; g < f.length - 1; g++) {\n            var o = he.distanceLineLine(i[s], i[s + 1], f[g], f[g + 1]);\n\n            if (o < this.minDistance) {\n              this.minDistance = o;\n              var d = new ce(i[s], i[s + 1]),\n                  p = new ce(f[g], f[g + 1]),\n                  v = d.closestPoints(p);\n              c[0] = new ar(l, s, v[0]), c[1] = new ar(h, g, v[1]);\n            }\n\n            if (this.minDistance <= this.terminateDistance) return null;\n          }\n        }\n      }\n    },\n    computeMinDistancePoints: function computeMinDistancePoints(t, e, n) {\n      for (var i = 0; i < t.size(); i++) {\n        for (var r = t.get(i), s = 0; s < e.size(); s++) {\n          var o = e.get(s),\n              a = r.getCoordinate().distance(o.getCoordinate());\n          if (a < this.minDistance && (this.minDistance = a, n[0] = new ar(r, 0, r.getCoordinate()), n[1] = new ar(o, 0, o.getCoordinate())), this.minDistance <= this.terminateDistance) return null;\n        }\n      }\n    },\n    distance: function distance() {\n      if (null === this.geom[0] || null === this.geom[1]) throw new i(\"null geometries are not supported\");\n      return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance);\n    },\n    computeMinDistanceLines: function computeMinDistanceLines(t, e, n) {\n      for (var i = 0; i < t.size(); i++) {\n        for (var r = t.get(i), s = 0; s < e.size(); s++) {\n          var o = e.get(s);\n          if (this.computeMinDistance(r, o, n), this.minDistance <= this.terminateDistance) return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return hr;\n    }\n  }), hr.distance = function (t, e) {\n    var n = new hr(t, e);\n    return n.distance();\n  }, hr.isWithinDistance = function (t, e, n) {\n    var i = new hr(t, e, n);\n    return i.distance() <= n;\n  }, hr.nearestPoints = function (t, e) {\n    var n = new hr(t, e);\n    return n.nearestPoints();\n  };\n  var So = Object.freeze({\n    DistanceOp: hr\n  });\n  e(cr.prototype, {\n    getCoordinates: function getCoordinates() {\n      if (null === this.coordinates) {\n        for (var t = 0, e = 0, n = new N(), i = this.directedEdges.iterator(); i.hasNext();) {\n          var r = i.next();\n          r.getEdgeDirection() ? t++ : e++, n.add(r.getEdge().getLine().getCoordinates(), !1, r.getEdgeDirection());\n        }\n\n        this.coordinates = n.toCoordinateArray(), e > t && H.reverse(this.coordinates);\n      }\n\n      return this.coordinates;\n    },\n    toLineString: function toLineString() {\n      return this.factory.createLineString(this.getCoordinates());\n    },\n    add: function add(t) {\n      this.directedEdges.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return cr;\n    }\n  }), e(fr.prototype, {\n    setVisited: function setVisited(t) {\n      this._isVisited = t;\n    },\n    isMarked: function isMarked() {\n      return this._isMarked;\n    },\n    setData: function setData(t) {\n      this.data = t;\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    setMarked: function setMarked(t) {\n      this._isMarked = t;\n    },\n    getContext: function getContext() {\n      return this.data;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    setContext: function setContext(t) {\n      this.data = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return fr;\n    }\n  }), fr.getComponentWithVisitedState = function (t, e) {\n    for (; t.hasNext();) {\n      var n = t.next();\n      if (n.isVisited() === e) return n;\n    }\n\n    return null;\n  }, fr.setVisited = function (t, e) {\n    for (; t.hasNext();) {\n      var n = t.next();\n      n.setVisited(e);\n    }\n  }, fr.setMarked = function (t, e) {\n    for (; t.hasNext();) {\n      var n = t.next();\n      n.setMarked(e);\n    }\n  }, h(gr, fr), e(gr.prototype, {\n    isRemoved: function isRemoved() {\n      return null === this.parentEdge;\n    },\n    compareDirection: function compareDirection(t) {\n      return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : he.computeOrientation(t.p0, t.p1, this.p1);\n    },\n    getCoordinate: function getCoordinate() {\n      return this.from.getCoordinate();\n    },\n    print: function print(t) {\n      var e = this.getClass().getName(),\n          n = e.lastIndexOf(\".\"),\n          i = e.substring(n + 1);\n      t.print(\"  \" + i + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + this.angle);\n    },\n    getDirectionPt: function getDirectionPt() {\n      return this.p1;\n    },\n    getAngle: function getAngle() {\n      return this.angle;\n    },\n    compareTo: function compareTo(t) {\n      var e = t;\n      return this.compareDirection(e);\n    },\n    getFromNode: function getFromNode() {\n      return this.from;\n    },\n    getSym: function getSym() {\n      return this.sym;\n    },\n    setEdge: function setEdge(t) {\n      this.parentEdge = t;\n    },\n    remove: function remove() {\n      this.sym = null, this.parentEdge = null;\n    },\n    getEdge: function getEdge() {\n      return this.parentEdge;\n    },\n    getQuadrant: function getQuadrant() {\n      return this.quadrant;\n    },\n    setSym: function setSym(t) {\n      this.sym = t;\n    },\n    getToNode: function getToNode() {\n      return this.to;\n    },\n    getEdgeDirection: function getEdgeDirection() {\n      return this.edgeDirection;\n    },\n    interfaces_: function interfaces_() {\n      return [s];\n    },\n    getClass: function getClass() {\n      return gr;\n    }\n  }), gr.toEdges = function (t) {\n    for (var e = new I(), n = t.iterator(); n.hasNext();) {\n      e.add(n.next().parentEdge);\n    }\n\n    return e;\n  }, h(dr, gr), e(dr.prototype, {\n    getNext: function getNext() {\n      return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (f.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return dr;\n    }\n  }), h(pr, fr), e(pr.prototype, {\n    isRemoved: function isRemoved() {\n      return null === this.dirEdge;\n    },\n    setDirectedEdges: function setDirectedEdges(t, e) {\n      this.dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e);\n    },\n    getDirEdge: function getDirEdge() {\n      if (Number.isInteger(arguments[0])) {\n        var t = arguments[0];\n        return this.dirEdge[t];\n      }\n\n      if (arguments[0] instanceof mr) {\n        var e = arguments[0];\n        return this.dirEdge[0].getFromNode() === e ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e ? this.dirEdge[1] : null;\n      }\n    },\n    remove: function remove() {\n      this.dirEdge = null;\n    },\n    getOppositeNode: function getOppositeNode(t) {\n      return this.dirEdge[0].getFromNode() === t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t ? this.dirEdge[1].getToNode() : null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return pr;\n    }\n  }), e(vr.prototype, {\n    getNextEdge: function getNextEdge(t) {\n      var e = this.getIndex(t);\n      return this.outEdges.get(this.getIndex(e + 1));\n    },\n    getCoordinate: function getCoordinate() {\n      var t = this.iterator();\n      if (!t.hasNext()) return null;\n      var e = t.next();\n      return e.getCoordinate();\n    },\n    iterator: function iterator() {\n      return this.sortEdges(), this.outEdges.iterator();\n    },\n    sortEdges: function sortEdges() {\n      this.sorted || (ho.sort(this.outEdges), this.sorted = !0);\n    },\n    remove: function remove(t) {\n      this.outEdges.remove(t);\n    },\n    getEdges: function getEdges() {\n      return this.sortEdges(), this.outEdges;\n    },\n    getNextCWEdge: function getNextCWEdge(t) {\n      var e = this.getIndex(t);\n      return this.outEdges.get(this.getIndex(e - 1));\n    },\n    getIndex: function getIndex() {\n      if (arguments[0] instanceof pr) {\n        var t = arguments[0];\n        this.sortEdges();\n\n        for (var e = 0; e < this.outEdges.size(); e++) {\n          var n = this.outEdges.get(e);\n          if (n.getEdge() === t) return e;\n        }\n\n        return -1;\n      }\n\n      if (arguments[0] instanceof gr) {\n        var i = arguments[0];\n        this.sortEdges();\n\n        for (var e = 0; e < this.outEdges.size(); e++) {\n          var n = this.outEdges.get(e);\n          if (n === i) return e;\n        }\n\n        return -1;\n      }\n\n      if (Number.isInteger(arguments[0])) {\n        var r = arguments[0],\n            s = r % this.outEdges.size();\n        return 0 > s && (s += this.outEdges.size()), s;\n      }\n    },\n    add: function add(t) {\n      this.outEdges.add(t), this.sorted = !1;\n    },\n    getDegree: function getDegree() {\n      return this.outEdges.size();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return vr;\n    }\n  }), h(mr, fr), e(mr.prototype, {\n    isRemoved: function isRemoved() {\n      return null === this.pt;\n    },\n    addOutEdge: function addOutEdge(t) {\n      this.deStar.add(t);\n    },\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    getOutEdges: function getOutEdges() {\n      return this.deStar;\n    },\n    remove: function remove() {\n      if (0 === arguments.length) this.pt = null;else if (1 === arguments.length) {\n        var t = arguments[0];\n        this.deStar.remove(t);\n      }\n    },\n    getIndex: function getIndex(t) {\n      return this.deStar.getIndex(t);\n    },\n    getDegree: function getDegree() {\n      return this.deStar.getDegree();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return mr;\n    }\n  }), mr.getEdgesBetween = function (t, e) {\n    var n = gr.toEdges(t.getOutEdges().getEdges()),\n        i = new J(n),\n        r = gr.toEdges(e.getOutEdges().getEdges());\n    return i.retainAll(r), i;\n  }, h(yr, pr), e(yr.prototype, {\n    getLine: function getLine() {\n      return this.line;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return yr;\n    }\n  }), e(xr.prototype, {\n    find: function find(t) {\n      return this.nodeMap.get(t);\n    },\n    iterator: function iterator() {\n      return this.nodeMap.values().iterator();\n    },\n    remove: function remove(t) {\n      return this.nodeMap.remove(t);\n    },\n    values: function values() {\n      return this.nodeMap.values();\n    },\n    add: function add(t) {\n      return this.nodeMap.put(t.getCoordinate(), t), t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return xr;\n    }\n  }), e(Er.prototype, {\n    findNodesOfDegree: function findNodesOfDegree(t) {\n      for (var e = new I(), n = this.nodeIterator(); n.hasNext();) {\n        var i = n.next();\n        i.getDegree() === t && e.add(i);\n      }\n\n      return e;\n    },\n    dirEdgeIterator: function dirEdgeIterator() {\n      return this.dirEdges.iterator();\n    },\n    edgeIterator: function edgeIterator() {\n      return this.edges.iterator();\n    },\n    remove: function remove() {\n      if (arguments[0] instanceof pr) {\n        var t = arguments[0];\n        this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this.edges.remove(t), t.remove();\n      } else if (arguments[0] instanceof gr) {\n        var e = arguments[0],\n            n = e.getSym();\n        null !== n && n.setSym(null), e.getFromNode().remove(e), e.remove(), this.dirEdges.remove(e);\n      } else if (arguments[0] instanceof mr) {\n        for (var i = arguments[0], r = i.getOutEdges().getEdges(), s = r.iterator(); s.hasNext();) {\n          var o = s.next(),\n              n = o.getSym();\n          null !== n && this.remove(n), this.dirEdges.remove(o);\n          var a = o.getEdge();\n          null !== a && this.edges.remove(a);\n        }\n\n        this.nodeMap.remove(i.getCoordinate()), i.remove();\n      }\n    },\n    findNode: function findNode(t) {\n      return this.nodeMap.find(t);\n    },\n    getEdges: function getEdges() {\n      return this.edges;\n    },\n    nodeIterator: function nodeIterator() {\n      return this.nodeMap.iterator();\n    },\n    contains: function contains() {\n      if (arguments[0] instanceof pr) {\n        var t = arguments[0];\n        return this.edges.contains(t);\n      }\n\n      if (arguments[0] instanceof gr) {\n        var e = arguments[0];\n        return this.dirEdges.contains(e);\n      }\n    },\n    add: function add() {\n      if (arguments[0] instanceof mr) {\n        var t = arguments[0];\n        this.nodeMap.add(t);\n      } else if (arguments[0] instanceof pr) {\n        var e = arguments[0];\n        this.edges.add(e), this.add(e.getDirEdge(0)), this.add(e.getDirEdge(1));\n      } else if (arguments[0] instanceof gr) {\n        var n = arguments[0];\n        this.dirEdges.add(n);\n      }\n    },\n    getNodes: function getNodes() {\n      return this.nodeMap.values();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Er;\n    }\n  }), h(Ir, Er), e(Ir.prototype, {\n    addEdge: function addEdge(t) {\n      if (t.isEmpty()) return null;\n      var e = H.removeRepeatedPoints(t.getCoordinates());\n      if (e.length <= 1) return null;\n      var n = e[0],\n          i = e[e.length - 1],\n          r = this.getNode(n),\n          s = this.getNode(i),\n          o = new dr(r, s, e[1], !0),\n          a = new dr(s, r, e[e.length - 2], !1),\n          u = new yr(t);\n      u.setDirectedEdges(o, a), this.add(u);\n    },\n    getNode: function getNode(t) {\n      var e = this.findNode(t);\n      return null === e && (e = new mr(t), this.add(e)), e;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ir;\n    }\n  }), e(Nr.prototype, {\n    buildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {\n      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next();\n        e.isMarked() || (f.isTrue(2 === e.getDegree()), this.buildEdgeStringsStartingAt(e), e.setMarked(!0));\n      }\n    },\n    buildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {\n      for (var t = this.graph.getNodes().iterator(); t.hasNext();) {\n        var e = t.next();\n        2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e), e.setMarked(!0));\n      }\n    },\n    buildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {\n      this.buildEdgeStringsForNonDegree2Nodes();\n    },\n    getMergedLineStrings: function getMergedLineStrings() {\n      return this.merge(), this.mergedLineStrings;\n    },\n    buildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(t) {\n      for (var e = t.getOutEdges().iterator(); e.hasNext();) {\n        var n = e.next();\n        n.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(n));\n      }\n    },\n    merge: function merge() {\n      if (null !== this.mergedLineStrings) return null;\n      fr.setMarked(this.graph.nodeIterator(), !1), fr.setMarked(this.graph.edgeIterator(), !1), this.edgeStrings = new I(), this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this.mergedLineStrings = new I();\n\n      for (var t = this.edgeStrings.iterator(); t.hasNext();) {\n        var e = t.next();\n        this.mergedLineStrings.add(e.toLineString());\n      }\n    },\n    buildEdgeStringStartingWith: function buildEdgeStringStartingWith(t) {\n      var e = new cr(this.factory),\n          n = t;\n\n      do {\n        e.add(n), n.getEdge().setMarked(!0), n = n.getNext();\n      } while (null !== n && n !== t);\n\n      return e;\n    },\n    add: function add() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        t.apply({\n          interfaces_: function interfaces_() {\n            return [q];\n          },\n          filter: function filter(t) {\n            t instanceof St && this.add(t);\n          }\n        });\n      } else if (R(arguments[0], v)) {\n        var e = arguments[0];\n        this.mergedLineStrings = null;\n\n        for (var n = e.iterator(); n.hasNext();) {\n          var i = n.next();\n          this.add(i);\n        }\n      } else if (arguments[0] instanceof St) {\n        var r = arguments[0];\n        null === this.factory && (this.factory = r.getFactory()), this.graph.addEdge(r);\n      }\n    },\n    buildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {\n      this.buildEdgeStringsForUnprocessedNodes();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Nr;\n    }\n  });\n  var wo = Object.freeze({\n    LineMerger: Nr\n  }),\n      Lo = Object.freeze({\n    OverlayOp: ii\n  });\n  h(Cr, gr), e(Cr.prototype, {\n    getNext: function getNext() {\n      return this.next;\n    },\n    isInRing: function isInRing() {\n      return null !== this.edgeRing;\n    },\n    setRing: function setRing(t) {\n      this.edgeRing = t;\n    },\n    setLabel: function setLabel(t) {\n      this.label = t;\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    setNext: function setNext(t) {\n      this.next = t;\n    },\n    getRing: function getRing() {\n      return this.edgeRing;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Cr;\n    }\n  }), h(Sr, pr), e(Sr.prototype, {\n    getLine: function getLine() {\n      return this.line;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Sr;\n    }\n  }), e(wr.prototype, {\n    isIncluded: function isIncluded() {\n      return this._isIncluded;\n    },\n    getCoordinates: function getCoordinates() {\n      if (null === this.ringPts) {\n        for (var t = new N(), e = this.deList.iterator(); e.hasNext();) {\n          var n = e.next(),\n              i = n.getEdge();\n          wr.addEdge(i.getLine().getCoordinates(), n.getEdgeDirection(), t);\n        }\n\n        this.ringPts = t.toCoordinateArray();\n      }\n\n      return this.ringPts;\n    },\n    isIncludedSet: function isIncludedSet() {\n      return this._isIncludedSet;\n    },\n    isValid: function isValid() {\n      return this.getCoordinates(), this.ringPts.length <= 3 ? !1 : (this.getRing(), this.ring.isValid());\n    },\n    build: function build(t) {\n      var e = t;\n\n      do {\n        this.add(e), e.setRing(this), e = e.getNext(), f.isTrue(null !== e, \"found null DE in ring\"), f.isTrue(e === t || !e.isInRing(), \"found DE already in ring\");\n      } while (e !== t);\n    },\n    isOuterHole: function isOuterHole() {\n      return this._isHole ? !this.hasShell() : !1;\n    },\n    getPolygon: function getPolygon() {\n      var t = null;\n\n      if (null !== this.holes) {\n        t = new Array(this.holes.size()).fill(null);\n\n        for (var e = 0; e < this.holes.size(); e++) {\n          t[e] = this.holes.get(e);\n        }\n      }\n\n      var n = this.factory.createPolygon(this.ring, t);\n      return n;\n    },\n    isHole: function isHole() {\n      return this._isHole;\n    },\n    isProcessed: function isProcessed() {\n      return this._isProcessed;\n    },\n    addHole: function addHole() {\n      if (arguments[0] instanceof bt) {\n        var t = arguments[0];\n        null === this.holes && (this.holes = new I()), this.holes.add(t);\n      } else if (arguments[0] instanceof wr) {\n        var e = arguments[0];\n        e.setShell(this);\n        var n = e.getRing();\n        null === this.holes && (this.holes = new I()), this.holes.add(n);\n      }\n    },\n    setIncluded: function setIncluded(t) {\n      this._isIncluded = t, this._isIncludedSet = !0;\n    },\n    getOuterHole: function getOuterHole() {\n      if (this.isHole()) return null;\n\n      for (var t = 0; t < this.deList.size(); t++) {\n        var e = this.deList.get(t),\n            n = e.getSym().getRing();\n        if (n.isOuterHole()) return n;\n      }\n\n      return null;\n    },\n    computeHole: function computeHole() {\n      var t = this.getRing();\n      this._isHole = he.isCCW(t.getCoordinates());\n    },\n    hasShell: function hasShell() {\n      return null !== this.shell;\n    },\n    isOuterShell: function isOuterShell() {\n      return null !== this.getOuterHole();\n    },\n    getLineString: function getLineString() {\n      return this.getCoordinates(), this.factory.createLineString(this.ringPts);\n    },\n    toString: function toString() {\n      return se.toLineString(new Gt(this.getCoordinates()));\n    },\n    getShell: function getShell() {\n      return this.isHole() ? this.shell : this;\n    },\n    add: function add(t) {\n      this.deList.add(t);\n    },\n    getRing: function getRing() {\n      if (null !== this.ring) return this.ring;\n      this.getCoordinates(), this.ringPts.length < 3 && A.out.println(this.ringPts);\n\n      try {\n        this.ring = this.factory.createLinearRing(this.ringPts);\n      } catch (t) {\n        if (!(t instanceof S)) throw t;\n        A.out.println(this.ringPts);\n      } finally {}\n\n      return this.ring;\n    },\n    updateIncluded: function updateIncluded() {\n      if (this.isHole()) return null;\n\n      for (var t = 0; t < this.deList.size(); t++) {\n        var e = this.deList.get(t),\n            n = e.getSym().getRing().getShell();\n        if (null !== n && n.isIncludedSet()) return this.setIncluded(!n.isIncluded()), null;\n      }\n    },\n    setShell: function setShell(t) {\n      this.shell = t;\n    },\n    setProcessed: function setProcessed(t) {\n      this._isProcessed = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return wr;\n    }\n  }), wr.findDirEdgesInRing = function (t) {\n    var e = t,\n        n = new I();\n\n    do {\n      n.add(e), e = e.getNext(), f.isTrue(null !== e, \"found null DE in ring\"), f.isTrue(e === t || !e.isInRing(), \"found DE already in ring\");\n    } while (e !== t);\n\n    return n;\n  }, wr.addEdge = function (t, e, n) {\n    if (e) for (var i = 0; i < t.length; i++) {\n      n.add(t[i], !1);\n    } else for (var i = t.length - 1; i >= 0; i--) {\n      n.add(t[i], !1);\n    }\n  }, wr.findEdgeRingContaining = function (t, e) {\n    for (var n = t.getRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, o = null, a = e.iterator(); a.hasNext();) {\n      var u = a.next(),\n          l = u.getRing(),\n          h = l.getEnvelopeInternal();\n\n      if (!h.equals(i) && h.contains(i)) {\n        r = H.ptNotInList(n.getCoordinates(), l.getCoordinates());\n        var c = !1;\n        he.isPointInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || o.contains(h)) && (s = u, o = s.getRing().getEnvelopeInternal());\n      }\n    }\n\n    return s;\n  }, e(Lr.prototype, {\n    compare: function compare(t, e) {\n      var n = t,\n          i = e;\n      return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope());\n    },\n    interfaces_: function interfaces_() {\n      return [a];\n    },\n    getClass: function getClass() {\n      return Lr;\n    }\n  }), wr.EnvelopeComparator = Lr, h(Rr, Er), e(Rr.prototype, {\n    findEdgeRing: function findEdgeRing(t) {\n      var e = new wr(this.factory);\n      return e.build(t), e;\n    },\n    computeDepthParity: function computeDepthParity() {\n      if (0 === arguments.length) for (;;) {\n        var t = null;\n        if (null === t) return null;\n        this.computeDepthParity(t);\n      } else if (1 === arguments.length) {\n        arguments[0];\n      }\n    },\n    computeNextCWEdges: function computeNextCWEdges() {\n      for (var t = this.nodeIterator(); t.hasNext();) {\n        var e = t.next();\n        Rr.computeNextCWEdges(e);\n      }\n    },\n    addEdge: function addEdge(t) {\n      if (t.isEmpty()) return null;\n      var e = H.removeRepeatedPoints(t.getCoordinates());\n      if (e.length < 2) return null;\n      var n = e[0],\n          i = e[e.length - 1],\n          r = this.getNode(n),\n          s = this.getNode(i),\n          o = new Cr(r, s, e[1], !0),\n          a = new Cr(s, r, e[e.length - 2], !1),\n          u = new Sr(t);\n      u.setDirectedEdges(o, a), this.add(u);\n    },\n    deleteCutEdges: function deleteCutEdges() {\n      this.computeNextCWEdges(), Rr.findLabeledEdgeRings(this.dirEdges);\n\n      for (var t = new I(), e = this.dirEdges.iterator(); e.hasNext();) {\n        var n = e.next();\n\n        if (!n.isMarked()) {\n          var i = n.getSym();\n\n          if (n.getLabel() === i.getLabel()) {\n            n.setMarked(!0), i.setMarked(!0);\n            var r = n.getEdge();\n            t.add(r.getLine());\n          }\n        }\n      }\n\n      return t;\n    },\n    getEdgeRings: function getEdgeRings() {\n      this.computeNextCWEdges(), Rr.label(this.dirEdges, -1);\n      var t = Rr.findLabeledEdgeRings(this.dirEdges);\n      this.convertMaximalToMinimalEdgeRings(t);\n\n      for (var e = new I(), n = this.dirEdges.iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (!i.isMarked() && !i.isInRing()) {\n          var r = this.findEdgeRing(i);\n          e.add(r);\n        }\n      }\n\n      return e;\n    },\n    getNode: function getNode(t) {\n      var e = this.findNode(t);\n      return null === e && (e = new mr(t), this.add(e)), e;\n    },\n    convertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next(),\n            i = n.getLabel(),\n            r = Rr.findIntersectionNodes(n, i);\n        if (null !== r) for (var s = r.iterator(); s.hasNext();) {\n          var o = s.next();\n          Rr.computeNextCCWEdges(o, i);\n        }\n      }\n    },\n    deleteDangles: function deleteDangles() {\n      for (var t = this.findNodesOfDegree(1), e = new J(), n = new pe(), i = t.iterator(); i.hasNext();) {\n        n.push(i.next());\n      }\n\n      for (; !n.isEmpty();) {\n        var r = n.pop();\n        Rr.deleteAllEdges(r);\n\n        for (var s = r.getOutEdges().getEdges(), i = s.iterator(); i.hasNext();) {\n          var o = i.next();\n          o.setMarked(!0);\n          var a = o.getSym();\n          null !== a && a.setMarked(!0);\n          var u = o.getEdge();\n          e.add(u.getLine());\n          var l = o.getToNode();\n          1 === Rr.getDegreeNonDeleted(l) && n.push(l);\n        }\n      }\n\n      return e;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Rr;\n    }\n  }), Rr.findLabeledEdgeRings = function (t) {\n    for (var e = new I(), n = 1, i = t.iterator(); i.hasNext();) {\n      var r = i.next();\n\n      if (!(r.isMarked() || r.getLabel() >= 0)) {\n        e.add(r);\n        var s = wr.findDirEdgesInRing(r);\n        Rr.label(s, n), n++;\n      }\n    }\n\n    return e;\n  }, Rr.getDegreeNonDeleted = function (t) {\n    for (var e = t.getOutEdges().getEdges(), n = 0, i = e.iterator(); i.hasNext();) {\n      var r = i.next();\n      r.isMarked() || n++;\n    }\n\n    return n;\n  }, Rr.deleteAllEdges = function (t) {\n    for (var e = t.getOutEdges().getEdges(), n = e.iterator(); n.hasNext();) {\n      var i = n.next();\n      i.setMarked(!0);\n      var r = i.getSym();\n      null !== r && r.setMarked(!0);\n    }\n  }, Rr.label = function (t, e) {\n    for (var n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      i.setLabel(e);\n    }\n  }, Rr.computeNextCWEdges = function (t) {\n    for (var e = t.getOutEdges(), n = null, i = null, r = e.getEdges().iterator(); r.hasNext();) {\n      var s = r.next();\n\n      if (!s.isMarked()) {\n        if (null === n && (n = s), null !== i) {\n          var o = i.getSym();\n          o.setNext(s);\n        }\n\n        i = s;\n      }\n    }\n\n    if (null !== i) {\n      var o = i.getSym();\n      o.setNext(n);\n    }\n  }, Rr.computeNextCCWEdges = function (t, e) {\n    for (var n = t.getOutEdges(), i = null, r = null, s = n.getEdges(), o = s.size() - 1; o >= 0; o--) {\n      var a = s.get(o),\n          u = a.getSym(),\n          l = null;\n      a.getLabel() === e && (l = a);\n      var h = null;\n      u.getLabel() === e && (h = u), null === l && null === h || (null !== h && (r = h), null !== l && (null !== r && (r.setNext(l), r = null), null === i && (i = l)));\n    }\n\n    null !== r && (f.isTrue(null !== i), r.setNext(i));\n  }, Rr.getDegree = function (t, e) {\n    for (var n = t.getOutEdges().getEdges(), i = 0, r = n.iterator(); r.hasNext();) {\n      var s = r.next();\n      s.getLabel() === e && i++;\n    }\n\n    return i;\n  }, Rr.findIntersectionNodes = function (t, e) {\n    var n = t,\n        i = null;\n\n    do {\n      var r = n.getFromNode();\n      Rr.getDegree(r, e) > 1 && (null === i && (i = new I()), i.add(r)), n = n.getNext(), f.isTrue(null !== n, \"found null DE in ring\"), f.isTrue(n === t || !n.isInRing(), \"found DE already in ring\");\n    } while (n !== t);\n\n    return i;\n  }, e(Tr.prototype, {\n    getGeometry: function getGeometry() {\n      return null === this.geomFactory && (this.geomFactory = new ie()), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList));\n    },\n    getInvalidRingLines: function getInvalidRingLines() {\n      return this.polygonize(), this.invalidRingLines;\n    },\n    findValidRings: function findValidRings(t, e, n) {\n      for (var i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        r.isValid() ? e.add(r) : n.add(r.getLineString());\n      }\n    },\n    polygonize: function polygonize() {\n      if (null !== this.polyList) return null;\n      if (this.polyList = new I(), null === this.graph) return null;\n      this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();\n      var t = this.graph.getEdgeRings(),\n          e = new I();\n      this.invalidRingLines = new I(), this.isCheckingRingsValid ? this.findValidRings(t, e, this.invalidRingLines) : e = t, this.findShellsAndHoles(e), Tr.assignHolesToShells(this.holeList, this.shellList), ho.sort(this.shellList, new wr.EnvelopeComparator());\n      var n = !0;\n      this.extractOnlyPolygonal && (Tr.findDisjointShells(this.shellList), n = !1), this.polyList = Tr.extractPolygons(this.shellList, n);\n    },\n    getDangles: function getDangles() {\n      return this.polygonize(), this.dangles;\n    },\n    getCutEdges: function getCutEdges() {\n      return this.polygonize(), this.cutEdges;\n    },\n    getPolygons: function getPolygons() {\n      return this.polygonize(), this.polyList;\n    },\n    add: function add() {\n      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.add(n);\n      } else if (arguments[0] instanceof St) {\n        var i = arguments[0];\n        this.geomFactory = i.getFactory(), null === this.graph && (this.graph = new Rr(this.geomFactory)), this.graph.addEdge(i);\n      } else if (arguments[0] instanceof B) {\n        var r = arguments[0];\n        r.apply(this.lineStringAdder);\n      }\n    },\n    setCheckRingsValid: function setCheckRingsValid(t) {\n      this.isCheckingRingsValid = t;\n    },\n    findShellsAndHoles: function findShellsAndHoles(t) {\n      this.holeList = new I(), this.shellList = new I();\n\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.computeHole(), n.isHole() ? this.holeList.add(n) : this.shellList.add(n);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Tr;\n    }\n  }), Tr.findOuterShells = function (t) {\n    for (var e = t.iterator(); e.hasNext();) {\n      var n = e.next(),\n          i = n.getOuterHole();\n      null === i || i.isProcessed() || (n.setIncluded(!0), i.setProcessed(!0));\n    }\n  }, Tr.extractPolygons = function (t, e) {\n    for (var n = new I(), i = t.iterator(); i.hasNext();) {\n      var r = i.next();\n      (e || r.isIncluded()) && n.add(r.getPolygon());\n    }\n\n    return n;\n  }, Tr.assignHolesToShells = function (t, e) {\n    for (var n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      Tr.assignHoleToShell(i, e);\n    }\n  }, Tr.assignHoleToShell = function (t, e) {\n    var n = wr.findEdgeRingContaining(t, e);\n    null !== n && n.addHole(t);\n  }, Tr.findDisjointShells = function (t) {\n    Tr.findOuterShells(t);\n    var e = null;\n\n    do {\n      e = !1;\n\n      for (var n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n        i.isIncludedSet() || (i.updateIncluded(), i.isIncludedSet() || (e = !0));\n      }\n    } while (e);\n  }, e(Pr.prototype, {\n    filter: function filter(t) {\n      t instanceof St && this.p.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [q];\n    },\n    getClass: function getClass() {\n      return Pr;\n    }\n  }), Tr.LineStringAdder = Pr;\n  var Ro = Object.freeze({\n    Polygonizer: Tr\n  });\n  e(br.prototype, {\n    createEdgeEndForNext: function createEdgeEndForNext(t, e, n, i) {\n      var r = n.segmentIndex + 1;\n      if (r >= t.getNumPoints() && null === i) return null;\n      var s = t.getCoordinate(r);\n      null !== i && i.segmentIndex === n.segmentIndex && (s = i.coord);\n      var o = new En(t, n.coord, s, new gn(t.getLabel()));\n      e.add(o);\n    },\n    createEdgeEndForPrev: function createEdgeEndForPrev(t, e, n, i) {\n      var r = n.segmentIndex;\n\n      if (0 === n.dist) {\n        if (0 === r) return null;\n        r--;\n      }\n\n      var s = t.getCoordinate(r);\n      null !== i && i.segmentIndex >= r && (s = i.coord);\n      var o = new gn(t.getLabel());\n      o.flip();\n      var a = new En(t, n.coord, s, o);\n      e.add(a);\n    },\n    computeEdgeEnds: function computeEdgeEnds() {\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = new I(), n = t; n.hasNext();) {\n          var i = n.next();\n          this.computeEdgeEnds(i, e);\n        }\n\n        return e;\n      }\n\n      if (2 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = r.getEdgeIntersectionList();\n        o.addEndpoints();\n        var a = o.iterator(),\n            u = null,\n            l = null;\n        if (!a.hasNext()) return null;\n        var h = a.next();\n\n        do {\n          u = l, l = h, h = null, a.hasNext() && (h = a.next()), null !== l && (this.createEdgeEndForPrev(r, s, l, u), this.createEdgeEndForNext(r, s, l, h));\n        } while (null !== l);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return br;\n    }\n  }), h(Or, En), e(Or.prototype, {\n    insert: function insert(t) {\n      this.edgeEnds.add(t);\n    },\n    print: function print(t) {\n      t.println(\"EdgeEndBundle--> Label: \" + this.label);\n\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.print(t), t.println();\n      }\n    },\n    iterator: function iterator() {\n      return this.edgeEnds.iterator();\n    },\n    getEdgeEnds: function getEdgeEnds() {\n      return this.edgeEnds;\n    },\n    computeLabelOn: function computeLabelOn(t, e) {\n      for (var n = 0, i = !1, r = this.iterator(); r.hasNext();) {\n        var s = r.next(),\n            o = s.getLabel().getLocation(t);\n        o === L.BOUNDARY && n++, o === L.INTERIOR && (i = !0);\n      }\n\n      var o = L.NONE;\n      i && (o = L.INTERIOR), n > 0 && (o = $n.determineBoundary(e, n)), this.label.setLocation(t, o);\n    },\n    computeLabelSide: function computeLabelSide(t, e) {\n      for (var n = this.iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (i.getLabel().isArea()) {\n          var r = i.getLabel().getLocation(t, e);\n          if (r === L.INTERIOR) return this.label.setLocation(t, e, L.INTERIOR), null;\n          r === L.EXTERIOR && this.label.setLocation(t, e, L.EXTERIOR);\n        }\n      }\n    },\n    getLabel: function getLabel() {\n      return this.label;\n    },\n    computeLabelSides: function computeLabelSides(t) {\n      this.computeLabelSide(t, cn.LEFT), this.computeLabelSide(t, cn.RIGHT);\n    },\n    updateIM: function updateIM(t) {\n      Jn.updateIM(this.label, t);\n    },\n    computeLabel: function computeLabel(t) {\n      for (var e = !1, n = this.iterator(); n.hasNext();) {\n        var i = n.next();\n        i.getLabel().isArea() && (e = !0);\n      }\n\n      e ? this.label = new gn(L.NONE, L.NONE, L.NONE) : this.label = new gn(L.NONE);\n\n      for (var r = 0; 2 > r; r++) {\n        this.computeLabelOn(r, t), e && this.computeLabelSides(r);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Or;\n    }\n  }), h(_r, Pn), e(_r.prototype, {\n    updateIM: function updateIM(t) {\n      for (var e = this.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.updateIM(t);\n      }\n    },\n    insert: function insert(t) {\n      var e = this.edgeMap.get(t);\n      null === e ? (e = new Or(t), this.insertEdgeEnd(t, e)) : e.insert(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return _r;\n    }\n  }), h(Mr, yn), e(Mr.prototype, {\n    updateIMFromEdges: function updateIMFromEdges(t) {\n      this.edges.updateIM(t);\n    },\n    computeIM: function computeIM(t) {\n      t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Mr;\n    }\n  }), h(Dr, Nn), e(Dr.prototype, {\n    createNode: function createNode(t) {\n      return new Mr(t, new _r());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Dr;\n    }\n  }), e(Ar.prototype, {\n    insertEdgeEnds: function insertEdgeEnds(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.nodes.add(n);\n      }\n    },\n    computeProperIntersectionIM: function computeProperIntersectionIM(t, e) {\n      var n = this.arg[0].getGeometry().getDimension(),\n          i = this.arg[1].getGeometry().getDimension(),\n          r = t.hasProperIntersection(),\n          s = t.hasProperInteriorIntersection();\n      2 === n && 2 === i ? r && e.setAtLeast(\"212101212\") : 2 === n && 1 === i ? (r && e.setAtLeast(\"FFF0FFFF2\"), s && e.setAtLeast(\"1FFFFF1FF\")) : 1 === n && 2 === i ? (r && e.setAtLeast(\"F0FFFFFF2\"), s && e.setAtLeast(\"1F1FFFFFF\")) : 1 === n && 1 === i && s && e.setAtLeast(\"0FFFFFFFF\");\n    },\n    labelIsolatedEdges: function labelIsolatedEdges(t, e) {\n      for (var n = this.arg[t].getEdgeIterator(); n.hasNext();) {\n        var i = n.next();\n        i.isIsolated() && (this.labelIsolatedEdge(i, e, this.arg[e].getGeometry()), this.isolatedEdges.add(i));\n      }\n    },\n    labelIsolatedEdge: function labelIsolatedEdge(t, e, n) {\n      if (n.getDimension() > 0) {\n        var i = this.ptLocator.locate(t.getCoordinate(), n);\n        t.getLabel().setAllLocations(e, i);\n      } else t.getLabel().setAllLocations(e, L.EXTERIOR);\n    },\n    computeIM: function computeIM() {\n      var t = new fe();\n      if (t.set(L.EXTERIOR, L.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;\n      this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);\n      var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);\n      this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);\n      var n = new br(),\n          i = n.computeEdgeEnds(this.arg[0].getEdgeIterator());\n      this.insertEdgeEnds(i);\n      var r = n.computeEdgeEnds(this.arg[1].getEdgeIterator());\n      return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t;\n    },\n    labelNodeEdges: function labelNodeEdges() {\n      for (var t = this.nodes.iterator(); t.hasNext();) {\n        var e = t.next();\n        e.getEdges().computeLabelling(this.arg);\n      }\n    },\n    copyNodesAndLabels: function copyNodesAndLabels(t) {\n      for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {\n        var n = e.next(),\n            i = this.nodes.addNode(n.getCoordinate());\n        i.setLabel(t, n.getLabel().getLocation(t));\n      }\n    },\n    labelIntersectionNodes: function labelIntersectionNodes(t) {\n      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) {\n        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {\n          var s = r.next(),\n              o = this.nodes.find(s.coord);\n          o.getLabel().isNull(t) && (i === L.BOUNDARY ? o.setLabelBoundary(t) : o.setLabel(t, L.INTERIOR));\n        }\n      }\n    },\n    labelIsolatedNode: function labelIsolatedNode(t, e) {\n      var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());\n      t.getLabel().setAllLocations(e, n);\n    },\n    computeIntersectionNodes: function computeIntersectionNodes(t) {\n      for (var e = this.arg[t].getEdgeIterator(); e.hasNext();) {\n        for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext();) {\n          var s = r.next(),\n              o = this.nodes.addNode(s.coord);\n          i === L.BOUNDARY ? o.setLabelBoundary(t) : o.getLabel().isNull(t) && o.setLabel(t, L.INTERIOR);\n        }\n      }\n    },\n    labelIsolatedNodes: function labelIsolatedNodes() {\n      for (var t = this.nodes.iterator(); t.hasNext();) {\n        var e = t.next(),\n            n = e.getLabel();\n        f.isTrue(n.getGeometryCount() > 0, \"node with empty label found\"), e.isIsolated() && (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1));\n      }\n    },\n    updateIM: function updateIM(t) {\n      for (var e = this.isolatedEdges.iterator(); e.hasNext();) {\n        var n = e.next();\n        n.updateIM(t);\n      }\n\n      for (var i = this.nodes.iterator(); i.hasNext();) {\n        var r = i.next();\n        r.updateIM(t), r.updateIMFromEdges(t);\n      }\n    },\n    computeDisjointIM: function computeDisjointIM(t) {\n      var e = this.arg[0].getGeometry();\n      e.isEmpty() || (t.set(L.INTERIOR, L.EXTERIOR, e.getDimension()), t.set(L.BOUNDARY, L.EXTERIOR, e.getBoundaryDimension()));\n      var n = this.arg[1].getGeometry();\n      n.isEmpty() || (t.set(L.EXTERIOR, L.INTERIOR, n.getDimension()), t.set(L.EXTERIOR, L.BOUNDARY, n.getBoundaryDimension()));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ar;\n    }\n  }), e(Fr.prototype, {\n    isContainedInBoundary: function isContainedInBoundary(t) {\n      if (t instanceof Tt) return !1;\n      if (t instanceof Lt) return this.isPointContainedInBoundary(t);\n      if (t instanceof St) return this.isLineStringContainedInBoundary(t);\n\n      for (var e = 0; e < t.getNumGeometries(); e++) {\n        var n = t.getGeometryN(e);\n        if (!this.isContainedInBoundary(n)) return !1;\n      }\n\n      return !0;\n    },\n    isLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(t, e) {\n      if (t.equals(e)) return this.isPointContainedInBoundary(t);\n\n      if (t.x === e.x) {\n        if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX()) return !0;\n      } else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY())) return !0;\n\n      return !1;\n    },\n    isLineStringContainedInBoundary: function isLineStringContainedInBoundary(t) {\n      for (var e = t.getCoordinateSequence(), n = new g(), i = new g(), r = 0; r < e.size() - 1; r++) {\n        if (e.getCoordinate(r, n), e.getCoordinate(r + 1, i), !this.isLineSegmentContainedInBoundary(n, i)) return !1;\n      }\n\n      return !0;\n    },\n    isPointContainedInBoundary: function isPointContainedInBoundary() {\n      if (arguments[0] instanceof Lt) {\n        var t = arguments[0];\n        return this.isPointContainedInBoundary(t.getCoordinate());\n      }\n\n      if (arguments[0] instanceof g) {\n        var e = arguments[0];\n        return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY();\n      }\n    },\n    contains: function contains(t) {\n      return this.rectEnv.contains(t.getEnvelopeInternal()) ? !this.isContainedInBoundary(t) : !1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Fr;\n    }\n  }), Fr.contains = function (t, e) {\n    var n = new Fr(t);\n    return n.contains(e);\n  }, e(Gr.prototype, {\n    intersects: function intersects(t, e) {\n      var n = new C(t, e);\n      if (!this.rectEnv.intersects(n)) return !1;\n      if (this.rectEnv.intersects(t)) return !0;\n      if (this.rectEnv.intersects(e)) return !0;\n\n      if (t.compareTo(e) > 0) {\n        var i = t;\n        t = e, e = i;\n      }\n\n      var r = !1;\n      return e.y > t.y && (r = !0), r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1), !!this.li.hasIntersection();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Gr;\n    }\n  }), e(qr.prototype, {\n    applyTo: function applyTo(t) {\n      for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {\n        var n = t.getGeometryN(e);\n        if (n instanceof ft) this.applyTo(n);else if (this.visit(n), this.isDone()) return this._isDone = !0, null;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return qr;\n    }\n  }), e(Br.prototype, {\n    intersects: function intersects(t) {\n      if (!this.rectEnv.intersects(t.getEnvelopeInternal())) return !1;\n      var e = new zr(this.rectEnv);\n      if (e.applyTo(t), e.intersects()) return !0;\n      var n = new Vr(this.rectangle);\n      if (n.applyTo(t), n.containsPoint()) return !0;\n      var i = new kr(this.rectangle);\n      return i.applyTo(t), !!i.intersects();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Br;\n    }\n  }), Br.intersects = function (t, e) {\n    var n = new Br(t);\n    return n.intersects(e);\n  }, h(zr, qr), e(zr.prototype, {\n    isDone: function isDone() {\n      return this._intersects === !0;\n    },\n    visit: function visit(t) {\n      var e = t.getEnvelopeInternal();\n      return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0, null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null;\n    },\n    intersects: function intersects() {\n      return this._intersects;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return zr;\n    }\n  }), h(Vr, qr), e(Vr.prototype, {\n    isDone: function isDone() {\n      return this._containsPoint === !0;\n    },\n    visit: function visit(t) {\n      if (!(t instanceof Tt)) return null;\n      var e = t.getEnvelopeInternal();\n      if (!this.rectEnv.intersects(e)) return null;\n\n      for (var n = new g(), i = 0; 4 > i; i++) {\n        if (this.rectSeq.getCoordinate(i, n), e.contains(n) && Tn.containsPointInPolygon(n, t)) return this._containsPoint = !0, null;\n      }\n    },\n    containsPoint: function containsPoint() {\n      return this._containsPoint;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Vr;\n    }\n  }), h(kr, qr), e(kr.prototype, {\n    intersects: function intersects() {\n      return this.hasIntersection;\n    },\n    isDone: function isDone() {\n      return this.hasIntersection === !0;\n    },\n    visit: function visit(t) {\n      var e = t.getEnvelopeInternal();\n      if (!this.rectEnv.intersects(e)) return null;\n      var n = kn.getLines(t);\n      this.checkIntersectionWithLineStrings(n);\n    },\n    checkIntersectionWithLineStrings: function checkIntersectionWithLineStrings(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        if (this.checkIntersectionWithSegments(n), this.hasIntersection) return null;\n      }\n    },\n    checkIntersectionWithSegments: function checkIntersectionWithSegments(t) {\n      for (var e = t.getCoordinateSequence(), n = 1; n < e.size(); n++) {\n        if (e.getCoordinate(n - 1, this.p0), e.getCoordinate(n, this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return kr;\n    }\n  }), h(Yr, ti), e(Yr.prototype, {\n    getIntersectionMatrix: function getIntersectionMatrix() {\n      return this._relate.computeIM();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Yr;\n    }\n  }), Yr.covers = function (t, e) {\n    return t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) ? t.isRectangle() ? !0 : Yr.relate(t, e).isCovers() : !1;\n  }, Yr.intersects = function (t, e) {\n    return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? t.isRectangle() ? Br.intersects(t, e) : e.isRectangle() ? Br.intersects(e, t) : Yr.relate(t, e).isIntersects() : !1;\n  }, Yr.touches = function (t, e) {\n    return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? Yr.relate(t, e).isTouches(t.getDimension(), e.getDimension()) : !1;\n  }, Yr.within = function (t, e) {\n    return e.contains(t);\n  }, Yr.coveredBy = function (t, e) {\n    return Yr.covers(e, t);\n  }, Yr.relate = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = new Yr(t, e),\n          i = n.getIntersectionMatrix();\n      return i;\n    }\n\n    if (3 === arguments.length) {\n      if (\"string\" == typeof arguments[2] && arguments[0] instanceof B && arguments[1] instanceof B) {\n        var r = arguments[0],\n            s = arguments[1],\n            o = arguments[2];\n        return Yr.relateWithCheck(r, s).matches(o);\n      }\n\n      if (R(arguments[2], V) && arguments[0] instanceof B && arguments[1] instanceof B) {\n        var a = arguments[0],\n            u = arguments[1],\n            l = arguments[2],\n            n = new Yr(a, u, l),\n            i = n.getIntersectionMatrix();\n        return i;\n      }\n    }\n  }, Yr.overlaps = function (t, e) {\n    return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? Yr.relate(t, e).isOverlaps(t.getDimension(), e.getDimension()) : !1;\n  }, Yr.disjoint = function (t, e) {\n    return !t.intersects(e);\n  }, Yr.relateWithCheck = function (t, e) {\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Yr.relate(t, e);\n  }, Yr.crosses = function (t, e) {\n    return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) ? Yr.relate(t, e).isCrosses(t.getDimension(), e.getDimension()) : !1;\n  }, Yr.contains = function (t, e) {\n    return t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) ? t.isRectangle() ? Fr.contains(t, e) : Yr.relate(t, e).isContains() : !1;\n  };\n  var To = Object.freeze({\n    RelateOp: Yr\n  });\n  e(Ur.prototype, {\n    extractElements: function extractElements(t, e) {\n      if (null === t) return null;\n\n      for (var n = 0; n < t.getNumGeometries(); n++) {\n        var i = t.getGeometryN(n);\n        this.skipEmpty && i.isEmpty() || e.add(i);\n      }\n    },\n    combine: function combine() {\n      for (var t = new I(), e = this.inputGeoms.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.extractElements(n, t);\n      }\n\n      return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ur;\n    }\n  }), Ur.combine = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0],\n          e = new Ur(t);\n      return e.combine();\n    }\n\n    if (2 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          e = new Ur(Ur.createList(n, i));\n      return e.combine();\n    }\n\n    if (3 === arguments.length) {\n      var r = arguments[0],\n          s = arguments[1],\n          o = arguments[2],\n          e = new Ur(Ur.createList(r, s, o));\n      return e.combine();\n    }\n  }, Ur.extractFactory = function (t) {\n    return t.isEmpty() ? null : t.iterator().next().getFactory();\n  }, Ur.createList = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = new I();\n      return n.add(t), n.add(e), n;\n    }\n\n    if (3 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          s = arguments[2],\n          n = new I();\n      return n.add(i), n.add(r), n.add(s), n;\n    }\n  }, e(Xr.prototype, {\n    union: function union() {\n      for (var t = new Te(), e = new at(), n = 0; n < this.pointGeom.getNumGeometries(); n++) {\n        var i = this.pointGeom.getGeometryN(n),\n            r = i.getCoordinate(),\n            s = t.locate(r, this.otherGeom);\n        s === L.EXTERIOR && e.add(r);\n      }\n\n      if (0 === e.size()) return this.otherGeom;\n      var o = null,\n          a = H.toCoordinateArray(e);\n      return o = 1 === a.length ? this.geomFact.createPoint(a[0]) : this.geomFact.createMultiPointFromCoords(a), Ur.combine(o, this.otherGeom);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Xr;\n    }\n  }), Xr.union = function (t, e) {\n    var n = new Xr(t, e);\n    return n.union();\n  }, e(Hr.prototype, {\n    filter: function filter(t) {\n      -1 !== this.sortIndex && t.getSortIndex() !== this.sortIndex || this.comps.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [ht];\n    },\n    getClass: function getClass() {\n      return Hr;\n    }\n  }), Hr.extract = function () {\n    if (2 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1];\n      return Hr.extract(t, e, new I());\n    }\n\n    if (3 === arguments.length) {\n      var n = arguments[0],\n          i = arguments[1],\n          r = arguments[2];\n      return n.getSortIndex() === i ? r.add(n) : n instanceof ft && n.apply(new Hr(i, r)), r;\n    }\n  }, e(Wr.prototype, {\n    reduceToGeometries: function reduceToGeometries(t) {\n      for (var e = new I(), n = t.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = null;\n        R(i, y) ? r = this.unionTree(i) : i instanceof B && (r = i), e.add(r);\n      }\n\n      return e;\n    },\n    extractByEnvelope: function extractByEnvelope(t, e, n) {\n      for (var i = new I(), r = 0; r < e.getNumGeometries(); r++) {\n        var s = e.getGeometryN(r);\n        s.getEnvelopeInternal().intersects(t) ? i.add(s) : n.add(s);\n      }\n\n      return this.geomFactory.buildGeometry(i);\n    },\n    unionOptimized: function unionOptimized(t, e) {\n      var n = t.getEnvelopeInternal(),\n          i = e.getEnvelopeInternal();\n\n      if (!n.intersects(i)) {\n        var r = Ur.combine(t, e);\n        return r;\n      }\n\n      if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);\n      var s = n.intersection(i);\n      return this.unionUsingEnvelopeIntersection(t, e, s);\n    },\n    union: function union() {\n      if (null === this.inputPolys) throw new IllegalStateException(\"union() method cannot be called twice\");\n      if (this.inputPolys.isEmpty()) return null;\n      this.geomFactory = this.inputPolys.iterator().next().getFactory();\n\n      for (var t = new ke(Wr.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext();) {\n        var n = e.next();\n        t.insert(n.getEnvelopeInternal(), n);\n      }\n\n      this.inputPolys = null;\n      var i = t.itemsTree(),\n          r = this.unionTree(i);\n      return r;\n    },\n    binaryUnion: function binaryUnion() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.binaryUnion(t, 0, t.size());\n      }\n\n      if (3 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1],\n            i = arguments[2];\n\n        if (1 >= i - n) {\n          var r = Wr.getGeometry(e, n);\n          return this.unionSafe(r, null);\n        }\n\n        if (i - n === 2) return this.unionSafe(Wr.getGeometry(e, n), Wr.getGeometry(e, n + 1));\n        var s = Math.trunc((i + n) / 2),\n            r = this.binaryUnion(e, n, s),\n            o = this.binaryUnion(e, s, i);\n        return this.unionSafe(r, o);\n      }\n    },\n    repeatedUnion: function repeatedUnion(t) {\n      for (var e = null, n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n        e = null === e ? i.copy() : e.union(i);\n      }\n\n      return e;\n    },\n    unionSafe: function unionSafe(t, e) {\n      return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e);\n    },\n    unionActual: function unionActual(t, e) {\n      return Wr.restrictToPolygons(t.union(e));\n    },\n    unionTree: function unionTree(t) {\n      var e = this.reduceToGeometries(t),\n          n = this.binaryUnion(e);\n      return n;\n    },\n    unionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(t, e, n) {\n      var i = new I(),\n          r = this.extractByEnvelope(n, t, i),\n          s = this.extractByEnvelope(n, e, i),\n          o = this.unionActual(r, s);\n      i.add(o);\n      var a = Ur.combine(i);\n      return a;\n    },\n    bufferUnion: function bufferUnion() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = t.get(0).getFactory(),\n            n = e.buildGeometry(t),\n            i = n.buffer(0);\n        return i;\n      }\n\n      if (2 === arguments.length) {\n        var r = arguments[0],\n            s = arguments[1],\n            e = r.getFactory(),\n            n = e.createGeometryCollection([r, s]),\n            i = n.buffer(0);\n        return i;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Wr;\n    }\n  }), Wr.restrictToPolygons = function (t) {\n    if (R(t, Rt)) return t;\n    var e = or.getPolygons(t);\n    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(ie.toPolygonArray(e));\n  }, Wr.getGeometry = function (t, e) {\n    return e >= t.size() ? null : t.get(e);\n  }, Wr.union = function (t) {\n    var e = new Wr(t);\n    return e.union();\n  }, Wr.STRTREE_NODE_CAPACITY = 4, e(jr.prototype, {\n    unionNoOpt: function unionNoOpt(t) {\n      var e = this.geomFact.createPoint();\n      return si.overlayOp(t, e, ii.UNION);\n    },\n    unionWithNull: function unionWithNull(t, e) {\n      return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e);\n    },\n    extract: function extract() {\n      if (R(arguments[0], v)) for (var t = arguments[0], e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.extract(n);\n      } else if (arguments[0] instanceof B) {\n        var i = arguments[0];\n        null === this.geomFact && (this.geomFact = i.getFactory()), Hr.extract(i, B.SORTINDEX_POLYGON, this.polygons), Hr.extract(i, B.SORTINDEX_LINESTRING, this.lines), Hr.extract(i, B.SORTINDEX_POINT, this.points);\n      }\n    },\n    union: function t() {\n      if (null === this.geomFact) return null;\n      var e = null;\n\n      if (this.points.size() > 0) {\n        var n = this.geomFact.buildGeometry(this.points);\n        e = this.unionNoOpt(n);\n      }\n\n      var i = null;\n\n      if (this.lines.size() > 0) {\n        var r = this.geomFact.buildGeometry(this.lines);\n        i = this.unionNoOpt(r);\n      }\n\n      var s = null;\n      this.polygons.size() > 0 && (s = Wr.union(this.polygons));\n      var o = this.unionWithNull(i, s),\n          t = null;\n      return t = null === e ? o : null === o ? e : Xr.union(e, o), null === t ? this.geomFact.createGeometryCollection() : t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return jr;\n    }\n  }), jr.union = function () {\n    if (1 === arguments.length) {\n      if (R(arguments[0], v)) {\n        var t = arguments[0],\n            e = new jr(t);\n        return e.union();\n      }\n\n      if (arguments[0] instanceof B) {\n        var n = arguments[0],\n            e = new jr(n);\n        return e.union();\n      }\n    } else if (2 === arguments.length) {\n      var i = arguments[0],\n          r = arguments[1],\n          e = new jr(i, r);\n      return e.union();\n    }\n  };\n  var Po = Object.freeze({\n    UnaryUnionOp: jr\n  });\n  e(Kr.prototype, {\n    visitInteriorRing: function visitInteriorRing(t, e) {\n      var n = t.getCoordinates(),\n          i = n[0],\n          r = Kr.findDifferentPoint(n, i),\n          s = e.findEdgeInSameDirection(i, r),\n          o = e.findEdgeEnd(s),\n          a = null;\n      o.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR ? a = o : o.getSym().getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && (a = o.getSym()), f.isTrue(null !== a, \"unable to find dirEdge with Interior on RHS\"), this.visitLinkedDirectedEdges(a);\n    },\n    visitShellInteriors: function visitShellInteriors(t, e) {\n      if (t instanceof Tt) {\n        var n = t;\n        this.visitInteriorRing(n.getExteriorRing(), e);\n      }\n\n      if (t instanceof Ot) for (var i = t, r = 0; r < i.getNumGeometries(); r++) {\n        var n = i.getGeometryN(r);\n        this.visitInteriorRing(n.getExteriorRing(), e);\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this.disconnectedRingcoord;\n    },\n    setInteriorEdgesInResult: function setInteriorEdgesInResult(t) {\n      for (var e = t.getEdgeEnds().iterator(); e.hasNext();) {\n        var n = e.next();\n        n.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR && n.setInResult(!0);\n      }\n    },\n    visitLinkedDirectedEdges: function visitLinkedDirectedEdges(t) {\n      var e = t,\n          n = t;\n\n      do {\n        f.isTrue(null !== n, \"found null Directed Edge\"), n.setVisited(!0), n = n.getNext();\n      } while (n !== e);\n    },\n    buildEdgeRings: function buildEdgeRings(t) {\n      for (var e = new I(), n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n\n        if (i.isInResult() && null === i.getEdgeRing()) {\n          var r = new vn(i, this.geometryFactory);\n          r.linkDirectedEdgesForMinimalEdgeRings();\n          var s = r.buildMinimalRings();\n          e.addAll(s);\n        }\n      }\n\n      return e;\n    },\n    hasUnvisitedShellEdge: function hasUnvisitedShellEdge(t) {\n      for (var e = 0; e < t.size(); e++) {\n        var n = t.get(e);\n\n        if (!n.isHole()) {\n          var i = n.getEdges(),\n              r = i.get(0);\n          if (r.getLabel().getLocation(0, cn.RIGHT) === L.INTERIOR) for (var s = 0; s < i.size(); s++) {\n            if (r = i.get(s), !r.isVisited()) return this.disconnectedRingcoord = r.getCoordinate(), !0;\n          }\n        }\n      }\n\n      return !1;\n    },\n    isInteriorsConnected: function isInteriorsConnected() {\n      var t = new I();\n      this.geomGraph.computeSplitEdges(t);\n      var e = new Cn(new On());\n      e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();\n      var n = this.buildEdgeRings(e.getEdgeEnds());\n      return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Kr;\n    }\n  }), Kr.findDifferentPoint = function (t, e) {\n    for (var n = 0; n < t.length; n++) {\n      if (!t[n].equals(e)) return t[n];\n    }\n\n    return null;\n  }, e(Zr.prototype, {\n    hasChildren: function hasChildren() {\n      for (var t = 0; 2 > t; t++) {\n        if (null !== this.subnode[t]) return !0;\n      }\n\n      return !1;\n    },\n    isPrunable: function isPrunable() {\n      return !(this.hasChildren() || this.hasItems());\n    },\n    addAllItems: function addAllItems(t) {\n      t.addAll(this.items);\n\n      for (var e = 0; 2 > e; e++) {\n        null !== this.subnode[e] && this.subnode[e].addAllItems(t);\n      }\n\n      return t;\n    },\n    size: function size() {\n      for (var t = 0, e = 0; 2 > e; e++) {\n        null !== this.subnode[e] && (t += this.subnode[e].size());\n      }\n\n      return t + this.items.size();\n    },\n    addAllItemsFromOverlapping: function addAllItemsFromOverlapping(t, e) {\n      return null === t || this.isSearchMatch(t) ? (e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), void (null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))) : null;\n    },\n    hasItems: function hasItems() {\n      return !this.items.isEmpty();\n    },\n    remove: function remove(t, e) {\n      if (!this.isSearchMatch(t)) return !1;\n\n      for (var n = !1, i = 0; 2 > i; i++) {\n        if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {\n          this.subnode[i].isPrunable() && (this.subnode[i] = null);\n          break;\n        }\n      }\n\n      return n ? n : n = this.items.remove(e);\n    },\n    getItems: function getItems() {\n      return this.items;\n    },\n    depth: function depth() {\n      for (var t = 0, e = 0; 2 > e; e++) {\n        if (null !== this.subnode[e]) {\n          var n = this.subnode[e].depth();\n          n > t && (t = n);\n        }\n      }\n\n      return t + 1;\n    },\n    nodeSize: function nodeSize() {\n      for (var t = 0, e = 0; 2 > e; e++) {\n        null !== this.subnode[e] && (t += this.subnode[e].nodeSize());\n      }\n\n      return t + 1;\n    },\n    add: function add(t) {\n      this.items.add(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Zr;\n    }\n  }), Zr.getSubnodeIndex = function (t, e) {\n    var n = -1;\n    return t.min >= e && (n = 1), t.max <= e && (n = 0), n;\n  }, e(Qr.prototype, {\n    expandToInclude: function expandToInclude(t) {\n      t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min);\n    },\n    getWidth: function getWidth() {\n      return this.max - this.min;\n    },\n    overlaps: function overlaps() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.overlaps(t.min, t.max);\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return !(this.min > n || this.max < e);\n      }\n    },\n    getMin: function getMin() {\n      return this.min;\n    },\n    toString: function toString() {\n      return \"[\" + this.min + \", \" + this.max + \"]\";\n    },\n    contains: function contains() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Qr) {\n          var t = arguments[0];\n          return this.contains(t.min, t.max);\n        }\n\n        if (\"number\" == typeof arguments[0]) {\n          var e = arguments[0];\n          return e >= this.min && e <= this.max;\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1];\n        return n >= this.min && i <= this.max;\n      }\n    },\n    init: function init(t, e) {\n      this.min = t, this.max = e, t > e && (this.min = e, this.max = t);\n    },\n    getMax: function getMax() {\n      return this.max;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Qr;\n    }\n  }), e(Jr.prototype, {\n    getInterval: function getInterval() {\n      return this.interval;\n    },\n    getLevel: function getLevel() {\n      return this.level;\n    },\n    computeKey: function computeKey(t) {\n      for (this.level = Jr.computeLevel(t), this.interval = new Qr(), this.computeInterval(this.level, t); !this.interval.contains(t);) {\n        this.level += 1, this.computeInterval(this.level, t);\n      }\n    },\n    computeInterval: function computeInterval(t, e) {\n      var n = Ci.powerOf2(t);\n      this.pt = Math.floor(e.getMin() / n) * n, this.interval.init(this.pt, this.pt + n);\n    },\n    getPoint: function getPoint() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Jr;\n    }\n  }), Jr.computeLevel = function (t) {\n    var e = t.getWidth(),\n        n = Ci.exponent(e) + 1;\n    return n;\n  }, h($r, Zr), e($r.prototype, {\n    getInterval: function getInterval() {\n      return this.interval;\n    },\n    find: function find(t) {\n      var e = Zr.getSubnodeIndex(t, this.centre);\n      if (-1 === e) return this;\n\n      if (null !== this.subnode[e]) {\n        var n = this.subnode[e];\n        return n.find(t);\n      }\n\n      return this;\n    },\n    insert: function insert(t) {\n      f.isTrue(null === this.interval || this.interval.contains(t.interval));\n      var e = Zr.getSubnodeIndex(t.interval, this.centre);\n      if (t.level === this.level - 1) this.subnode[e] = t;else {\n        var n = this.createSubnode(e);\n        n.insert(t), this.subnode[e] = n;\n      }\n    },\n    isSearchMatch: function isSearchMatch(t) {\n      return t.overlaps(this.interval);\n    },\n    getSubnode: function getSubnode(t) {\n      return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t];\n    },\n    getNode: function getNode(t) {\n      var e = Zr.getSubnodeIndex(t, this.centre);\n\n      if (-1 !== e) {\n        var n = this.getSubnode(e);\n        return n.getNode(t);\n      }\n\n      return this;\n    },\n    createSubnode: function createSubnode(t) {\n      var e = 0,\n          n = 0;\n\n      switch (t) {\n        case 0:\n          e = this.interval.getMin(), n = this.centre;\n          break;\n\n        case 1:\n          e = this.centre, n = this.interval.getMax();\n      }\n\n      var i = new Qr(e, n),\n          r = new $r(i, this.level - 1);\n      return r;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return $r;\n    }\n  }), $r.createNode = function (t) {\n    var e = new Jr(t),\n        n = new $r(e.getInterval(), e.getLevel());\n    return n;\n  }, $r.createExpanded = function (t, e) {\n    var n = new Qr(e);\n    null !== t && n.expandToInclude(t.interval);\n    var i = $r.createNode(n);\n    return null !== t && i.insert(t), i;\n  }, h(ts, Zr), e(ts.prototype, {\n    insert: function insert(t, e) {\n      var n = Zr.getSubnodeIndex(t, ts.origin);\n      if (-1 === n) return this.add(e), null;\n      var i = this.subnode[n];\n\n      if (null === i || !i.getInterval().contains(t)) {\n        var r = $r.createExpanded(i, t);\n        this.subnode[n] = r;\n      }\n\n      this.insertContained(this.subnode[n], t, e);\n    },\n    isSearchMatch: function isSearchMatch(t) {\n      return !0;\n    },\n    insertContained: function insertContained(t, e, n) {\n      f.isTrue(t.getInterval().contains(e));\n      var i = Ri.isZeroWidth(e.getMin(), e.getMax()),\n          r = null;\n      r = i ? t.find(e) : t.getNode(e), r.add(n);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ts;\n    }\n  }), ts.origin = 0, e(es.prototype, {\n    size: function size() {\n      return null !== this.root ? this.root.size() : 0;\n    },\n    insert: function insert(t, e) {\n      this.collectStats(t);\n      var n = es.ensureExtent(t, this.minExtent);\n      this.root.insert(n, e);\n    },\n    query: function query() {\n      if (1 === arguments.length) {\n        if (\"number\" == typeof arguments[0]) {\n          var t = arguments[0];\n          return this.query(new Qr(t, t));\n        }\n\n        if (arguments[0] instanceof Qr) {\n          var e = arguments[0],\n              n = new I();\n          return this.query(e, n), n;\n        }\n      } else if (2 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1];\n        this.root.addAllItemsFromOverlapping(i, r);\n      }\n    },\n    iterator: function iterator() {\n      var t = new I();\n      return this.root.addAllItems(t), t.iterator();\n    },\n    remove: function remove(t, e) {\n      var n = es.ensureExtent(t, this.minExtent);\n      return this.root.remove(n, e);\n    },\n    collectStats: function collectStats(t) {\n      var e = t.getWidth();\n      e < this.minExtent && e > 0 && (this.minExtent = e);\n    },\n    depth: function depth() {\n      return null !== this.root ? this.root.depth() : 0;\n    },\n    nodeSize: function nodeSize() {\n      return null !== this.root ? this.root.nodeSize() : 0;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return es;\n    }\n  }), es.ensureExtent = function (t, e) {\n    var n = t.getMin(),\n        i = t.getMax();\n    return n !== i ? t : (n === i && (n -= e / 2, i = n + e / 2), new Qr(n, i));\n  }, e(ns.prototype, {\n    isInside: function isInside(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ns;\n    }\n  }), e(is.prototype, {\n    testLineSegment: function testLineSegment(t, e) {\n      var n = null,\n          i = null,\n          r = null,\n          s = null,\n          o = null,\n          a = e.p0,\n          u = e.p1;\n      i = a.x - t.x, r = a.y - t.y, s = u.x - t.x, o = u.y - t.y, (r > 0 && 0 >= o || o > 0 && 0 >= r) && (n = ue.signOfDet2x2(i, r, s, o) / (o - r), n > 0 && this.crossings++);\n    },\n    buildIndex: function buildIndex() {\n      this.tree = new es();\n\n      for (var t = H.removeRepeatedPoints(this.ring.getCoordinates()), e = $e.getChains(t), n = 0; n < e.size(); n++) {\n        var i = e.get(n),\n            r = i.getEnvelope();\n        this.interval.min = r.getMinY(), this.interval.max = r.getMaxY(), this.tree.insert(this.interval, i);\n      }\n    },\n    testMonotoneChain: function testMonotoneChain(t, e, n) {\n      n.select(t, e);\n    },\n    isInside: function isInside(t) {\n      this.crossings = 0;\n      var e = new C(r.NEGATIVE_INFINITY, r.POSITIVE_INFINITY, t.y, t.y);\n      this.interval.min = t.y, this.interval.max = t.y;\n\n      for (var n = this.tree.query(this.interval), i = new rs(this, t), s = n.iterator(); s.hasNext();) {\n        var o = s.next();\n        this.testMonotoneChain(e, i, o);\n      }\n\n      return this.crossings % 2 === 1;\n    },\n    interfaces_: function interfaces_() {\n      return [ns];\n    },\n    getClass: function getClass() {\n      return is;\n    }\n  }), h(rs, tr), e(rs.prototype, {\n    select: function select() {\n      if (1 !== arguments.length) return tr.prototype.select.apply(this, arguments);\n      var t = arguments[0];\n      this.mcp.testLineSegment(this.p, t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return rs;\n    }\n  }), is.MCSelecter = rs, e(ss.prototype, {\n    insertEdgeEnds: function insertEdgeEnds(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.nodes.add(n);\n      }\n    },\n    getNodeIterator: function getNodeIterator() {\n      return this.nodes.iterator();\n    },\n    copyNodesAndLabels: function copyNodesAndLabels(t, e) {\n      for (var n = t.getNodeIterator(); n.hasNext();) {\n        var i = n.next(),\n            r = this.nodes.addNode(i.getCoordinate());\n        r.setLabel(e, i.getLabel().getLocation(e));\n      }\n    },\n    build: function build(t) {\n      this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);\n      var e = new br(),\n          n = e.computeEdgeEnds(t.getEdgeIterator());\n      this.insertEdgeEnds(n);\n    },\n    computeIntersectionNodes: function computeIntersectionNodes(t, e) {\n      for (var n = t.getEdgeIterator(); n.hasNext();) {\n        for (var i = n.next(), r = i.getLabel().getLocation(e), s = i.getEdgeIntersectionList().iterator(); s.hasNext();) {\n          var o = s.next(),\n              a = this.nodes.addNode(o.coord);\n          r === L.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, L.INTERIOR);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ss;\n    }\n  }), e(os.prototype, {\n    isNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {\n      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {\n        var e = t.next();\n        if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().copy(), !1;\n      }\n\n      return !0;\n    },\n    getInvalidPoint: function getInvalidPoint() {\n      return this.invalidPoint;\n    },\n    hasDuplicateRings: function hasDuplicateRings() {\n      for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {\n        for (var e = t.next(), n = e.getEdges().iterator(); n.hasNext();) {\n          var i = n.next();\n          if (i.getEdgeEnds().size() > 1) return this.invalidPoint = i.getEdge().getCoordinate(0), !0;\n        }\n      }\n\n      return !1;\n    },\n    isNodeConsistentArea: function isNodeConsistentArea() {\n      var t = this.geomGraph.computeSelfNodes(this.li, !0, !0);\n      return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return os;\n    }\n  }), e(as.prototype, {\n    buildIndex: function buildIndex() {\n      this.index = new ke();\n\n      for (var t = 0; t < this.rings.size(); t++) {\n        var e = this.rings.get(t),\n            n = e.getEnvelopeInternal();\n        this.index.insert(n, e);\n      }\n    },\n    getNestedPoint: function getNestedPoint() {\n      return this.nestedPt;\n    },\n    isNonNested: function isNonNested() {\n      this.buildIndex();\n\n      for (var t = 0; t < this.rings.size(); t++) {\n        for (var e = this.rings.get(t), n = e.getCoordinates(), i = this.index.query(e.getEnvelopeInternal()), r = 0; r < i.size(); r++) {\n          var s = i.get(r),\n              o = s.getCoordinates();\n\n          if (e !== s && e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())) {\n            var a = ls.findPtNotNode(n, s, this.graph);\n\n            if (null !== a) {\n              var u = he.isPointInRing(a, o);\n              if (u) return this.nestedPt = a, !1;\n            }\n          }\n        }\n      }\n\n      return !0;\n    },\n    add: function add(t) {\n      this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return as;\n    }\n  }), e(us.prototype, {\n    getErrorType: function getErrorType() {\n      return this.errorType;\n    },\n    getMessage: function getMessage() {\n      return us.errMsg[this.errorType];\n    },\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    toString: function toString() {\n      var t = \"\";\n      return null !== this.pt && (t = \" at or near point \" + this.pt), this.getMessage() + t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return us;\n    }\n  }), us.ERROR = 0, us.REPEATED_POINT = 1, us.HOLE_OUTSIDE_SHELL = 2, us.NESTED_HOLES = 3, us.DISCONNECTED_INTERIOR = 4, us.SELF_INTERSECTION = 5, us.RING_SELF_INTERSECTION = 6, us.NESTED_SHELLS = 7, us.DUPLICATE_RINGS = 8, us.TOO_FEW_POINTS = 9, us.INVALID_COORDINATE = 10, us.RING_NOT_CLOSED = 11, us.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"], e(ls.prototype, {\n    checkInvalidCoordinates: function checkInvalidCoordinates() {\n      if (arguments[0] instanceof Array) {\n        for (var t = arguments[0], e = 0; e < t.length; e++) {\n          if (!ls.isValid(t[e])) return this.validErr = new us(us.INVALID_COORDINATE, t[e]), null;\n        }\n      } else if (arguments[0] instanceof Tt) {\n        var n = arguments[0];\n        if (this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()), null !== this.validErr) return null;\n\n        for (var e = 0; e < n.getNumInteriorRing(); e++) {\n          if (this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()), null !== this.validErr) return null;\n        }\n      }\n    },\n    checkHolesNotNested: function checkHolesNotNested(t, e) {\n      for (var n = new as(e), i = 0; i < t.getNumInteriorRing(); i++) {\n        var r = t.getInteriorRingN(i);\n        n.add(r);\n      }\n\n      var s = n.isNonNested();\n      s || (this.validErr = new us(us.NESTED_HOLES, n.getNestedPoint()));\n    },\n    checkConsistentArea: function checkConsistentArea(t) {\n      var e = new os(t),\n          n = e.isNodeConsistentArea();\n      return n ? void (e.hasDuplicateRings() && (this.validErr = new us(us.DUPLICATE_RINGS, e.getInvalidPoint()))) : (this.validErr = new us(us.SELF_INTERSECTION, e.getInvalidPoint()), null);\n    },\n    isValid: function isValid() {\n      return this.checkValid(this.parentGeometry), null === this.validErr;\n    },\n    checkShellInsideHole: function checkShellInsideHole(t, e, n) {\n      var i = t.getCoordinates(),\n          r = e.getCoordinates(),\n          s = ls.findPtNotNode(i, e, n);\n\n      if (null !== s) {\n        var o = he.isPointInRing(s, r);\n        if (!o) return s;\n      }\n\n      var a = ls.findPtNotNode(r, t, n);\n\n      if (null !== a) {\n        var u = he.isPointInRing(a, i);\n        return u ? a : null;\n      }\n\n      return f.shouldNeverReachHere(\"points in shell and hole appear to be equal\"), null;\n    },\n    checkNoSelfIntersectingRings: function checkNoSelfIntersectingRings(t) {\n      for (var e = t.getEdgeIterator(); e.hasNext();) {\n        var n = e.next();\n        if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()), null !== this.validErr) return null;\n      }\n    },\n    checkConnectedInteriors: function checkConnectedInteriors(t) {\n      var e = new Kr(t);\n      e.isInteriorsConnected() || (this.validErr = new us(us.DISCONNECTED_INTERIOR, e.getCoordinate()));\n    },\n    checkNoSelfIntersectingRing: function checkNoSelfIntersectingRing(t) {\n      for (var e = new at(), n = !0, i = t.iterator(); i.hasNext();) {\n        var r = i.next();\n        if (n) n = !1;else {\n          if (e.contains(r.coord)) return this.validErr = new us(us.RING_SELF_INTERSECTION, r.coord), null;\n          e.add(r.coord);\n        }\n      }\n    },\n    checkHolesInShell: function checkHolesInShell(t, e) {\n      for (var n = t.getExteriorRing(), i = new is(n), r = 0; r < t.getNumInteriorRing(); r++) {\n        var s = t.getInteriorRingN(r),\n            o = ls.findPtNotNode(s.getCoordinates(), n, e);\n        if (null === o) return null;\n        var a = !i.isInside(o);\n        if (a) return this.validErr = new us(us.HOLE_OUTSIDE_SHELL, o), null;\n      }\n    },\n    checkTooFewPoints: function checkTooFewPoints(t) {\n      return t.hasTooFewPoints() ? (this.validErr = new us(us.TOO_FEW_POINTS, t.getInvalidPoint()), null) : void 0;\n    },\n    getValidationError: function getValidationError() {\n      return this.checkValid(this.parentGeometry), this.validErr;\n    },\n    checkValid: function checkValid() {\n      if (arguments[0] instanceof Lt) {\n        var t = arguments[0];\n        this.checkInvalidCoordinates(t.getCoordinates());\n      } else if (arguments[0] instanceof Pt) {\n        var e = arguments[0];\n        this.checkInvalidCoordinates(e.getCoordinates());\n      } else if (arguments[0] instanceof bt) {\n        var n = arguments[0];\n        if (this.checkInvalidCoordinates(n.getCoordinates()), null !== this.validErr) return null;\n        if (this.checkClosedRing(n), null !== this.validErr) return null;\n        var i = new $n(0, n);\n        if (this.checkTooFewPoints(i), null !== this.validErr) return null;\n        var r = new ae();\n        i.computeSelfNodes(r, !0, !0), this.checkNoSelfIntersectingRings(i);\n      } else if (arguments[0] instanceof St) {\n        var s = arguments[0];\n        if (this.checkInvalidCoordinates(s.getCoordinates()), null !== this.validErr) return null;\n        var i = new $n(0, s);\n        this.checkTooFewPoints(i);\n      } else if (arguments[0] instanceof Tt) {\n        var o = arguments[0];\n        if (this.checkInvalidCoordinates(o), null !== this.validErr) return null;\n        if (this.checkClosedRings(o), null !== this.validErr) return null;\n        var i = new $n(0, o);\n        if (this.checkTooFewPoints(i), null !== this.validErr) return null;\n        if (this.checkConsistentArea(i), null !== this.validErr) return null;\n        if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;\n        if (this.checkHolesInShell(o, i), null !== this.validErr) return null;\n        if (this.checkHolesNotNested(o, i), null !== this.validErr) return null;\n        this.checkConnectedInteriors(i);\n      } else if (arguments[0] instanceof Ot) {\n        for (var a = arguments[0], u = 0; u < a.getNumGeometries(); u++) {\n          var l = a.getGeometryN(u);\n          if (this.checkInvalidCoordinates(l), null !== this.validErr) return null;\n          if (this.checkClosedRings(l), null !== this.validErr) return null;\n        }\n\n        var i = new $n(0, a);\n        if (this.checkTooFewPoints(i), null !== this.validErr) return null;\n        if (this.checkConsistentArea(i), null !== this.validErr) return null;\n        if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i), null !== this.validErr)) return null;\n\n        for (var u = 0; u < a.getNumGeometries(); u++) {\n          var l = a.getGeometryN(u);\n          if (this.checkHolesInShell(l, i), null !== this.validErr) return null;\n        }\n\n        for (var u = 0; u < a.getNumGeometries(); u++) {\n          var l = a.getGeometryN(u);\n          if (this.checkHolesNotNested(l, i), null !== this.validErr) return null;\n        }\n\n        if (this.checkShellsNotNested(a, i), null !== this.validErr) return null;\n        this.checkConnectedInteriors(i);\n      } else if (arguments[0] instanceof ft) for (var h = arguments[0], u = 0; u < h.getNumGeometries(); u++) {\n        var c = h.getGeometryN(u);\n        if (this.checkValid(c), null !== this.validErr) return null;\n      } else if (arguments[0] instanceof B) {\n        var f = arguments[0];\n        if (this.validErr = null, f.isEmpty()) return null;\n        if (f instanceof Lt) this.checkValid(f);else if (f instanceof Pt) this.checkValid(f);else if (f instanceof bt) this.checkValid(f);else if (f instanceof St) this.checkValid(f);else if (f instanceof Tt) this.checkValid(f);else if (f instanceof Ot) this.checkValid(f);else {\n          if (!(f instanceof ft)) throw new UnsupportedOperationException(f.getClass().getName());\n          this.checkValid(f);\n        }\n      }\n    },\n    setSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(t) {\n      this.isSelfTouchingRingFormingHoleValid = t;\n    },\n    checkShellNotNested: function checkShellNotNested(t, e, n) {\n      var i = t.getCoordinates(),\n          r = e.getExteriorRing(),\n          s = r.getCoordinates(),\n          o = ls.findPtNotNode(i, r, n);\n      if (null === o) return null;\n      var a = he.isPointInRing(o, s);\n      if (!a) return null;\n      if (e.getNumInteriorRing() <= 0) return this.validErr = new us(us.NESTED_SHELLS, o), null;\n\n      for (var u = null, l = 0; l < e.getNumInteriorRing(); l++) {\n        var h = e.getInteriorRingN(l);\n        if (u = this.checkShellInsideHole(t, h, n), null === u) return null;\n      }\n\n      this.validErr = new us(us.NESTED_SHELLS, u);\n    },\n    checkClosedRings: function checkClosedRings(t) {\n      if (this.checkClosedRing(t.getExteriorRing()), null !== this.validErr) return null;\n\n      for (var e = 0; e < t.getNumInteriorRing(); e++) {\n        if (this.checkClosedRing(t.getInteriorRingN(e)), null !== this.validErr) return null;\n      }\n    },\n    checkClosedRing: function checkClosedRing(t) {\n      if (!t.isClosed()) {\n        var e = null;\n        t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new us(us.RING_NOT_CLOSED, e);\n      }\n    },\n    checkShellsNotNested: function checkShellsNotNested(t, e) {\n      for (var n = 0; n < t.getNumGeometries(); n++) {\n        for (var i = t.getGeometryN(n), r = i.getExteriorRing(), s = 0; s < t.getNumGeometries(); s++) {\n          if (n !== s) {\n            var o = t.getGeometryN(s);\n            if (this.checkShellNotNested(r, o, e), null !== this.validErr) return null;\n          }\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ls;\n    }\n  }), ls.findPtNotNode = function (t, e, n) {\n    for (var i = n.findEdge(e), r = i.getEdgeIntersectionList(), s = 0; s < t.length; s++) {\n      var o = t[s];\n      if (!r.isIntersection(o)) return o;\n    }\n\n    return null;\n  }, ls.isValid = function () {\n    if (arguments[0] instanceof B) {\n      var t = arguments[0],\n          e = new ls(t);\n      return e.isValid();\n    }\n\n    if (arguments[0] instanceof g) {\n      var n = arguments[0];\n      return r.isNaN(n.x) ? !1 : r.isInfinite(n.x) ? !1 : r.isNaN(n.y) ? !1 : !r.isInfinite(n.y);\n    }\n  };\n  var bo = Object.freeze({\n    IsValidOp: ls\n  }),\n      Oo = Object.freeze({\n    BoundaryOp: dt,\n    IsSimpleOp: Gi,\n    buffer: Co,\n    distance: So,\n    linemerge: wo,\n    overlay: Lo,\n    polygonize: Ro,\n    relate: To,\n    union: Po,\n    valid: bo\n  });\n  h(hs, _t.CoordinateOperation), e(hs.prototype, {\n    editCoordinates: function editCoordinates(t, e) {\n      if (0 === t.length) return null;\n\n      for (var n = new Array(t.length).fill(null), i = 0; i < t.length; i++) {\n        var r = new g(t[i]);\n        this.targetPM.makePrecise(r), n[i] = r;\n      }\n\n      var s = new N(n, !1),\n          o = s.toCoordinateArray(),\n          a = 0;\n      e instanceof St && (a = 2), e instanceof bt && (a = 4);\n      var u = n;\n      return this.removeCollapsed && (u = null), o.length < a ? u : o;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return hs;\n    }\n  }), e(cs.prototype, {\n    fixPolygonalTopology: function fixPolygonalTopology(t) {\n      var e = t;\n      this.changePrecisionModel || (e = this.changePM(t, this.targetPM));\n      var n = e.buffer(0),\n          i = n;\n      return this.changePrecisionModel || (i = t.getFactory().createGeometry(n)), i;\n    },\n    reducePointwise: function reducePointwise(t) {\n      var e = null;\n\n      if (this.changePrecisionModel) {\n        var n = this.createFactory(t.getFactory(), this.targetPM);\n        e = new _t(n);\n      } else e = new _t();\n\n      var i = this.removeCollapsed;\n      t.getDimension() >= 2 && (i = !0);\n      var r = e.edit(t, new hs(this.targetPM, i));\n      return r;\n    },\n    changePM: function changePM(t, e) {\n      var n = this.createEditor(t.getFactory(), e);\n      return n.edit(t, new _t.NoOpGeometryOperation());\n    },\n    setRemoveCollapsedComponents: function setRemoveCollapsedComponents(t) {\n      this.removeCollapsed = t;\n    },\n    createFactory: function createFactory(t, e) {\n      var n = new ie(e, t.getSRID(), t.getCoordinateSequenceFactory());\n      return n;\n    },\n    setChangePrecisionModel: function setChangePrecisionModel(t) {\n      this.changePrecisionModel = t;\n    },\n    reduce: function reduce(t) {\n      var e = this.reducePointwise(t);\n      return this.isPointwise ? e : R(e, Rt) ? e.isValid() ? e : this.fixPolygonalTopology(e) : e;\n    },\n    setPointwise: function setPointwise(t) {\n      this.isPointwise = t;\n    },\n    createEditor: function createEditor(t, e) {\n      if (t.getPrecisionModel() === e) return new _t();\n      var n = this.createFactory(t, e),\n          i = new _t(n);\n      return i;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return cs;\n    }\n  }), cs.reduce = function (t, e) {\n    var n = new cs(e);\n    return n.reduce(t);\n  }, cs.reducePointwise = function (t, e) {\n    var n = new cs(e);\n    return n.setPointwise(!0), n.reduce(t);\n  };\n\n  var _o = Object.freeze({\n    GeometryPrecisionReducer: cs\n  });\n\n  e(fs.prototype, {\n    simplifySection: function simplifySection(t, e) {\n      if (t + 1 === e) return null;\n      this.seg.p0 = this.pts[t], this.seg.p1 = this.pts[e];\n\n      for (var n = -1, i = t, r = t + 1; e > r; r++) {\n        var s = this.seg.distance(this.pts[r]);\n        s > n && (n = s, i = r);\n      }\n\n      if (n <= this.distanceTolerance) for (var r = t + 1; e > r; r++) {\n        this.usePt[r] = !1;\n      } else this.simplifySection(t, i), this.simplifySection(i, e);\n    },\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      this.distanceTolerance = t;\n    },\n    simplify: function simplify() {\n      this.usePt = new Array(this.pts.length).fill(null);\n\n      for (var t = 0; t < this.pts.length; t++) {\n        this.usePt[t] = !0;\n      }\n\n      this.simplifySection(0, this.pts.length - 1);\n\n      for (var e = new N(), t = 0; t < this.pts.length; t++) {\n        this.usePt[t] && e.add(new g(this.pts[t]));\n      }\n\n      return e.toCoordinateArray();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return fs;\n    }\n  }), fs.simplify = function (t, e) {\n    var n = new fs(t);\n    return n.setDistanceTolerance(e), n.simplify();\n  }, e(gs.prototype, {\n    setEnsureValid: function setEnsureValid(t) {\n      this.isEnsureValidTopology = t;\n    },\n    getResultGeometry: function getResultGeometry() {\n      return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new ds(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom);\n    },\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      if (0 > t) throw new i(\"Tolerance must be non-negative\");\n      this.distanceTolerance = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return gs;\n    }\n  }), gs.simplify = function (t, e) {\n    var n = new gs(t);\n    return n.setDistanceTolerance(e), n.getResultGeometry();\n  }, h(ds, xe), e(ds.prototype, {\n    transformPolygon: function transformPolygon(t, e) {\n      if (t.isEmpty()) return null;\n      var n = xe.prototype.transformPolygon.call(this, t, e);\n      return e instanceof Ot ? n : this.createValidArea(n);\n    },\n    createValidArea: function createValidArea(t) {\n      return this.isEnsureValidTopology ? t.buffer(0) : t;\n    },\n    transformCoordinates: function transformCoordinates(t, e) {\n      var n = t.toCoordinateArray(),\n          i = null;\n      return i = 0 === n.length ? new Array(0).fill(null) : fs.simplify(n, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(i);\n    },\n    transformMultiPolygon: function transformMultiPolygon(t, e) {\n      var n = xe.prototype.transformMultiPolygon.call(this, t, e);\n      return this.createValidArea(n);\n    },\n    transformLinearRing: function transformLinearRing(t, e) {\n      var n = e instanceof Tt,\n          i = xe.prototype.transformLinearRing.call(this, t, e);\n      return !n || i instanceof bt ? i : null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ds;\n    }\n  }), gs.DPTransformer = ds, h(ps, ce), e(ps.prototype, {\n    getIndex: function getIndex() {\n      return this.index;\n    },\n    getParent: function getParent() {\n      return this.parent;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ps;\n    }\n  }), e(vs.prototype, {\n    addToResult: function addToResult(t) {\n      this.resultSegs.add(t);\n    },\n    asLineString: function asLineString() {\n      return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs));\n    },\n    getResultSize: function getResultSize() {\n      var t = this.resultSegs.size();\n      return 0 === t ? 0 : t + 1;\n    },\n    getParent: function getParent() {\n      return this.parentLine;\n    },\n    getSegment: function getSegment(t) {\n      return this.segs[t];\n    },\n    getParentCoordinates: function getParentCoordinates() {\n      return this.parentLine.getCoordinates();\n    },\n    getMinimumSize: function getMinimumSize() {\n      return this.minimumSize;\n    },\n    asLinearRing: function asLinearRing() {\n      return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs));\n    },\n    getSegments: function getSegments() {\n      return this.segs;\n    },\n    init: function init() {\n      var t = this.parentLine.getCoordinates();\n      this.segs = new Array(t.length - 1).fill(null);\n\n      for (var e = 0; e < t.length - 1; e++) {\n        var n = new ps(t[e], t[e + 1], this.parentLine, e);\n        this.segs[e] = n;\n      }\n    },\n    getResultCoordinates: function getResultCoordinates() {\n      return vs.extractCoordinates(this.resultSegs);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return vs;\n    }\n  }), vs.extractCoordinates = function (t) {\n    for (var e = new Array(t.size() + 1).fill(null), n = null, i = 0; i < t.size(); i++) {\n      n = t.get(i), e[i] = n.p0;\n    }\n\n    return e[e.length - 1] = n.p1, e;\n  }, e(ms.prototype, {\n    remove: function remove(t) {\n      this.index.remove(new C(t.p0, t.p1), t);\n    },\n    add: function add() {\n      if (arguments[0] instanceof vs) for (var t = arguments[0], e = t.getSegments(), n = 0; n < e.length; n++) {\n        var i = e[n];\n        this.add(i);\n      } else if (arguments[0] instanceof ce) {\n        var r = arguments[0];\n        this.index.insert(new C(r.p0, r.p1), r);\n      }\n    },\n    query: function query(t) {\n      var e = new C(t.p0, t.p1),\n          n = new ys(t);\n      this.index.query(e, n);\n      var i = n.getItems();\n      return i;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ms;\n    }\n  }), e(ys.prototype, {\n    visitItem: function visitItem(t) {\n      var e = t;\n      C.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t);\n    },\n    getItems: function getItems() {\n      return this.items;\n    },\n    interfaces_: function interfaces_() {\n      return [Ae];\n    },\n    getClass: function getClass() {\n      return ys;\n    }\n  }), e(xs.prototype, {\n    flatten: function flatten(t, e) {\n      var n = this.linePts[t],\n          i = this.linePts[e],\n          r = new ce(n, i);\n      return this.remove(this.line, t, e), this.outputIndex.add(r), r;\n    },\n    hasBadIntersection: function hasBadIntersection(t, e, n) {\n      return this.hasBadOutputIntersection(n) ? !0 : !!this.hasBadInputIntersection(t, e, n);\n    },\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      this.distanceTolerance = t;\n    },\n    simplifySection: function simplifySection(t, e, n) {\n      n += 1;\n      var i = new Array(2).fill(null);\n\n      if (t + 1 === e) {\n        var r = this.line.getSegment(t);\n        return this.line.addToResult(r), null;\n      }\n\n      var s = !0;\n\n      if (this.line.getResultSize() < this.line.getMinimumSize()) {\n        var o = n + 1;\n        o < this.line.getMinimumSize() && (s = !1);\n      }\n\n      var a = new Array(1).fill(null),\n          u = this.findFurthestPoint(this.linePts, t, e, a);\n      a[0] > this.distanceTolerance && (s = !1);\n      var l = new ce();\n\n      if (l.p0 = this.linePts[t], l.p1 = this.linePts[e], i[0] = t, i[1] = e, this.hasBadIntersection(this.line, i, l) && (s = !1), s) {\n        var r = this.flatten(t, e);\n        return this.line.addToResult(r), null;\n      }\n\n      this.simplifySection(t, u, n), this.simplifySection(u, e, n);\n    },\n    hasBadOutputIntersection: function hasBadOutputIntersection(t) {\n      for (var e = this.outputIndex.query(t), n = e.iterator(); n.hasNext();) {\n        var i = n.next();\n        if (this.hasInteriorIntersection(i, t)) return !0;\n      }\n\n      return !1;\n    },\n    findFurthestPoint: function findFurthestPoint(t, e, n, i) {\n      var r = new ce();\n      r.p0 = t[e], r.p1 = t[n];\n\n      for (var s = -1, o = e, a = e + 1; n > a; a++) {\n        var u = t[a],\n            l = r.distance(u);\n        l > s && (s = l, o = a);\n      }\n\n      return i[0] = s, o;\n    },\n    simplify: function simplify(t) {\n      this.line = t, this.linePts = t.getParentCoordinates(), this.simplifySection(0, this.linePts.length - 1, 0);\n    },\n    remove: function remove(t, e, n) {\n      for (var i = e; n > i; i++) {\n        var r = t.getSegment(i);\n        this.inputIndex.remove(r);\n      }\n    },\n    hasInteriorIntersection: function hasInteriorIntersection(t, e) {\n      return this.li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this.li.isInteriorIntersection();\n    },\n    hasBadInputIntersection: function hasBadInputIntersection(t, e, n) {\n      for (var i = this.inputIndex.query(n), r = i.iterator(); r.hasNext();) {\n        var s = r.next();\n\n        if (this.hasInteriorIntersection(s, n)) {\n          if (xs.isInLineSection(t, e, s)) continue;\n          return !0;\n        }\n      }\n\n      return !1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return xs;\n    }\n  }), xs.isInLineSection = function (t, e, n) {\n    if (n.getParent() !== t.getParent()) return !1;\n    var i = n.getIndex();\n    return i >= e[0] && i < e[1];\n  }, e(Es.prototype, {\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      this.distanceTolerance = t;\n    },\n    simplify: function simplify(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        this.inputIndex.add(e.next());\n      }\n\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = new xs(this.inputIndex, this.outputIndex);\n        n.setDistanceTolerance(this.distanceTolerance), n.simplify(e.next());\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Es;\n    }\n  }), e(Is.prototype, {\n    getResultGeometry: function getResultGeometry() {\n      if (this.inputGeom.isEmpty()) return this.inputGeom.copy();\n      this.linestringMap = new te(), this.inputGeom.apply(new Cs(this)), this.lineSimplifier.simplify(this.linestringMap.values());\n      var t = new Ns(this.linestringMap).transform(this.inputGeom);\n      return t;\n    },\n    setDistanceTolerance: function setDistanceTolerance(t) {\n      if (0 > t) throw new i(\"Tolerance must be non-negative\");\n      this.lineSimplifier.setDistanceTolerance(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Is;\n    }\n  }), Is.simplify = function (t, e) {\n    var n = new Is(t);\n    return n.setDistanceTolerance(e), n.getResultGeometry();\n  }, h(Ns, xe), e(Ns.prototype, {\n    transformCoordinates: function transformCoordinates(t, e) {\n      if (0 === t.size()) return null;\n\n      if (e instanceof St) {\n        var n = this.linestringMap.get(e);\n        return this.createCoordinateSequence(n.getResultCoordinates());\n      }\n\n      return xe.prototype.transformCoordinates.call(this, t, e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ns;\n    }\n  }), e(Cs.prototype, {\n    filter: function filter(t) {\n      if (t instanceof St) {\n        var e = t;\n        if (e.isEmpty()) return null;\n        var n = e.isClosed() ? 4 : 2,\n            i = new vs(e, n);\n        this.tps.linestringMap.put(e, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [q];\n    },\n    getClass: function getClass() {\n      return Cs;\n    }\n  }), Is.LineStringTransformer = Ns, Is.LineStringMapBuilderFilter = Cs;\n  var Mo = Object.freeze({\n    DouglasPeuckerSimplifier: gs,\n    TopologyPreservingSimplifier: Is\n  });\n  e(Ss.prototype, {\n    splitAt: function splitAt() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = this.minimumLen / this.segLen;\n        if (t.distance(this.seg.p0) < this.minimumLen) return this.splitPt = this.seg.pointAlong(e), null;\n        if (t.distance(this.seg.p1) < this.minimumLen) return this.splitPt = Ss.pointAlongReverse(this.seg, e), null;\n        this.splitPt = t;\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = this.getConstrainedLength(n),\n            s = r / this.segLen;\n        i.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(s) : this.splitPt = Ss.pointAlongReverse(this.seg, s);\n      }\n    },\n    setMinimumLength: function setMinimumLength(t) {\n      this.minimumLen = t;\n    },\n    getConstrainedLength: function getConstrainedLength(t) {\n      return t < this.minimumLen ? this.minimumLen : t;\n    },\n    getSplitPoint: function getSplitPoint() {\n      return this.splitPt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ss;\n    }\n  }), Ss.pointAlongReverse = function (t, e) {\n    var n = new g();\n    return n.x = t.p1.x - e * (t.p1.x - t.p0.x), n.y = t.p1.y - e * (t.p1.y - t.p0.y), n;\n  }, e(ws.prototype, {\n    findSplitPoint: function findSplitPoint(t, e) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ws;\n    }\n  }), e(Ls.prototype, {\n    findSplitPoint: function findSplitPoint(t, e) {\n      var n = t.getLineSegment(),\n          i = n.getLength(),\n          r = i / 2,\n          s = new Ss(n),\n          o = Ls.projectedSplitPoint(t, e),\n          a = 2 * o.distance(e) * .8,\n          u = a;\n      return u > r && (u = r), s.setMinimumLength(u), s.splitAt(o), s.getSplitPoint();\n    },\n    interfaces_: function interfaces_() {\n      return [ws];\n    },\n    getClass: function getClass() {\n      return Ls;\n    }\n  }), Ls.projectedSplitPoint = function (t, e) {\n    var n = t.getLineSegment(),\n        i = n.project(e);\n    return i;\n  }, e(Rs.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Rs;\n    }\n  }), Rs.triArea = function (t, e, n) {\n    return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x);\n  }, Rs.isInCircleDDNormalized = function (t, e, n, i) {\n    var r = _.valueOf(t.x).selfSubtract(i.x),\n        s = _.valueOf(t.y).selfSubtract(i.y),\n        o = _.valueOf(e.x).selfSubtract(i.x),\n        a = _.valueOf(e.y).selfSubtract(i.y),\n        u = _.valueOf(n.x).selfSubtract(i.x),\n        l = _.valueOf(n.y).selfSubtract(i.y),\n        h = r.multiply(a).selfSubtract(o.multiply(s)),\n        c = o.multiply(l).selfSubtract(u.multiply(a)),\n        f = u.multiply(s).selfSubtract(r.multiply(l)),\n        g = r.multiply(r).selfAdd(s.multiply(s)),\n        d = o.multiply(o).selfAdd(a.multiply(a)),\n        p = u.multiply(u).selfAdd(l.multiply(l)),\n        v = g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),\n        m = v.doubleValue() > 0;\n\n    return m;\n  }, Rs.checkRobustInCircle = function (t, e, n, i) {\n    var r = Rs.isInCircleNonRobust(t, e, n, i),\n        s = Rs.isInCircleDDSlow(t, e, n, i),\n        o = Rs.isInCircleCC(t, e, n, i),\n        a = ci.circumcentre(t, e, n);\n    A.out.println(\"p radius diff a = \" + Math.abs(i.distance(a) - t.distance(a)) / t.distance(a)), r === s && r === o || (A.out.println(\"inCircle robustness failure (double result = \" + r + \", DD result = \" + s + \", CC result = \" + o + \")\"), A.out.println(se.toLineString(new Gt([t, e, n, i]))), A.out.println(\"Circumcentre = \" + se.toPoint(a) + \" radius = \" + t.distance(a)), A.out.println(\"p radius diff a = \" + Math.abs(i.distance(a) / t.distance(a) - 1)), A.out.println(\"p radius diff b = \" + Math.abs(i.distance(a) / e.distance(a) - 1)), A.out.println(\"p radius diff c = \" + Math.abs(i.distance(a) / n.distance(a) - 1)), A.out.println());\n  }, Rs.isInCircleDDFast = function (t, e, n, i) {\n    var r = _.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e, n, i)),\n        s = _.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t, n, i)),\n        o = _.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t, e, i)),\n        a = _.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t, e, n)),\n        u = r.selfSubtract(s).selfAdd(o).selfSubtract(a),\n        l = u.doubleValue() > 0;\n\n    return l;\n  }, Rs.isInCircleCC = function (t, e, n, i) {\n    var r = ci.circumcentre(t, e, n),\n        s = t.distance(r),\n        o = i.distance(r) - s;\n    return 0 >= o;\n  }, Rs.isInCircleNormalized = function (t, e, n, i) {\n    var r = t.x - i.x,\n        s = t.y - i.y,\n        o = e.x - i.x,\n        a = e.y - i.y,\n        u = n.x - i.x,\n        l = n.y - i.y,\n        h = r * a - o * s,\n        c = o * l - u * a,\n        f = u * s - r * l,\n        g = r * r + s * s,\n        d = o * o + a * a,\n        p = u * u + l * l,\n        v = g * c + d * f + p * h;\n    return v > 0;\n  }, Rs.isInCircleDDSlow = function (t, e, n, i) {\n    var r = _.valueOf(i.x),\n        s = _.valueOf(i.y),\n        o = _.valueOf(t.x),\n        a = _.valueOf(t.y),\n        u = _.valueOf(e.x),\n        l = _.valueOf(e.y),\n        h = _.valueOf(n.x),\n        c = _.valueOf(n.y),\n        f = o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u, l, h, c, r, s)),\n        g = u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o, a, h, c, r, s)),\n        d = h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o, a, u, l, r, s)),\n        p = r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o, a, u, l, h, c)),\n        v = f.subtract(g).add(d).subtract(p),\n        m = v.doubleValue() > 0;\n\n    return m;\n  }, Rs.isInCircleNonRobust = function (t, e, n, i) {\n    var r = (t.x * t.x + t.y * t.y) * Rs.triArea(e, n, i) - (e.x * e.x + e.y * e.y) * Rs.triArea(t, n, i) + (n.x * n.x + n.y * n.y) * Rs.triArea(t, e, i) - (i.x * i.x + i.y * i.y) * Rs.triArea(t, e, n) > 0;\n    return r;\n  }, Rs.isInCircleRobust = function (t, e, n, i) {\n    return Rs.isInCircleNormalized(t, e, n, i);\n  }, Rs.triAreaDDSlow = function (t, e, n, i, r, s) {\n    return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)));\n  }, Rs.triAreaDDFast = function (t, e, n) {\n    var i = _.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),\n        r = _.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));\n\n    return i.selfSubtract(r);\n  }, e(Ts.prototype, {\n    circleCenter: function circleCenter(t, e) {\n      var n = new Ts(this.getX(), this.getY()),\n          i = this.bisector(n, t),\n          r = this.bisector(t, e),\n          s = new F(i, r),\n          o = null;\n\n      try {\n        o = new Ts(s.getX(), s.getY());\n      } catch (i) {\n        if (!(i instanceof w)) throw i;\n        A.err.println(\"a: \" + n + \"  b: \" + t + \"  c: \" + e), A.err.println(i);\n      } finally {}\n\n      return o;\n    },\n    dot: function dot(t) {\n      return this.p.x * t.getX() + this.p.y * t.getY();\n    },\n    magn: function magn() {\n      return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y);\n    },\n    getZ: function getZ() {\n      return this.p.z;\n    },\n    bisector: function bisector(t, e) {\n      var n = e.getX() - t.getX(),\n          i = e.getY() - t.getY(),\n          r = new F(t.getX() + n / 2, t.getY() + i / 2, 1),\n          s = new F(t.getX() - i + n / 2, t.getY() + n + i / 2, 1);\n      return new F(r, s);\n    },\n    equals: function equals() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.p.x === t.getX() && this.p.y === t.getY();\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return this.p.distance(e.getCoordinate()) < n;\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this.p;\n    },\n    isInCircle: function isInCircle(t, e, n) {\n      return Rs.isInCircleRobust(t.p, e.p, n.p, this.p);\n    },\n    interpolateZValue: function interpolateZValue(t, e, n) {\n      var i = t.getX(),\n          r = t.getY(),\n          s = e.getX() - i,\n          o = n.getX() - i,\n          a = e.getY() - r,\n          u = n.getY() - r,\n          l = s * u - o * a,\n          h = this.getX() - i,\n          c = this.getY() - r,\n          f = (u * h - o * c) / l,\n          g = (-a * h + s * c) / l,\n          d = t.getZ() + f * (e.getZ() - t.getZ()) + g * (n.getZ() - t.getZ());\n      return d;\n    },\n    midPoint: function midPoint(t) {\n      var e = (this.p.x + t.getX()) / 2,\n          n = (this.p.y + t.getY()) / 2,\n          i = (this.p.z + t.getZ()) / 2;\n      return new Ts(e, n, i);\n    },\n    rightOf: function rightOf(t) {\n      return this.isCCW(t.dest(), t.orig());\n    },\n    isCCW: function isCCW(t, e) {\n      return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0;\n    },\n    getX: function getX() {\n      return this.p.x;\n    },\n    crossProduct: function crossProduct(t) {\n      return this.p.x * t.getY() - this.p.y * t.getX();\n    },\n    setZ: function setZ(t) {\n      this.p.z = t;\n    },\n    times: function times(t) {\n      return new Ts(t * this.p.x, t * this.p.y);\n    },\n    cross: function cross() {\n      return new Ts(this.p.y, -this.p.x);\n    },\n    leftOf: function leftOf(t) {\n      return this.isCCW(t.orig(), t.dest());\n    },\n    toString: function toString() {\n      return \"POINT (\" + this.p.x + \" \" + this.p.y + \")\";\n    },\n    sub: function sub(t) {\n      return new Ts(this.p.x - t.getX(), this.p.y - t.getY());\n    },\n    getY: function getY() {\n      return this.p.y;\n    },\n    classify: function classify(t, e) {\n      var n = this,\n          i = e.sub(t),\n          r = n.sub(t),\n          s = i.crossProduct(r);\n      return s > 0 ? Ts.LEFT : 0 > s ? Ts.RIGHT : i.getX() * r.getX() < 0 || i.getY() * r.getY() < 0 ? Ts.BEHIND : i.magn() < r.magn() ? Ts.BEYOND : t.equals(n) ? Ts.ORIGIN : e.equals(n) ? Ts.DESTINATION : Ts.BETWEEN;\n    },\n    sum: function sum(t) {\n      return new Ts(this.p.x + t.getX(), this.p.y + t.getY());\n    },\n    distance: function distance(t, e) {\n      return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2));\n    },\n    circumRadiusRatio: function circumRadiusRatio(t, e) {\n      var n = this.circleCenter(t, e),\n          i = this.distance(n, t),\n          r = this.distance(this, t),\n          s = this.distance(t, e);\n      return r > s && (r = s), s = this.distance(e, this), r > s && (r = s), i / r;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ts;\n    }\n  }), Ts.interpolateZ = function () {\n    if (3 === arguments.length) {\n      var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2],\n          i = e.distance(n),\n          r = t.distance(e),\n          s = n.z - e.z,\n          o = e.z + s * (r / i);\n      return o;\n    }\n\n    if (4 === arguments.length) {\n      var a = arguments[0],\n          u = arguments[1],\n          l = arguments[2],\n          h = arguments[3],\n          c = u.x,\n          f = u.y,\n          g = l.x - c,\n          d = h.x - c,\n          p = l.y - f,\n          v = h.y - f,\n          m = g * v - d * p,\n          y = a.x - c,\n          x = a.y - f,\n          E = (v * y - d * x) / m,\n          I = (-p * y + g * x) / m,\n          N = u.z + E * (l.z - u.z) + I * (h.z - u.z);\n      return N;\n    }\n  }, Ts.LEFT = 0, Ts.RIGHT = 1, Ts.BEYOND = 2, Ts.BEHIND = 3, Ts.BETWEEN = 4, Ts.ORIGIN = 5, Ts.DESTINATION = 6, h(Ps, Ts), e(Ps.prototype, {\n    getConstraint: function getConstraint() {\n      return this.constraint;\n    },\n    setOnConstraint: function setOnConstraint(t) {\n      this._isOnConstraint = t;\n    },\n    merge: function merge(t) {\n      t._isOnConstraint && (this._isOnConstraint = !0, this.constraint = t.constraint);\n    },\n    isOnConstraint: function isOnConstraint() {\n      return this._isOnConstraint;\n    },\n    setConstraint: function setConstraint(t) {\n      this._isOnConstraint = !0, this.constraint = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ps;\n    }\n  }), e(bs.prototype, {\n    equalsNonOriented: function equalsNonOriented(t) {\n      return this.equalsOriented(t) ? !0 : !!this.equalsOriented(t.sym());\n    },\n    toLineSegment: function toLineSegment() {\n      return new ce(this.vertex.getCoordinate(), this.dest().getCoordinate());\n    },\n    dest: function dest() {\n      return this.sym().orig();\n    },\n    oNext: function oNext() {\n      return this.next;\n    },\n    equalsOriented: function equalsOriented(t) {\n      return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()));\n    },\n    dNext: function dNext() {\n      return this.sym().oNext().sym();\n    },\n    lPrev: function lPrev() {\n      return this.next.sym();\n    },\n    rPrev: function rPrev() {\n      return this.sym().oNext();\n    },\n    rot: function rot() {\n      return this._rot;\n    },\n    oPrev: function oPrev() {\n      return this._rot.next._rot;\n    },\n    sym: function sym() {\n      return this._rot._rot;\n    },\n    setOrig: function setOrig(t) {\n      this.vertex = t;\n    },\n    lNext: function lNext() {\n      return this.invRot().oNext().rot();\n    },\n    getLength: function getLength() {\n      return this.orig().getCoordinate().distance(this.dest().getCoordinate());\n    },\n    invRot: function invRot() {\n      return this._rot.sym();\n    },\n    setDest: function setDest(t) {\n      this.sym().setOrig(t);\n    },\n    setData: function setData(t) {\n      this.data = t;\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    delete: function _delete() {\n      this._rot = null;\n    },\n    orig: function orig() {\n      return this.vertex;\n    },\n    rNext: function rNext() {\n      return this._rot.next.invRot();\n    },\n    toString: function toString() {\n      var t = this.vertex.getCoordinate(),\n          e = this.dest().getCoordinate();\n      return se.toLineString(t, e);\n    },\n    isLive: function isLive() {\n      return null !== this._rot;\n    },\n    getPrimary: function getPrimary() {\n      return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym();\n    },\n    dPrev: function dPrev() {\n      return this.invRot().oNext().invRot();\n    },\n    setNext: function setNext(t) {\n      this.next = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return bs;\n    }\n  }), bs.makeEdge = function (t, e) {\n    var n = new bs(),\n        i = new bs(),\n        r = new bs(),\n        s = new bs();\n    n._rot = i, i._rot = r, r._rot = s, s._rot = n, n.setNext(n), i.setNext(s), r.setNext(r), s.setNext(i);\n    var o = n;\n    return o.setOrig(t), o.setDest(e), o;\n  }, bs.swap = function (t) {\n    var e = t.oPrev(),\n        n = t.sym().oPrev();\n    bs.splice(t, e), bs.splice(t.sym(), n), bs.splice(t, e.lNext()), bs.splice(t.sym(), n.lNext()), t.setOrig(e.dest()), t.setDest(n.dest());\n  }, bs.splice = function (t, e) {\n    var n = t.oNext().rot(),\n        i = e.oNext().rot(),\n        r = e.oNext(),\n        s = t.oNext(),\n        o = i.oNext(),\n        a = n.oNext();\n    t.setNext(r), e.setNext(s), n.setNext(o), i.setNext(a);\n  }, bs.connect = function (t, e) {\n    var n = bs.makeEdge(t.dest(), e.orig());\n    return bs.splice(n, t.lNext()), bs.splice(n.sym(), e), n;\n  }, e(Os.prototype, {\n    insertSite: function insertSite(t) {\n      var e = this.subdiv.locate(t);\n      if (this.subdiv.isVertexOfEdge(e, t)) return e;\n      this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this.subdiv.delete(e.oNext()));\n      var n = this.subdiv.makeEdge(e.orig(), t);\n      bs.splice(n, e);\n      var i = n;\n\n      do {\n        n = this.subdiv.connect(e, n.sym()), e = n.oPrev();\n      } while (e.lNext() !== i);\n\n      for (;;) {\n        var r = e.oPrev();\n        if (r.dest().rightOf(e) && t.isInCircle(e.orig(), r.dest(), e.dest())) bs.swap(e), e = e.oPrev();else {\n          if (e.oNext() === i) return n;\n          e = e.oNext().lPrev();\n        }\n      }\n    },\n    insertSites: function insertSites(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.insertSite(n);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Os;\n    }\n  }), e(_s.prototype, {\n    locate: function locate(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return _s;\n    }\n  }), e(Ms.prototype, {\n    init: function init() {\n      this.lastEdge = this.findEdge();\n    },\n    locate: function locate(t) {\n      this.lastEdge.isLive() || this.init();\n      var e = this.subdiv.locateFromEdge(t, this.lastEdge);\n      return this.lastEdge = e, e;\n    },\n    findEdge: function findEdge() {\n      var t = this.subdiv.getEdges();\n      return t.iterator().next();\n    },\n    interfaces_: function interfaces_() {\n      return [_s];\n    },\n    getClass: function getClass() {\n      return Ms;\n    }\n  }), h(Ds, l), e(Ds.prototype, {\n    getSegment: function getSegment() {\n      return this.seg;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ds;\n    }\n  }), Ds.msgWithSpatial = function (t, e) {\n    return null !== e ? t + \" [ \" + e + \" ]\" : t;\n  }, e(As.prototype, {\n    visit: function visit(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return As;\n    }\n  }), e(Fs.prototype, {\n    getTriangleVertices: function getTriangleVertices(t) {\n      var e = new Bs();\n      return this.visitTriangles(e, t), e.getTriangleVertices();\n    },\n    isFrameVertex: function isFrameVertex(t) {\n      return t.equals(this.frameVertex[0]) ? !0 : t.equals(this.frameVertex[1]) ? !0 : !!t.equals(this.frameVertex[2]);\n    },\n    isVertexOfEdge: function isVertexOfEdge(t, e) {\n      return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance));\n    },\n    connect: function connect(t, e) {\n      var n = bs.connect(t, e);\n      return this.quadEdges.add(n), n;\n    },\n    getVoronoiCellPolygon: function getVoronoiCellPolygon(t, e) {\n      var n = new I(),\n          i = t;\n\n      do {\n        var r = t.rot().orig().getCoordinate();\n        n.add(r), t = t.oPrev();\n      } while (t !== i);\n\n      var s = new N();\n      s.addAll(n, !1), s.closeRing(), s.size() < 4 && (A.out.println(s), s.add(s.get(s.size() - 1), !0));\n      var o = s.toCoordinateArray(),\n          a = e.createPolygon(e.createLinearRing(o), null),\n          u = i.orig();\n      return a.setUserData(u.getCoordinate()), a;\n    },\n    setLocator: function setLocator(t) {\n      this.locator = t;\n    },\n    initSubdiv: function initSubdiv() {\n      var t = this.makeEdge(this.frameVertex[0], this.frameVertex[1]),\n          e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);\n      bs.splice(t.sym(), e);\n      var n = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);\n      return bs.splice(e.sym(), n), bs.splice(n.sym(), t), t;\n    },\n    isFrameBorderEdge: function isFrameBorderEdge(t) {\n      var e = new Array(3).fill(null);\n      Fs.getTriangleEdges(t, e);\n      var n = new Array(3).fill(null);\n      Fs.getTriangleEdges(t.sym(), n);\n      var i = t.lNext().dest();\n      if (this.isFrameVertex(i)) return !0;\n      var r = t.sym().lNext().dest();\n      return !!this.isFrameVertex(r);\n    },\n    makeEdge: function makeEdge(t, e) {\n      var n = bs.makeEdge(t, e);\n      return this.quadEdges.add(n), n;\n    },\n    visitTriangles: function visitTriangles(t, e) {\n      this.visitedKey++;\n      var n = new pe();\n      n.push(this.startingEdge);\n\n      for (var i = new J(); !n.empty();) {\n        var r = n.pop();\n\n        if (!i.contains(r)) {\n          var s = this.fetchTriangleToVisit(r, n, e, i);\n          null !== s && t.visit(s);\n        }\n      }\n    },\n    isFrameEdge: function isFrameEdge(t) {\n      return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()));\n    },\n    isOnEdge: function isOnEdge(t, e) {\n      this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate());\n      var n = this.seg.distance(e);\n      return n < this.edgeCoincidenceTolerance;\n    },\n    getEnvelope: function getEnvelope() {\n      return new C(this.frameEnv);\n    },\n    createFrame: function createFrame(t) {\n      var e = t.getWidth(),\n          n = t.getHeight(),\n          i = 0;\n      i = e > n ? 10 * e : 10 * n, this.frameVertex[0] = new Ts((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + i), this.frameVertex[1] = new Ts(t.getMinX() - i, t.getMinY() - i), this.frameVertex[2] = new Ts(t.getMaxX() + i, t.getMinY() - i), this.frameEnv = new C(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());\n    },\n    getTriangleCoordinates: function getTriangleCoordinates(t) {\n      var e = new zs();\n      return this.visitTriangles(e, t), e.getTriangles();\n    },\n    getVertices: function getVertices(t) {\n      for (var e = new J(), n = this.quadEdges.iterator(); n.hasNext();) {\n        var i = n.next(),\n            r = i.orig();\n        !t && this.isFrameVertex(r) || e.add(r);\n        var s = i.dest();\n        !t && this.isFrameVertex(s) || e.add(s);\n      }\n\n      return e;\n    },\n    fetchTriangleToVisit: function fetchTriangleToVisit(t, e, n, i) {\n      var r = t,\n          s = 0,\n          o = !1;\n\n      do {\n        this.triEdges[s] = r, this.isFrameEdge(r) && (o = !0);\n        var a = r.sym();\n        i.contains(a) || e.push(a), i.add(r), s++, r = r.lNext();\n      } while (r !== t);\n\n      return o && !n ? null : this.triEdges;\n    },\n    getEdges: function getEdges() {\n      if (0 === arguments.length) return this.quadEdges;\n\n      if (1 === arguments.length) {\n        for (var t = arguments[0], e = this.getPrimaryEdges(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext();) {\n          var s = r.next();\n          n[i++] = t.createLineString([s.orig().getCoordinate(), s.dest().getCoordinate()]);\n        }\n\n        return t.createMultiLineString(n);\n      }\n    },\n    getVertexUniqueEdges: function getVertexUniqueEdges(t) {\n      for (var e = new I(), n = new J(), i = this.quadEdges.iterator(); i.hasNext();) {\n        var r = i.next(),\n            s = r.orig();\n        n.contains(s) || (n.add(s), !t && this.isFrameVertex(s) || e.add(r));\n        var o = r.sym(),\n            a = o.orig();\n        n.contains(a) || (n.add(a), !t && this.isFrameVertex(a) || e.add(o));\n      }\n\n      return e;\n    },\n    getTriangleEdges: function getTriangleEdges(t) {\n      var e = new qs();\n      return this.visitTriangles(e, t), e.getTriangleEdges();\n    },\n    getPrimaryEdges: function getPrimaryEdges(t) {\n      this.visitedKey++;\n      var e = new I(),\n          n = new pe();\n      n.push(this.startingEdge);\n\n      for (var i = new J(); !n.empty();) {\n        var r = n.pop();\n\n        if (!i.contains(r)) {\n          var s = r.getPrimary();\n          !t && this.isFrameEdge(s) || e.add(s), n.push(r.oNext()), n.push(r.sym().oNext()), i.add(r), i.add(r.sym());\n        }\n      }\n\n      return e;\n    },\n    delete: function _delete(t) {\n      bs.splice(t, t.oPrev()), bs.splice(t.sym(), t.sym().oPrev());\n      var e = t.sym(),\n          n = t.rot(),\n          i = t.rot().sym();\n      this.quadEdges.remove(t), this.quadEdges.remove(e), this.quadEdges.remove(n), this.quadEdges.remove(i), t.delete(), e.delete(), n.delete(), i.delete();\n    },\n    locateFromEdge: function locateFromEdge(t, e) {\n      for (var n = 0, i = this.quadEdges.size(), r = e;;) {\n        if (n++, n > i) throw new Ds(r.toLineSegment());\n        if (t.equals(r.orig()) || t.equals(r.dest())) break;\n        if (t.rightOf(r)) r = r.sym();else if (t.rightOf(r.oNext())) {\n          if (t.rightOf(r.dPrev())) break;\n          r = r.dPrev();\n        } else r = r.oNext();\n      }\n\n      return r;\n    },\n    getTolerance: function getTolerance() {\n      return this.tolerance;\n    },\n    getVoronoiCellPolygons: function getVoronoiCellPolygons(t) {\n      this.visitTriangles(new Gs(), !0);\n\n      for (var e = new I(), n = this.getVertexUniqueEdges(!1), i = n.iterator(); i.hasNext();) {\n        var r = i.next();\n        e.add(this.getVoronoiCellPolygon(r, t));\n      }\n\n      return e;\n    },\n    getVoronoiDiagram: function getVoronoiDiagram(t) {\n      var e = this.getVoronoiCellPolygons(t);\n      return t.createGeometryCollection(ie.toGeometryArray(e));\n    },\n    getTriangles: function getTriangles(t) {\n      for (var e = this.getTriangleCoordinates(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext();) {\n        var s = r.next();\n        n[i++] = t.createPolygon(t.createLinearRing(s), null);\n      }\n\n      return t.createGeometryCollection(n);\n    },\n    insertSite: function insertSite(t) {\n      var e = this.locate(t);\n      if (t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance)) return e;\n      var n = this.makeEdge(e.orig(), t);\n      bs.splice(n, e);\n      var i = n;\n\n      do {\n        n = this.connect(e, n.sym()), e = n.oPrev();\n      } while (e.lNext() !== i);\n\n      return i;\n    },\n    locate: function locate() {\n      if (1 === arguments.length) {\n        if (arguments[0] instanceof Ts) {\n          var t = arguments[0];\n          return this.locator.locate(t);\n        }\n\n        if (arguments[0] instanceof g) {\n          var e = arguments[0];\n          return this.locator.locate(new Ts(e));\n        }\n      } else if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            r = this.locator.locate(new Ts(n));\n        if (null === r) return null;\n        var s = r;\n        r.dest().getCoordinate().equals2D(n) && (s = r.sym());\n        var o = s;\n\n        do {\n          if (o.dest().getCoordinate().equals2D(i)) return o;\n          o = o.oNext();\n        } while (o !== s);\n\n        return null;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Fs;\n    }\n  }), Fs.getTriangleEdges = function (t, e) {\n    if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() !== e[0]) throw new i(\"Edges do not form a triangle\");\n  }, e(Gs.prototype, {\n    visit: function visit(t) {\n      for (var e = t[0].orig().getCoordinate(), n = t[1].orig().getCoordinate(), i = t[2].orig().getCoordinate(), r = ci.circumcentre(e, n, i), s = new Ts(r), o = 0; 3 > o; o++) {\n        t[o].rot().setOrig(s);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [As];\n    },\n    getClass: function getClass() {\n      return Gs;\n    }\n  }), e(qs.prototype, {\n    getTriangleEdges: function getTriangleEdges() {\n      return this.triList;\n    },\n    visit: function visit(t) {\n      this.triList.add(t.clone());\n    },\n    interfaces_: function interfaces_() {\n      return [As];\n    },\n    getClass: function getClass() {\n      return qs;\n    }\n  }), e(Bs.prototype, {\n    visit: function visit(t) {\n      this.triList.add([t[0].orig(), t[1].orig(), t[2].orig()]);\n    },\n    getTriangleVertices: function getTriangleVertices() {\n      return this.triList;\n    },\n    interfaces_: function interfaces_() {\n      return [As];\n    },\n    getClass: function getClass() {\n      return Bs;\n    }\n  }), e(zs.prototype, {\n    checkTriangleSize: function checkTriangleSize(t) {\n      var e = \"\";\n      t.length >= 2 ? e = se.toLineString(t[0], t[1]) : t.length >= 1 && (e = se.toPoint(t[0]));\n    },\n    visit: function visit(t) {\n      this.coordList.clear();\n\n      for (var e = 0; 3 > e; e++) {\n        var n = t[e].orig();\n        this.coordList.add(n.getCoordinate());\n      }\n\n      if (this.coordList.size() > 0) {\n        this.coordList.closeRing();\n        var i = this.coordList.toCoordinateArray();\n        if (4 !== i.length) return null;\n        this.triCoords.add(i);\n      }\n    },\n    getTriangles: function getTriangles() {\n      return this.triCoords;\n    },\n    interfaces_: function interfaces_() {\n      return [As];\n    },\n    getClass: function getClass() {\n      return zs;\n    }\n  }), Fs.TriangleCircumcentreVisitor = Gs, Fs.TriangleEdgesListVisitor = qs, Fs.TriangleVertexListVisitor = Bs, Fs.TriangleCoordinatesVisitor = zs, Fs.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, e(Vs.prototype, {\n    getLineSegment: function getLineSegment() {\n      return this.ls;\n    },\n    getEndZ: function getEndZ() {\n      var t = this.ls.getCoordinate(1);\n      return t.z;\n    },\n    getStartZ: function getStartZ() {\n      var t = this.ls.getCoordinate(0);\n      return t.z;\n    },\n    intersection: function intersection(t) {\n      return this.ls.intersection(t.getLineSegment());\n    },\n    getStart: function getStart() {\n      return this.ls.getCoordinate(0);\n    },\n    getEnd: function getEnd() {\n      return this.ls.getCoordinate(1);\n    },\n    getEndY: function getEndY() {\n      var t = this.ls.getCoordinate(1);\n      return t.y;\n    },\n    getStartX: function getStartX() {\n      var t = this.ls.getCoordinate(0);\n      return t.x;\n    },\n    equalsTopo: function equalsTopo(t) {\n      return this.ls.equalsTopo(t.getLineSegment());\n    },\n    getStartY: function getStartY() {\n      var t = this.ls.getCoordinate(0);\n      return t.y;\n    },\n    setData: function setData(t) {\n      this.data = t;\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    getEndX: function getEndX() {\n      var t = this.ls.getCoordinate(1);\n      return t.x;\n    },\n    toString: function toString() {\n      return this.ls.toString();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Vs;\n    }\n  }), e(ks.prototype, {\n    visit: function visit(t) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ks;\n    }\n  }), e(Ys.prototype, {\n    isRepeated: function isRepeated() {\n      return this.count > 1;\n    },\n    getRight: function getRight() {\n      return this.right;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.p;\n    },\n    setLeft: function setLeft(t) {\n      this.left = t;\n    },\n    getX: function getX() {\n      return this.p.x;\n    },\n    getData: function getData() {\n      return this.data;\n    },\n    getCount: function getCount() {\n      return this.count;\n    },\n    getLeft: function getLeft() {\n      return this.left;\n    },\n    getY: function getY() {\n      return this.p.y;\n    },\n    increment: function increment() {\n      this.count = this.count + 1;\n    },\n    setRight: function setRight(t) {\n      this.right = t;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ys;\n    }\n  }), e(Us.prototype, {\n    insert: function insert() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return this.insert(t, null);\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        if (null === this.root) return this.root = new Ys(e, n), this.root;\n\n        if (this.tolerance > 0) {\n          var i = this.findBestMatchNode(e);\n          if (null !== i) return i.increment(), i;\n        }\n\n        return this.insertExact(e, n);\n      }\n    },\n    query: function query() {\n      var t = arguments,\n          e = this;\n\n      if (1 === arguments.length) {\n        var n = arguments[0],\n            i = new I();\n        return this.query(n, i), i;\n      }\n\n      if (2 === arguments.length) if (arguments[0] instanceof C && R(arguments[1], y)) !function () {\n        var n = t[0],\n            i = t[1];\n        e.queryNode(e.root, n, !0, {\n          interfaces_: function interfaces_() {\n            return [ks];\n          },\n          visit: function visit(t) {\n            i.add(t);\n          }\n        });\n      }();else if (arguments[0] instanceof C && R(arguments[1], ks)) {\n        var r = arguments[0],\n            s = arguments[1];\n        this.queryNode(this.root, r, !0, s);\n      }\n    },\n    queryNode: function queryNode(t, e, n, i) {\n      if (null === t) return null;\n      var r = null,\n          s = null,\n          o = null;\n      n ? (r = e.getMinX(), s = e.getMaxX(), o = t.getX()) : (r = e.getMinY(), s = e.getMaxY(), o = t.getY());\n      var a = o > r,\n          u = s >= o;\n      a && this.queryNode(t.getLeft(), e, !n, i), e.contains(t.getCoordinate()) && i.visit(t), u && this.queryNode(t.getRight(), e, !n, i);\n    },\n    findBestMatchNode: function findBestMatchNode(t) {\n      var e = new Xs(t, this.tolerance);\n      return this.query(e.queryEnvelope(), e), e.getNode();\n    },\n    isEmpty: function isEmpty() {\n      return null === this.root;\n    },\n    insertExact: function insertExact(t, e) {\n      for (var n = this.root, i = this.root, r = !0, s = !0; null !== n;) {\n        if (null !== n) {\n          var o = t.distance(n.getCoordinate()) <= this.tolerance;\n          if (o) return n.increment(), n;\n        }\n\n        s = r ? t.x < n.getX() : t.y < n.getY(), i = n, n = s ? n.getLeft() : n.getRight(), r = !r;\n      }\n\n      this.numberOfNodes = this.numberOfNodes + 1;\n      var a = new Ys(t, e);\n      return s ? i.setLeft(a) : i.setRight(a), a;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Us;\n    }\n  }), Us.toCoordinates = function () {\n    if (1 === arguments.length) {\n      var t = arguments[0];\n      return Us.toCoordinates(t, !1);\n    }\n\n    if (2 === arguments.length) {\n      for (var e = arguments[0], n = arguments[1], i = new N(), r = e.iterator(); r.hasNext();) {\n        for (var s = r.next(), o = n ? s.getCount() : 1, a = 0; o > a; a++) {\n          i.add(s.getCoordinate(), !0);\n        }\n      }\n\n      return i.toCoordinateArray();\n    }\n  }, e(Xs.prototype, {\n    visit: function visit(t) {\n      var e = this.p.distance(t.getCoordinate()),\n          n = e <= this.tolerance;\n      if (!n) return null;\n      var i = !1;\n      (null === this.matchNode || e < this.matchDist || null !== this.matchNode && e === this.matchDist && t.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (i = !0), i && (this.matchNode = t, this.matchDist = e);\n    },\n    queryEnvelope: function queryEnvelope() {\n      var t = new C(this.p);\n      return t.expandBy(this.tolerance), t;\n    },\n    getNode: function getNode() {\n      return this.matchNode;\n    },\n    interfaces_: function interfaces_() {\n      return [ks];\n    },\n    getClass: function getClass() {\n      return Xs;\n    }\n  }), Us.BestMatchVisitor = Xs, e(Hs.prototype, {\n    getInitialVertices: function getInitialVertices() {\n      return this.initialVertices;\n    },\n    getKDT: function getKDT() {\n      return this.kdt;\n    },\n    enforceConstraints: function enforceConstraints() {\n      this.addConstraintVertices();\n      var t = 0,\n          e = 0;\n\n      do {\n        e = this.enforceGabriel(this.segments), t++;\n      } while (e > 0 && t < Hs.MAX_SPLIT_ITER);\n    },\n    insertSites: function insertSites(t) {\n      for (var e = t.iterator(); e.hasNext();) {\n        var n = e.next();\n        this.insertSite(n);\n      }\n    },\n    getVertexFactory: function getVertexFactory() {\n      return this.vertexFactory;\n    },\n    getPointArray: function getPointArray() {\n      for (var t = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e = 0, n = this.initialVertices.iterator(); n.hasNext();) {\n        var i = n.next();\n        t[e++] = i.getCoordinate();\n      }\n\n      for (var r = this.segVertices.iterator(); r.hasNext();) {\n        var i = r.next();\n        t[e++] = i.getCoordinate();\n      }\n\n      return t;\n    },\n    setConstraints: function setConstraints(t, e) {\n      this.segments = t, this.segVertices = e;\n    },\n    computeConvexHull: function computeConvexHull() {\n      var t = new ie(),\n          e = this.getPointArray(),\n          n = new me(e, t);\n      this.convexHull = n.getConvexHull();\n    },\n    addConstraintVertices: function addConstraintVertices() {\n      this.computeConvexHull(), this.insertSites(this.segVertices);\n    },\n    findNonGabrielPoint: function findNonGabrielPoint(t) {\n      var e = t.getStart(),\n          n = t.getEnd(),\n          i = new g((e.x + n.x) / 2, (e.y + n.y) / 2),\n          s = e.distance(i),\n          o = new C(i);\n      o.expandBy(s);\n\n      for (var a = this.kdt.query(o), u = null, l = r.MAX_VALUE, h = a.iterator(); h.hasNext();) {\n        var c = h.next(),\n            f = c.getCoordinate();\n\n        if (!f.equals2D(e) && !f.equals2D(n)) {\n          var d = i.distance(f);\n\n          if (s > d) {\n            var p = d;\n            (null === u || l > p) && (u = f, l = p);\n          }\n        }\n      }\n\n      return u;\n    },\n    getConstraintSegments: function getConstraintSegments() {\n      return this.segments;\n    },\n    setSplitPointFinder: function setSplitPointFinder(t) {\n      this.splitFinder = t;\n    },\n    getConvexHull: function getConvexHull() {\n      return this.convexHull;\n    },\n    getTolerance: function getTolerance() {\n      return this.tolerance;\n    },\n    enforceGabriel: function enforceGabriel(t) {\n      for (var e = new I(), n = 0, i = new I(), r = t.iterator(); r.hasNext();) {\n        var s = r.next(),\n            o = this.findNonGabrielPoint(s);\n\n        if (null !== o) {\n          this.splitPt = this.splitFinder.findSplitPoint(s, o);\n          var a = this.createVertex(this.splitPt, s),\n              u = (this.insertSite(a), new Vs(s.getStartX(), s.getStartY(), s.getStartZ(), a.getX(), a.getY(), a.getZ(), s.getData())),\n              l = new Vs(a.getX(), a.getY(), a.getZ(), s.getEndX(), s.getEndY(), s.getEndZ(), s.getData());\n          e.add(u), e.add(l), i.add(s), n += 1;\n        }\n      }\n\n      return t.removeAll(i), t.addAll(e), n;\n    },\n    createVertex: function createVertex() {\n      if (1 === arguments.length) {\n        var t = arguments[0],\n            e = null;\n        return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(t, null) : new Ps(t);\n      }\n\n      if (2 === arguments.length) {\n        var n = arguments[0],\n            i = arguments[1],\n            e = null;\n        return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(n, i) : new Ps(n), e.setOnConstraint(!0), e;\n      }\n    },\n    getSubdivision: function getSubdivision() {\n      return this.subdiv;\n    },\n    computeBoundingBox: function computeBoundingBox() {\n      var t = Hs.computeVertexEnvelope(this.initialVertices),\n          e = Hs.computeVertexEnvelope(this.segVertices),\n          n = new C(t);\n      n.expandToInclude(e);\n      var i = .2 * n.getWidth(),\n          r = .2 * n.getHeight(),\n          s = Math.max(i, r);\n      this.computeAreaEnv = new C(n), this.computeAreaEnv.expandBy(s);\n    },\n    setVertexFactory: function setVertexFactory(t) {\n      this.vertexFactory = t;\n    },\n    formInitialDelaunay: function formInitialDelaunay() {\n      this.computeBoundingBox(), this.subdiv = new Fs(this.computeAreaEnv, this.tolerance), this.subdiv.setLocator(new Ms(this.subdiv)), this.incDel = new Os(this.subdiv), this.insertSites(this.initialVertices);\n    },\n    insertSite: function insertSite() {\n      if (arguments[0] instanceof Ps) {\n        var t = arguments[0],\n            e = this.kdt.insert(t.getCoordinate(), t);\n\n        if (e.isRepeated()) {\n          var n = e.getData();\n          return n.merge(t), n;\n        }\n\n        return this.incDel.insertSite(t), t;\n      }\n\n      if (arguments[0] instanceof g) {\n        var i = arguments[0];\n        this.insertSite(this.createVertex(i));\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Hs;\n    }\n  }), Hs.computeVertexEnvelope = function (t) {\n    for (var e = new C(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e.expandToInclude(i.getCoordinate());\n    }\n\n    return e;\n  }, Hs.MAX_SPLIT_ITER = 99, e(Ws.prototype, {\n    create: function create() {\n      if (null !== this.subdiv) return null;\n      var t = Ws.envelope(this.siteCoords),\n          e = Ws.toVertices(this.siteCoords);\n      this.subdiv = new Fs(t, this.tolerance);\n      var n = new Os(this.subdiv);\n      n.insertSites(e);\n    },\n    setTolerance: function setTolerance(t) {\n      this.tolerance = t;\n    },\n    setSites: function setSites() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        this.siteCoords = Ws.extractUniqueCoordinates(t);\n      } else if (R(arguments[0], v)) {\n        var e = arguments[0];\n        this.siteCoords = Ws.unique(H.toCoordinateArray(e));\n      }\n    },\n    getEdges: function getEdges(t) {\n      return this.create(), this.subdiv.getEdges(t);\n    },\n    getSubdivision: function getSubdivision() {\n      return this.create(), this.subdiv;\n    },\n    getTriangles: function getTriangles(t) {\n      return this.create(), this.subdiv.getTriangles(t);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ws;\n    }\n  }), Ws.extractUniqueCoordinates = function (t) {\n    if (null === t) return new N();\n    var e = t.getCoordinates();\n    return Ws.unique(e);\n  }, Ws.envelope = function (t) {\n    for (var e = new C(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e.expandToInclude(i);\n    }\n\n    return e;\n  }, Ws.unique = function (t) {\n    var e = H.copyDeep(t);\n    ut.sort(e);\n    var n = new N(e, !1);\n    return n;\n  }, Ws.toVertices = function (t) {\n    for (var e = new I(), n = t.iterator(); n.hasNext();) {\n      var i = n.next();\n      e.add(new Ts(i));\n    }\n\n    return e;\n  }, e(js.prototype, {\n    createSiteVertices: function createSiteVertices(t) {\n      for (var e = new I(), n = t.iterator(); n.hasNext();) {\n        var i = n.next();\n        this.constraintVertexMap.containsKey(i) || e.add(new Ps(i));\n      }\n\n      return e;\n    },\n    create: function create() {\n      if (null !== this.subdiv) return null;\n      var t = Ws.envelope(this.siteCoords),\n          e = new I();\n      null !== this.constraintLines && (t.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), e = js.createConstraintSegments(this.constraintLines));\n      var n = this.createSiteVertices(this.siteCoords),\n          i = new Hs(n, this.tolerance);\n      i.setConstraints(e, new I(this.constraintVertexMap.values())), i.formInitialDelaunay(), i.enforceConstraints(), this.subdiv = i.getSubdivision();\n    },\n    setTolerance: function setTolerance(t) {\n      this.tolerance = t;\n    },\n    setConstraints: function setConstraints(t) {\n      this.constraintLines = t;\n    },\n    setSites: function setSites(t) {\n      this.siteCoords = Ws.extractUniqueCoordinates(t);\n    },\n    getEdges: function getEdges(t) {\n      return this.create(), this.subdiv.getEdges(t);\n    },\n    getSubdivision: function getSubdivision() {\n      return this.create(), this.subdiv;\n    },\n    getTriangles: function getTriangles(t) {\n      return this.create(), this.subdiv.getTriangles(t);\n    },\n    createVertices: function createVertices(t) {\n      for (var e = t.getCoordinates(), n = 0; n < e.length; n++) {\n        var i = new Ps(e[n]);\n        this.constraintVertexMap.put(e[n], i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return js;\n    }\n  }), js.createConstraintSegments = function () {\n    if (1 === arguments.length) {\n      for (var t = arguments[0], e = kn.getLines(t), n = new I(), i = e.iterator(); i.hasNext();) {\n        var r = i.next();\n        js.createConstraintSegments(r, n);\n      }\n\n      return n;\n    }\n\n    if (2 === arguments.length) for (var s = arguments[0], o = arguments[1], a = s.getCoordinates(), i = 1; i < a.length; i++) {\n      o.add(new Vs(a[i - 1], a[i]));\n    }\n  }, e(Ks.prototype, {\n    create: function create() {\n      if (null !== this.subdiv) return null;\n      var t = Ws.envelope(this.siteCoords);\n      this.diagramEnv = t;\n      var e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());\n      this.diagramEnv.expandBy(e), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);\n      var n = Ws.toVertices(this.siteCoords);\n      this.subdiv = new Fs(t, this.tolerance);\n      var i = new Os(this.subdiv);\n      i.insertSites(n);\n    },\n    getDiagram: function getDiagram(t) {\n      this.create();\n      var e = this.subdiv.getVoronoiDiagram(t);\n      return Ks.clipGeometryCollection(e, this.diagramEnv);\n    },\n    setTolerance: function setTolerance(t) {\n      this.tolerance = t;\n    },\n    setSites: function setSites() {\n      if (arguments[0] instanceof B) {\n        var t = arguments[0];\n        this.siteCoords = Ws.extractUniqueCoordinates(t);\n      } else if (R(arguments[0], v)) {\n        var e = arguments[0];\n        this.siteCoords = Ws.unique(H.toCoordinateArray(e));\n      }\n    },\n    setClipEnvelope: function setClipEnvelope(t) {\n      this.clipEnv = t;\n    },\n    getSubdivision: function getSubdivision() {\n      return this.create(), this.subdiv;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Ks;\n    }\n  }), Ks.clipGeometryCollection = function (t, e) {\n    for (var n = t.getFactory().toGeometry(e), i = new I(), r = 0; r < t.getNumGeometries(); r++) {\n      var s = t.getGeometryN(r),\n          o = null;\n      e.contains(s.getEnvelopeInternal()) ? o = s : e.intersects(s.getEnvelopeInternal()) && (o = n.intersection(s), o.setUserData(s.getUserData())), null === o || o.isEmpty() || i.add(o);\n    }\n\n    return t.getFactory().createGeometryCollection(ie.toGeometryArray(i));\n  };\n  var Do = Object.freeze({\n    ConformingDelaunayTriangulationBuilder: js,\n    DelaunayTriangulationBuilder: Ws,\n    VoronoiDiagramBuilder: Ks\n  });\n  e(Zs.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Zs;\n    }\n  }), Zs.union = function (t, e) {\n    if (t.isEmpty() || e.isEmpty()) {\n      if (t.isEmpty() && e.isEmpty()) return ii.createEmptyResult(ii.UNION, t, e, t.getFactory());\n      if (t.isEmpty()) return e.copy();\n      if (e.isEmpty()) return t.copy();\n    }\n\n    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), si.overlayOp(t, e, ii.UNION);\n  }, e(B.prototype, {\n    equalsTopo: function equalsTopo(t) {\n      return this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) ? Yr.relate(this, t).isEquals(this.getDimension(), t.getDimension()) : !1;\n    },\n    union: function union() {\n      if (0 === arguments.length) return jr.union(this);\n\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return Zs.union(this, t);\n      }\n    },\n    isValid: function isValid() {\n      return ls.isValid(this);\n    },\n    intersection: function intersection(t) {\n      if (this.isEmpty() || t.isEmpty()) return ii.createEmptyResult(ii.INTERSECTION, this, t, this.factory);\n\n      if (this.isGeometryCollection()) {\n        var e = t;\n        return hn.map(this, {\n          interfaces_: function interfaces_() {\n            return [MapOp];\n          },\n          map: function map(t) {\n            return t.intersection(e);\n          }\n        });\n      }\n\n      return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.INTERSECTION);\n    },\n    covers: function covers(t) {\n      return Yr.covers(this, t);\n    },\n    coveredBy: function coveredBy(t) {\n      return Yr.coveredBy(this, t);\n    },\n    touches: function touches(t) {\n      return Yr.touches(this, t);\n    },\n    intersects: function intersects(t) {\n      return Yr.intersects(this, t);\n    },\n    within: function within(t) {\n      return Yr.within(this, t);\n    },\n    overlaps: function overlaps(t) {\n      return Yr.overlaps(this, t);\n    },\n    disjoint: function disjoint(t) {\n      return Yr.disjoint(this, t);\n    },\n    crosses: function crosses(t) {\n      return Yr.crosses(this, t);\n    },\n    buffer: function buffer() {\n      if (1 === arguments.length) {\n        var t = arguments[0];\n        return sr.bufferOp(this, t);\n      }\n\n      if (2 === arguments.length) {\n        var e = arguments[0],\n            n = arguments[1];\n        return sr.bufferOp(this, e, n);\n      }\n\n      if (3 === arguments.length) {\n        var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n        return sr.bufferOp(this, i, r, s);\n      }\n    },\n    convexHull: function convexHull() {\n      return new me(this).getConvexHull();\n    },\n    relate: function relate() {\n      for (var t = arguments.length, e = Array(t), n = 0; t > n; n++) {\n        e[n] = arguments[n];\n      }\n\n      return Yr.relate.apply(Yr, [this].concat(e));\n    },\n    getCentroid: function getCentroid() {\n      if (this.isEmpty()) return this.factory.createPoint();\n      var t = ge.getCentroid(this);\n      return this.createPointFromInternalCoord(t, this);\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      if (this.isEmpty()) return this.factory.createPoint();\n      var t = null,\n          e = this.getDimension();\n\n      if (0 === e) {\n        var n = new li(this);\n        t = n.getInteriorPoint();\n      } else if (1 === e) {\n        var n = new ui(this);\n        t = n.getInteriorPoint();\n      } else {\n        var n = new oi(this);\n        t = n.getInteriorPoint();\n      }\n\n      return this.createPointFromInternalCoord(t, this);\n    },\n    symDifference: function symDifference(t) {\n      if (this.isEmpty() || t.isEmpty()) {\n        if (this.isEmpty() && t.isEmpty()) return ii.createEmptyResult(ii.SYMDIFFERENCE, this, t, this.factory);\n        if (this.isEmpty()) return t.copy();\n        if (t.isEmpty()) return this.copy();\n      }\n\n      return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.SYMDIFFERENCE);\n    },\n    createPointFromInternalCoord: function createPointFromInternalCoord(t, e) {\n      return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n    },\n    toText: function toText() {\n      var t = new se();\n      return t.write(this);\n    },\n    toString: function toString() {\n      this.toText();\n    },\n    contains: function contains(t) {\n      return Yr.contains(this, t);\n    },\n    difference: function difference(t) {\n      return this.isEmpty() ? ii.createEmptyResult(ii.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), si.overlayOp(this, t, ii.DIFFERENCE));\n    },\n    isSimple: function isSimple() {\n      var t = new Gi(this);\n      return t.isSimple();\n    },\n    isWithinDistance: function isWithinDistance(t, e) {\n      var n = this.getEnvelopeInternal().distance(t.getEnvelopeInternal());\n      return n > e ? !1 : hr.isWithinDistance(this, t, e);\n    },\n    distance: function distance(t) {\n      return hr.distance(this, t);\n    },\n    isEquivalentClass: function isEquivalentClass(t) {\n      return this.getClass() === t.getClass();\n    }\n  });\n  var Ao = \"1.1.2 (248dab8)\";\n  t.version = Ao, t.algorithm = co, t.densify = fo, t.dissolve = go, t.geom = lo, t.index = mo, t.io = Io, t.noding = No, t.operation = Oo, t.precision = _o, t.simplify = Mo, t.triangulate = Do;\n});","map":null,"metadata":{},"sourceType":"script"}