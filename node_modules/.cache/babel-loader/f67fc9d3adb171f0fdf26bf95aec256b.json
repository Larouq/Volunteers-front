{"ast":null,"code":"var point = require('turf-helpers').point;\n\nvar polygon = require('turf-helpers').polygon;\n\nvar distance = require('turf-distance');\n\nvar featurecollection = require('turf-helpers').featureCollection; //Precompute cosines and sines of angles used in hexagon creation\n// for performance gain\n\n\nvar cosines = [];\nvar sines = [];\n\nfor (var i = 0; i < 6; i++) {\n  var angle = 2 * Math.PI / 6 * i;\n  cosines.push(Math.cos(angle));\n  sines.push(Math.sin(angle));\n}\n/**\n * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped\n * hexagons ({@link Polygon} features) aligned in an \"odd-q\" vertical grid as\n * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).\n *\n * @name hexGrid\n * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order\n * @param {number} cellSize dimension of cell in specified units\n * @param {string} units used in calculating cellWidth ('miles' or 'kilometers')\n * @param {boolean} triangles whether to return as triangles instead of hexagons\n * @return {FeatureCollection<Polygon>} a hexagonal grid\n * @example\n * var bbox = [-96,31,-84,40];\n * var cellWidth = 50;\n * var units = 'miles';\n *\n * var hexgrid = turf.hexGrid(bbox, cellWidth, units);\n *\n * //=hexgrid\n */\n\n\nmodule.exports = function hexGrid(bbox, cellSize, units, triangles) {\n  var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);\n  var cellWidth = xFraction * (bbox[2] - bbox[0]);\n  var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);\n  var cellHeight = yFraction * (bbox[3] - bbox[1]);\n  var radius = cellWidth / 2;\n  var hex_width = radius * 2;\n  var hex_height = Math.sqrt(3) / 2 * cellHeight;\n  var box_width = bbox[2] - bbox[0];\n  var box_height = bbox[3] - bbox[1];\n  var x_interval = 3 / 4 * hex_width;\n  var y_interval = hex_height;\n  var x_span = box_width / (hex_width - radius / 2);\n  var x_count = Math.ceil(x_span);\n\n  if (Math.round(x_span) === x_count) {\n    x_count++;\n  }\n\n  var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2;\n  var y_count = Math.ceil(box_height / hex_height);\n  var y_adjust = (box_height - y_count * hex_height) / 2;\n  var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n\n  if (hasOffsetY) {\n    y_adjust -= hex_height / 4;\n  }\n\n  var fc = featurecollection([]);\n\n  for (var x = 0; x < x_count; x++) {\n    for (var y = 0; y <= y_count; y++) {\n      var isOdd = x % 2 === 1;\n\n      if (y === 0 && isOdd) {\n        continue;\n      }\n\n      if (y === 0 && hasOffsetY) {\n        continue;\n      }\n\n      var center_x = x * x_interval + bbox[0] - x_adjust;\n      var center_y = y * y_interval + bbox[1] + y_adjust;\n\n      if (isOdd) {\n        center_y -= hex_height / 2;\n      }\n\n      if (triangles) {\n        fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));\n      } else {\n        fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));\n      }\n    }\n  }\n\n  return fc;\n}; //Center should be [x, y]\n\n\nfunction hexagon(center, rx, ry) {\n  var vertices = [];\n\n  for (var i = 0; i < 6; i++) {\n    var x = center[0] + rx * cosines[i];\n    var y = center[1] + ry * sines[i];\n    vertices.push([x, y]);\n  } //first and last vertex must be the same\n\n\n  vertices.push(vertices[0]);\n  return polygon([vertices]);\n} //Center should be [x, y]\n\n\nfunction hexTriangles(center, rx, ry) {\n  var triangles = [];\n\n  for (var i = 0; i < 6; i++) {\n    var vertices = [];\n    vertices.push(center);\n    vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);\n    vertices.push([center[0] + rx * cosines[(i + 1) % 6], center[1] + ry * sines[(i + 1) % 6]]);\n    vertices.push(center);\n    triangles.push(polygon([vertices]));\n  }\n\n  return triangles;\n}","map":null,"metadata":{},"sourceType":"script"}