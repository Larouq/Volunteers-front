{"ast":null,"code":"var simplify = require('simplify-js'); // supported GeoJSON geometries, used to check whether to wrap in simpleFeature()\n\n\nvar supportedTypes = ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n/**\n * Takes a {@link LineString} or {@link Polygon} and returns a simplified version. Internally uses [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.\n *\n * @name simplify\n * @param {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} feature feature to be simplified\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create\n * a higher-quality simplification with a different algorithm\n * @return {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} a simplified feature\n * @example\n  * var feature = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-70.603637, -33.399918],\n *       [-70.614624, -33.395332],\n *       [-70.639343, -33.392466],\n *       [-70.659942, -33.394759],\n *       [-70.683975, -33.404504],\n *       [-70.697021, -33.419406],\n *       [-70.701141, -33.434306],\n *       [-70.700454, -33.446339],\n *       [-70.694274, -33.458369],\n *       [-70.682601, -33.465816],\n *       [-70.668869, -33.472117],\n *       [-70.646209, -33.473835],\n *       [-70.624923, -33.472117],\n *       [-70.609817, -33.468107],\n *       [-70.595397, -33.458369],\n *       [-70.587158, -33.442901],\n *       [-70.587158, -33.426283],\n *       [-70.590591, -33.414248],\n *       [-70.594711, -33.406224],\n *       [-70.603637, -33.399918]\n *     ]]\n *   }\n * };\n\n * var tolerance = 0.01;\n *\n * var simplified = turf.simplify(\n *  feature, tolerance, false);\n *\n * //=feature\n *\n * //=simplified\n */\n\nmodule.exports = function (feature, tolerance, highQuality) {\n  if (feature.type === 'Feature') {\n    return simpleFeature(simplifyHelper(feature, tolerance, highQuality), feature.properties);\n  } else if (feature.type === 'FeatureCollection') {\n    return {\n      type: 'FeatureCollection',\n      features: feature.features.map(function (f) {\n        var simplified = simplifyHelper(f, tolerance, highQuality); // we create simpleFeature here because it doesn't apply to GeometryCollection\n        // so we can't create it at simplifyHelper()\n\n        if (supportedTypes.indexOf(simplified.type) > -1) {\n          return simpleFeature(simplified, f.properties);\n        } else {\n          return simplified;\n        }\n      })\n    };\n  } else if (feature.type === 'GeometryCollection') {\n    return {\n      type: 'GeometryCollection',\n      geometries: feature.geometries.map(function (g) {\n        if (supportedTypes.indexOf(g.type) > -1) {\n          return simplifyHelper({\n            type: 'Feature',\n            geometry: g\n          }, tolerance, highQuality);\n        }\n\n        return g;\n      })\n    };\n  } else {\n    return feature;\n  }\n};\n\nfunction simplifyHelper(feature, tolerance, highQuality) {\n  if (feature.geometry.type === 'LineString') {\n    return {\n      type: 'LineString',\n      coordinates: simplifyLine(feature.geometry.coordinates, tolerance, highQuality)\n    };\n  } else if (feature.geometry.type === 'MultiLineString') {\n    return {\n      type: 'MultiLineString',\n      coordinates: feature.geometry.coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      })\n    };\n  } else if (feature.geometry.type === 'Polygon') {\n    return {\n      type: 'Polygon',\n      coordinates: simplifyPolygon(feature.geometry.coordinates, tolerance, highQuality)\n    };\n  } else if (feature.geometry.type === 'MultiPolygon') {\n    return {\n      type: 'MultiPolygon',\n      coordinates: feature.geometry.coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      })\n    };\n  } else {\n    // unsupported geometry type supplied\n    return feature;\n  }\n}\n/*\n* returns true if ring's first coordinate is the same as its last\n*/\n\n\nfunction checkValidity(ring) {\n  if (ring.length < 3) {\n    return false; //if the last point is the same as the first, it's not a triangle\n  } else if (ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction simpleFeature(geom, properties) {\n  return {\n    type: 'Feature',\n    geometry: geom,\n    properties: properties\n  };\n}\n\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(coordinates.map(function (coord) {\n    return {\n      x: coord[0],\n      y: coord[1]\n    };\n  }), tolerance, highQuality).map(function (coords) {\n    return [coords.x, coords.y];\n  });\n}\n\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return {\n        x: coord[0],\n        y: coord[1]\n      };\n    });\n\n    if (pts.length < 4) {\n      throw new Error('Invalid polygon');\n    }\n\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {\n      return [coords.x, coords.y];\n    }); //remove 1 percent of tolerance until enough points to make a triangle\n\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {\n        return [coords.x, coords.y];\n      });\n    }\n\n    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n      simpleRing.push(simpleRing[0]);\n    }\n\n    return simpleRing;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}