{"ast":null,"code":"/**\n * Takes a {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<Polygon>|Polygon} polygon input polygon\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-12.034835, 8.901183],\n *       [-12.060413, 8.899826],\n *       [-12.03638, 8.873199],\n *       [-12.059383, 8.871418],\n *       [-12.034835, 8.901183]\n *     ]]\n *   }\n * };\n *\n * var kinks = turf.kinks(poly);\n *\n * var resultFeatures = kinks.intersections.features.concat(poly);\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": resultFeatures\n * };\n *\n * //=result\n */\nvar point = require('turf-helpers').point;\n\nmodule.exports = function (polyIn) {\n  var poly;\n  var results = {\n    type: 'FeatureCollection',\n    features: []\n  };\n\n  if (polyIn.type === 'Feature') {\n    poly = polyIn.geometry;\n  } else {\n    poly = polyIn;\n  }\n\n  poly.coordinates.forEach(function (ring1) {\n    poly.coordinates.forEach(function (ring2) {\n      for (var i = 0; i < ring1.length - 1; i++) {\n        for (var k = 0; k < ring2.length - 1; k++) {\n          // don't check adjacent sides of a given ring, since of course they intersect in a vertex.\n          if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n            continue;\n          }\n\n          var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1], ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);\n\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n}; // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n\n\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator,\n      a,\n      b,\n      numerator1,\n      numerator2,\n      result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY); // if line1 is a segment and line2 is infinite, they intersect if:\n\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  } // if line2 is a segment and line1 is infinite, they intersect if:\n\n\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  } // if line1 and line2 are segments, they intersect if both of the above are true\n\n\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}