{"ast":null,"code":"//http://en.wikipedia.org/wiki/Delaunay_triangulation\n//https://github.com/ironwallaby/delaunay\nvar polygon = require('turf-helpers').polygon;\n\nvar featurecollection = require('turf-helpers').featureCollection;\n/**\n * Takes a set of {@link Point|points} and the name of a z-value property and\n * creates a [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),\n * or a TIN for short, returned as a collection of Polygons. These are often used\n * for developing elevation contour maps or stepped heat visualizations.\n *\n * This triangulates the points, as well as adds properties called `a`, `b`,\n * and `c` representing the value of the given `propertyName` at each of\n * the points that represent the corners of the triangle.\n *\n * @name tin\n * @param {FeatureCollection<Point>} points input points\n * @param {String=} z name of the property from which to pull z values\n * This is optional: if not given, then there will be no extra data added to the derived triangles.\n * @return {FeatureCollection<Polygon>} TIN output\n * @example\n * // generate some random point data\n * var points = turf.random('points', 30, {\n *   bbox: [50, 30, 70, 50]\n * });\n * //=points\n * // add a random property to each point between 0 and 9\n * for (var i = 0; i < points.features.length; i++) {\n *   points.features[i].properties.z = ~~(Math.random() * 9);\n * }\n * var tin = turf.tin(points, 'z')\n * for (var i = 0; i < tin.features.length; i++) {\n *   var properties  = tin.features[i].properties;\n *   // roughly turn the properties of each\n *   // triangle into a fill color\n *   // so we can visualize the result\n *   properties.fill = '#' + properties.a +\n *     properties.b + properties.c;\n * }\n * //=tin\n */\n\n\nmodule.exports = function (points, z) {\n  //break down points\n  return featurecollection(triangulate(points.features.map(function (p) {\n    var point = {\n      x: p.geometry.coordinates[0],\n      y: p.geometry.coordinates[1]\n    };\n    if (z) point.z = p.properties[z];\n    return point;\n  })).map(function (triangle) {\n    return polygon([[[triangle.a.x, triangle.a.y], [triangle.b.x, triangle.b.y], [triangle.c.x, triangle.c.y], [triangle.a.x, triangle.a.y]]], {\n      a: triangle.a.z,\n      b: triangle.b.z,\n      c: triangle.c.z\n    });\n  }));\n};\n\nfunction Triangle(a, b, c) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  var A = b.x - a.x,\n      B = b.y - a.y,\n      C = c.x - a.x,\n      D = c.y - a.y,\n      E = A * (a.x + b.x) + B * (a.y + b.y),\n      F = C * (a.x + c.x) + D * (a.y + c.y),\n      G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n      minx,\n      miny,\n      dx,\n      dy; // If the points of the triangle are collinear, then just find the\n  // extremes and use the midpoint as the center of the circumcircle.\n\n  if (Math.abs(G) < 0.000001) {\n    minx = Math.min(a.x, b.x, c.x);\n    miny = Math.min(a.y, b.y, c.y);\n    dx = (Math.max(a.x, b.x, c.x) - minx) * 0.5;\n    dy = (Math.max(a.y, b.y, c.y) - miny) * 0.5;\n    this.x = minx + dx;\n    this.y = miny + dy;\n    this.r = dx * dx + dy * dy;\n  } else {\n    this.x = (D * E - B * F) / G;\n    this.y = (A * F - C * E) / G;\n    dx = this.x - a.x;\n    dy = this.y - a.y;\n    this.r = dx * dx + dy * dy;\n  }\n}\n\nfunction byX(a, b) {\n  return b.x - a.x;\n}\n\nfunction dedup(edges) {\n  var j = edges.length,\n      a,\n      b,\n      i,\n      m,\n      n;\n\n  outer: while (j) {\n    b = edges[--j];\n    a = edges[--j];\n    i = j;\n\n    while (i) {\n      n = edges[--i];\n      m = edges[--i];\n\n      if (a === m && b === n || a === n && b === m) {\n        edges.splice(j, 2);\n        edges.splice(i, 2);\n        j -= 2;\n        continue outer;\n      }\n    }\n  }\n}\n\nfunction triangulate(vertices) {\n  // Bail if there aren't enough vertices to form any triangles.\n  if (vertices.length < 3) return []; // Ensure the vertex array is in order of descending X coordinate\n  // (which is needed to ensure a subquadratic runtime), and then find\n  // the bounding box around the points.\n\n  vertices.sort(byX);\n  var i = vertices.length - 1,\n      xmin = vertices[i].x,\n      xmax = vertices[0].x,\n      ymin = vertices[i].y,\n      ymax = ymin;\n\n  while (i--) {\n    if (vertices[i].y < ymin) ymin = vertices[i].y;\n    if (vertices[i].y > ymax) ymax = vertices[i].y;\n  } //Find a supertriangle, which is a triangle that surrounds all the\n  //vertices. This is used like something of a sentinel value to remove\n  //cases in the main algorithm, and is removed before we return any\n  // results.\n  // Once found, put it in the \"open\" list. (The \"open\" list is for\n  // triangles who may still need to be considered; the \"closed\" list is\n  // for triangles which do not.)\n\n\n  var dx = xmax - xmin,\n      dy = ymax - ymin,\n      dmax = dx > dy ? dx : dy,\n      xmid = (xmax + xmin) * 0.5,\n      ymid = (ymax + ymin) * 0.5,\n      open = [new Triangle({\n    x: xmid - 20 * dmax,\n    y: ymid - dmax,\n    __sentinel: true\n  }, {\n    x: xmid,\n    y: ymid + 20 * dmax,\n    __sentinel: true\n  }, {\n    x: xmid + 20 * dmax,\n    y: ymid - dmax,\n    __sentinel: true\n  })],\n      closed = [],\n      edges = [],\n      j,\n      a,\n      b; // Incrementally add each vertex to the mesh.\n\n  i = vertices.length;\n\n  while (i--) {\n    // For each open triangle, check to see if the current point is\n    // inside it's circumcircle. If it is, remove the triangle and add\n    // it's edges to an edge list.\n    edges.length = 0;\n    j = open.length;\n\n    while (j--) {\n      // If this point is to the right of this triangle's circumcircle,\n      // then this triangle should never get checked again. Remove it\n      // from the open list, add it to the closed list, and skip.\n      dx = vertices[i].x - open[j].x;\n\n      if (dx > 0 && dx * dx > open[j].r) {\n        closed.push(open[j]);\n        open.splice(j, 1);\n        continue;\n      } // If not, skip this triangle.\n\n\n      dy = vertices[i].y - open[j].y;\n      if (dx * dx + dy * dy > open[j].r) continue; // Remove the triangle and add it's edges to the edge list.\n\n      edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n      open.splice(j, 1);\n    } // Remove any doubled edges.\n\n\n    dedup(edges); // Add a new triangle for each edge.\n\n    j = edges.length;\n\n    while (j) {\n      b = edges[--j];\n      a = edges[--j];\n      open.push(new Triangle(a, b, vertices[i]));\n    }\n  } // Copy any remaining open triangles to the closed list, and then\n  // remove any triangles that share a vertex with the supertriangle.\n\n\n  Array.prototype.push.apply(closed, open);\n  i = closed.length;\n\n  while (i--) {\n    if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) closed.splice(i, 1);\n  }\n\n  return closed;\n}","map":null,"metadata":{},"sourceType":"script"}