{"ast":null,"code":"var featureCollection = require('turf-helpers').featureCollection;\n\nvar centroid = require('turf-center');\n\nvar distance = require('turf-distance');\n\nvar inside = require('turf-inside');\n\nvar explode = require('turf-explode');\n/**\n * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @param {(Feature|FeatureCollection)} fc any feature or set of features\n * @returns {Feature} a point on the surface of `input`\n * @example\n * // create a random polygon\n * var polygon = turf.random('polygon');\n *\n * //=polygon\n *\n * var pointOnPolygon = turf.pointOnSurface(polygon);\n *\n* var resultFeatures = polygon.features.concat(pointOnPolygon);\n* var result = {\n*   \"type\": \"FeatureCollection\",\n*   \"features\": resultFeatures\n* };\n *\n * //=result\n */\n\n\nfunction pointOnSurface(fc) {\n  // normalize\n  if (fc.type !== 'FeatureCollection') {\n    if (fc.type !== 'Feature') {\n      fc = {\n        type: 'Feature',\n        geometry: fc,\n        properties: {}\n      };\n    }\n\n    fc = featureCollection([fc]);\n  } //get centroid\n\n\n  var cent = centroid(fc); // check to see if centroid is on surface\n\n  var onSurface = false;\n  var i = 0;\n\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n\n    if (geom.type === 'Point') {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === 'MultiPoint') {\n      var onMultiPoint = false;\n      k = 0;\n\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === 'LineString') {\n      k = 0;\n\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === 'MultiLineString') {\n      var j = 0;\n\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n\n          k++;\n        }\n\n        j++;\n      }\n    } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {\n      var f = {\n        type: 'Feature',\n        geometry: geom,\n        properties: {}\n      };\n\n      if (inside(cent, f)) {\n        onSurface = true;\n      }\n    }\n\n    i++;\n  }\n\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n    }\n\n    var closestVertex;\n    var closestDistance = Infinity;\n\n    for (i = 0; i < vertices.features.length; i++) {\n      var dist = distance(cent, vertices.features[i], 'miles');\n\n      if (dist < closestDistance) {\n        closestDistance = dist;\n        closestVertex = vertices.features[i];\n      }\n    }\n\n    return closestVertex;\n  }\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n\n  if (ab === ap + pb) {\n    return true;\n  }\n}\n\nmodule.exports = pointOnSurface;","map":null,"metadata":{},"sourceType":"script"}